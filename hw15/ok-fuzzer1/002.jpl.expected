global jpl_main
global _jpl_main
extern _fail_assertion
extern _jpl_alloc
extern _get_time
extern _show
extern _print
extern _print_time
extern _read_image
extern _write_image
extern _fmod
extern _sqrt
extern _exp
extern _sin
extern _cos
extern _tan
extern _asin
extern _acos
extern _atan
extern _log
extern _pow
extern _atan2
extern _to_int
extern _to_float

section .data
const0: dq 12.03
const1: dq 77.23
const2: dq 1
const3: dq 69
const4: dq 357
const5: dq 0
const6: dq 305
const7: dq 928
const8: db `divide by zero`, 0
const9: db `non-positive loop bound`, 0
const10: dq 285
const11: dq 436
const12: dq 807
const13: dq 736
const14: dq 915
const15: dq 976
const16: dq 331
const17: dq 726
const18: dq 238
const19: db `overflow computing array size`, 0
const20: dq 207
const21: db `negative array index`, 0
const22: db `index too large`, 0
const23: dq 417
const24: dq 411
const25: dq 453
const26: dq 296
const27: dq 965
const28: dq 279
const29: dq 310
const30: dq 122
const31: dq 419
const32: dq 360
const33: dq 740
const34: dq 938
const35: dq 607
const36: dq 960
const37: dq 261
const38: dq 953
const39: dq 62
const40: dq 570
const41: dq 609
const42: dq 396
const43: dq 858
const44: db `mod by zero`, 0
const45: dq 996
const46: dq 653
const47: dq 289
const48: dq 586
const49: dq 55
const50: dq 986
const51: dq 126
const52: dq 34.74
const53: dq 715
const54: dq 575
const55: dq 725
const56: dq 298
const57: dq 781
const58: dq 79
const59: dq 392
const60: dq 578
const61: dq 44.29
const62: dq 112
const63: dq 591
const64: dq 159
const65: dq 490
const66: dq 656
const67: dq 21
const68: dq 35
const69: dq 4
const70: dq 125
const71: dq 251
const72: dq 473
const73: dq 98
const74: dq 73
const75: dq 761
const76: dq 530
const77: dq 969
const78: dq 585
const79: dq 430
const80: dq 721
const81: dq 170
const82: dq 982
const83: dq 625
const84: dq 598
const85: dq 931
const86: dq 283
const87: dq 723
const88: dq 180
const89: dq 23.17
const90: dq 36.13
const91: dq 404
const92: dq 315
const93: dq 987
const94: dq 391
const95: dq 957
const96: dq 563
const97: dq 268
const98: dq 482
const99: dq 579
const100: dq 975
const101: dq 189
const102: dq 177
const103: dq 439
const104: dq 105
const105: dq 51
const106: dq 751
const107: dq 827
const108: dq 884
const109: dq 116
const110: dq 27.53
const111: dq 22.09
const112: dq 133
const113: dq 46
const114: dq 270
const115: dq 523
const116: dq 534
const117: dq 811
const118: dq 377
const119: dq 119
const120: dq 664
const121: dq 891
const122: dq 256
const123: dq 132
const124: dq 229
const125: dq 939
const126: dq 525
const127: dq 68
const128: dq 853
const129: dq 70
const130: dq 25
const131: dq 716
const132: dq 16.39
const133: dq 28.0
const134: dq 29.35
const135: dq 7.85
const136: dq 72.46
const137: dq 917
const138: dq 42.51
const139: dq 39.91
const140: dq 39.27
const141: dq 33.36
const142: dq 76.02
const143: dq 71.66
const144: dq 25.14
const145: dq 62.94
const146: dq 956
const147: dq 674
const148: dq 213
const149: dq 689
const150: dq 548
const151: dq 814
const152: dq 83
const153: dq 705
const154: dq 215
const155: dq 153
const156: dq 597
const157: dq 924
const158: dq 351
const159: dq 23
const160: dq 63.61
const161: dq 43.46
const162: dq 489
const163: dq 319
const164: dq 911
const165: dq 323
const166: dq 293
const167: dq 873
const168: dq 521
const169: dq 451
const170: dq 77.41
const171: dq 342
const172: dq 661
const173: dq 75.89
const174: dq 26.71
const175: dq 12
const176: dq 985
const177: dq 284
const178: dq 70.16
const179: dq 253
const180: db `a.png`, 0
const181: dq 992
const182: dq 847
const183: dq 805
const184: dq 442
const185: dq 232
const186: dq 907
const187: dq 620
const188: dq 201
const189: dq 158
const190: dq 309
const191: dq 681
const192: dq 65
const193: dq 777
const194: dq 299
const195: dq 147
const196: dq 322
const197: dq 630
const198: dq 970
const199: dq 34
const200: dq 166
const201: dq 909
const202: dq 815
const203: dq 654
const204: dq 665
const205: dq 161
const206: dq 878
const207: dq 583
const208: dq 53.47
const209: dq 74.75
const210: dq 785
const211: dq 222
const212: dq 318
const213: dq 128
const214: dq 503
const215: dq 398
const216: dq 136
const217: dq 679
const218: dq 241
const219: dq 445
const220: dq 198
const221: dq 914
const222: dq 576
const223: dq 93
const224: dq 64
const225: dq 686
const226: dq 226
const227: dq 892
const228: dq 96
const229: dq 472
const230: dq 468
const231: dq 593
const232: dq 409
const233: dq 308
const234: dq 317
const235: dq 353
const236: dq 967
const237: dq 511
const238: dq 918
const239: dq 845
const240: dq 36
const241: dq 983
const242: dq 29
const243: dq 649
const244: dq 603
const245: dq 698
const246: dq 948
const247: dq 767
const248: dq 227
const249: dq 692
const250: dq 706
const251: dq 691
const252: dq 832
const253: dq 405
const254: dq 881
const255: dq 816
const256: dq 600
const257: dq 280
const258: dq 554
const259: dq 754
const260: dq 514
const261: dq 851
const262: dq 520
const263: dq 581
const264: dq 302
const265: dq 998
const266: dq 16.65
const267: dq 46.45
const268: dq 743
const269: dq 234
const270: dq 629
const271: dq 438
const272: dq 40
const273: dq 988
const274: dq 559
const275: dq 286
const276: dq 263
const277: dq 88.03
const278: dq 26.25
const279: dq 11
const280: dq 71.87
const281: dq 16.24
const282: dq 7.76
const283: dq 28.29
const284: dq 779
const285: dq 66.83
const286: dq 47
const287: dq 896
const288: dq 83.6
const289: dq 36.35
const290: dq 48
const291: dq 34.37
const292: dq 71.49
const293: dq 83.96
const294: dq 99.91
const295: dq 59.63
const296: dq 513
const297: dq 69.06
const298: dq 26.19
const299: dq 129
const300: dq 697
const301: dq 225
const302: dq 350
const303: dq 99
const304: dq 724
const305: dq 33.26
const306: dq 63.93
const307: dq 11.78
const308: dq 741
const309: dq 107
const310: dq 898
const311: dq 320
const312: dq 366
const313: dq 849
const314: dq 73.41
const315: dq 77.95
const316: dq 446
const317: dq 476
const318: dq 455
const319: dq 541
const320: dq 459
const321: dq 935
const322: dq 487
const323: dq 846
const324: dq 185
const325: dq 739
const326: dq 272
const327: dq 817
const328: dq 769
const329: dq 572
const330: dq 337
const331: dq 103
const332: dq 457
const333: dq 74
const334: dq 139
const335: dq 265
const336: dq 449
const337: dq 826
const338: dq 616
const339: dq 622
const340: dq 123
const341: dq 379
const342: dq 450
const343: dq 486
const344: dq 56.43
const345: dq 88.71
const346: dq 565
const347: dq 368
const348: dq 336
const349: dq 195
const350: dq 604
const351: dq 770
const352: dq 29.08
const353: dq 20.5
const354: dq 12.78
const355: dq 90.79
const356: dq 38.48
const357: dq 250
const358: dq 389
const359: dq 748
const360: dq 244
const361: dq 882
const362: dq 385
const363: dq 414
const364: dq 242
const365: dq 671
const366: dq 804
const367: dq 718
const368: dq 728
const369: dq 220
const370: dq 859
const371: dq 83.54
const372: dq 95.41
const373: dq 37.88
const374: dq 70.91
const375: dq 424
const376: dq 955
const377: dq 645
const378: dq 101
const379: dq 574
const380: dq 527
const381: dq 175
const382: dq 99.98
const383: dq 50.92
const384: dq 399
const385: dq 94.34
const386: dq 41.94
const387: dq 64.99
const388: dq 30.08
const389: dq 1.82
const390: dq 39.97
const391: dq 22.07
const392: dq 73.89
const393: dq 33.52
const394: dq 36.05
const395: dq 71
const396: dq 64.98
const397: dq 38.56
const398: dq 942
const399: dq 33
const400: dq 91
const401: db `t.png`, 0
const402: dq 13.94
const403: dq 7.51
const404: dq 471
const405: dq 71.04
const406: dq 553
const407: dq 18.81
const408: dq 663
const409: dq 791
const410: dq 71.6
const411: dq 5.59
const412: dq 46.74
const413: dq 18.46
const414: dq 17.54
const415: dq 37.82
const416: dq 94.23
const417: dq 431
const418: dq 16.51
const419: dq 221
const420: dq 947
const421: dq 57.59
const422: dq 837
const423: dq 10.39
const424: dq 15.52
const425: dq 62.57
const426: dq 29.45
const427: dq 9.98
const428: dq 8.58
const429: db `(TupleType (FloatType) (FloatType) (FloatType) (FloatType))`, 0
const430: db `K`, 0
const431: dq 34.82
const432: dq 84.98
const433: dq 79.99
const434: dq 81.79
const435: dq 58.89
const436: dq 59
const437: dq 932
const438: dq 10.23
const439: dq 37.6
const440: dq 717
const441: dq 44.35
const442: dq 40.99
const443: dq 12.35
const444: dq 16.59
const445: dq 95.23
const446: dq 287
const447: dq 2.74
const448: dq 62.06
const449: dq 22.75
const450: dq 39.24
const451: dq 4.5
const452: dq 51.01
const453: dq 50.64
const454: dq 70.1
const455: dq 30.85
const456: dq 78.44
const457: dq 45.78
const458: dq 44.58
const459: dq 57.27
const460: dq 74.4
const461: dq 53.2
const462: dq 79.35
const463: dq 0.23
const464: dq 844
const465: dq 6.62
const466: dq 35.68
const467: dq 15.69
const468: dq 79.42
const469: dq 38.95
const470: dq 2.16
const471: dq 66.02
const472: dq 321
const473: dq 91.48
const474: dq 76.09
const475: dq 31.87
const476: dq 11.43
const477: dq 96.42
const478: dq 831
const479: db `A`, 0
const480: dq 21.18
const481: dq 38.51
const482: dq 3.34
const483: dq 50.16
const484: dq 14.72
const485: dq 28.7
const486: dq 45
const487: dq 77.05
const488: dq 47.02
const489: dq 61.55
const490: dq 990
const491: dq 99.09
const492: dq 79.29
const493: dq 98.1
const494: dq 10.34
const495: dq 64.44
const496: dq 10.6
const497: dq 540
const498: dq 34.56
const499: dq 73.6
const500: db `J`, 0
const501: dq 690
const502: dq 498
const503: dq 47.1
const504: dq 236
const505: dq 300
const506: dq 48.24
const507: dq 23.99
const508: dq 74.73
const509: dq 19.24
const510: dq 731
const511: dq 58
const512: dq 703
const513: dq 369
const514: dq 904
const515: dq 359
const516: dq 78.19
const517: dq 12.39
const518: dq 77.68
const519: dq 28.97
const520: dq 29.37
const521: dq 352
const522: dq 870
const523: db `A.png`, 0
const524: dq 999
const525: dq 85.73
const526: dq 204
const527: dq 79.49
const528: dq 991
const529: dq 522
const530: dq 395
const531: dq 28.44
const532: dq 42.98
const533: dq 363
const534: dq 434
const535: dq 557
const536: dq 818
const537: dq 50.8
const538: dq 95.57
const539: dq 54.03
const540: dq 338
const541: dq 29.78
const542: dq 78.66
const543: dq 62.51
const544: dq 801
const545: dq 18.89
const546: dq 86.69
const547: dq 67.48
const548: dq 281
const549: dq 59.81
const550: dq 31.84
const551: dq 2.35
const552: dq 993
const553: dq 52.82
const554: dq 729
const555: dq 96.21
const556: dq 88.34
const557: dq 90.2
const558: dq 70.02
const559: dq 80.72
const560: db `(VoidType)`, 0
const561: dq 76.54
const562: dq 22.81
const563: dq 23.71
const564: dq 3.19
const565: dq 8.17
const566: dq 6.87
const567: dq 2.39
const568: dq 71.2
const569: dq 19.05
const570: db `I`, 0
const571: dq 21.57
const572: dq 18.05
const573: dq 28.76
const574: dq 1.45
const575: dq 71.83
const576: dq 58.56
const577: dq 87.02
const578: dq 49.09
const579: dq 15.86
const580: dq 63.1
const581: dq 22.92
const582: dq 38.34
const583: dq 25.92
const584: dq 258
const585: dq 7.49
const586: dq 855
const587: dq 19.27
const588: dq 84.92
const589: dq 35.54
const590: dq 75.68
const591: dq 65.89
const592: dq 506
const593: dq 701
const594: dq 49.81
const595: dq 94.13
const596: dq 5.64
const597: dq 96.87
const598: dq 77.52
const599: dq 90.6
const600: dq 500
const601: dq 54.64
const602: dq 56.2
const603: dq 339
const604: dq 96.37
const605: dq 7.22
const606: dq 27.66
const607: dq 88.91
const608: dq 19.68
const609: dq 2.12
const610: dq 35.44
const611: dq 33.58
const612: dq 76.03
const613: dq 87.8
const614: dq 22.67
const615: dq 2.76
const616: dq 117
const617: dq 1.6
const618: dq 92.02
const619: dq 52.92
const620: dq 70.79
const621: dq 84.53
const622: dq 41.32
const623: dq 63.18
const624: dq 70.71
const625: dq 20.78
const626: dq 11.72
const627: db `P.png`, 0
const628: dq 71.97
const629: dq 14.45
const630: dq 58.71
const631: dq 16.14
const632: dq 356
const633: dq 99.54
const634: dq 97.29
const635: dq 21.21
const636: dq 864
const637: db `af`, 0
const638: dq 973
const639: dq 6.09
const640: dq 11.39
const641: dq 19.33
const642: dq 11.42
const643: dq 24.66
const644: dq 66.76
const645: dq 22.58
const646: dq 97.65
const647: dq 6.67
const648: dq 69.26
const649: dq 39.4
const650: dq 52.94
const651: dq 44.65
const652: dq 12.89
const653: dq 27.49
const654: dq 22.41
const655: dq 35.19
const656: dq 98.24
const657: dq 47.67
const658: dq 652
const659: dq 81.48
const660: db `ai`, 0
const661: dq 17
const662: db `as`, 0
const663: dq 86.92
const664: dq 61.05
const665: dq 72.01
const666: dq 27.43
const667: db `(ArrayType (ArrayType (ArrayType (BoolType) 2) 4) 1)`, 0

section .text
f:
_f:
	push rbp
	mov rbp, rsp
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump760
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump760:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump761
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump761:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump762
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump762:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump763
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump763:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump764: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump765
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump765:
	; Computing bound for 'i'
	mov rax, [rel const279] ; 11
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump766
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump766:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump767: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const5] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump768
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
.jump768:
	push rax
	pop rax
	cmp rax, 0
	jne .jump769
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump770
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump770:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump771
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump771:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump772
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump772:
	; Computing bound for 'k'
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump773
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump774
.jump773:
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
.jump774:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump775
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump775:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump776: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 24], 1
	; Compare n to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump776 ; If n < bound, next iter
	mov qword [rsp + 24], 0 ; n = 0
	add qword [rsp + 16], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump776 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump776 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump776 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
.jump769:
	push rax
	pop rax
	cmp rax, 0
	je .jump777
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump779
	mov rax, [rel const2] ; True
	push rax
	pop rax
.jump779:
	push rax
	pop rax
	cmp rax, 0
	je .jump780
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump781
.jump780:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump781:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump782
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump782:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by (if (false && true) then c else (- d)) 
	jno .jump783
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump783:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump784: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const280] ; 71.87
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump784 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump785
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump785:
	cmp rax, [rsp + 8]
	jl .jump786
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump786:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump778
.jump777:
	mov rax, [rel const281] ; 16.24
	push rax
.jump778:
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump767 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump767 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump787
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump787:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump788
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump788:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	mov rax, [rel const5] ; False
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump789
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump790
.jump789:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump790:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump791
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump791:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by (c + (if (false == (d > g)) then b else (- c))) 
	jno .jump792
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump792:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump793
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump793:
	imul rdi, [rsp + 0 + 16] ; multiply by c 
	jno .jump794
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump794:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump795: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const282] ; 7.76
	push rax
	mov rax, [rel const283] ; 28.29
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump796
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump796:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump797
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump797:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump798
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump798:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump799: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump800
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump800:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump801
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump801:
	; Computing bound for 'p'
	mov rax, [rel const284] ; 779
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump802
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump802:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump803
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump803:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump804: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const285] ; 66.83
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump804 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump804 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump804 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump804 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump799 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump799 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump799 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump795 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump795 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump795 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump805
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump805:
	cmp rax, [rsp + 24]
	jl .jump806
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump806:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump807
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump807:
	cmp rax, [rsp + 32]
	jl .jump808
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump808:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump809
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump809:
	cmp rax, [rsp + 40]
	jl .jump810
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump810:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump811
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump811:
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump812
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump812:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump813
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump813:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump814
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const286] ; 47
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const287] ; 896
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump816
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump816:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump817
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump817:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump818
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump818:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump819
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
.jump819:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump820
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump820:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump821: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump821 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump821 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump821 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump821 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	jmp .jump815
.jump814:
	mov rax, [rel const288] ; 83.6
	push rax
	mov rax, [rel const289] ; 36.35
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump822
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	jmp .jump823
.jump822:
	call _f
	push rax
	pop rax
	xor rax, 1
	push rax
.jump823:
	pop rax
	cmp rax, 0
	je .jump824
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump825
.jump824:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
.jump825:
.jump815:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump826
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump826:
	; Computing bound for 'i'
	mov rax, [rel const290] ; 48
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump827
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump827:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump828: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump828 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump828 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump828 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump828 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump829
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump829:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump830
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump830:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump831: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump832
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump832:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump833: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const291] ; 34.37
	push rax
	mov rax, [rel const292] ; 71.49
	push rax
	mov rax, [rel const293] ; 83.96
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump834
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump834:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump835
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump835:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump836
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump836:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump837
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump837:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump838: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const294] ; 99.91
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump838 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump838 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump838 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump838 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump839
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump839:
	cmp rax, [rsp + 8]
	jl .jump840
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump840:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump833 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump831 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump831 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump831 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const295] ; 59.63
	push rax
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump764 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump764 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump841
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
.jump841:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	sub rsp, 32
	; Moving 32 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump842
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump842:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump843
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump843:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump844: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const296] ; 513
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump845
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump846
.jump845:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump846:
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump844 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump844 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump847
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump847:
	cmp rax, [rsp + 24]
	jl .jump848
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump848:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump849
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump849:
	cmp rax, [rsp + 32]
	jl .jump850
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump850:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump851
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump851:
	cmp rax, [rsp + 40]
	jl .jump852
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump852:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump853
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump855
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump855:
	; Computing bound for 'n'
	sub rsp, 16
	; Moving 16 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump856
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump856:
	cmp rax, [rsp + 8]
	jl .jump857
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump857:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump858
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump858:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump859
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump859:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump860
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump860:
	imul rdi, [rsp + 0 + 8] ; multiply by k[(- i)] 
	jno .jump861
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump861:
	imul rdi, [rsp + 0 + 16] ; multiply by j 
	jno .jump862
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump862:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump863: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const297] ; 69.06
	push rax
	mov rax, [rel const298] ; 26.19
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	call _f
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump864
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump866
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump866:
	; Computing bound for 'r'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	jne .jump867
	mov rax, [rel const5] ; False
	push rax
	pop rax
.jump867:
	push rax
	pop rax
	cmp rax, 0
	je .jump868
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump869
.jump868:
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump870
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	jmp .jump871
.jump870:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
.jump871:
.jump869:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump872
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump872:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump873
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump873:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump874
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump874:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump875
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump875:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump876
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump876:
	imul rdi, [rsp + 0 + 16] ; multiply by (if (f() || false) then c else (if false then n else d)) 
	jno .jump877
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump877:
	imul rdi, [rsp + 0 + 24] ; multiply by b 
	jno .jump878
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump878:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump879: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump880
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump880:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump881
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump881:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump882
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump882:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump883
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump883:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump884
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump884:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump885
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump885:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump886
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump886:
	imul rdi, [rsp + 0 + 24] ; multiply by n 
	jno .jump887
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump887:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump888: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 24], 1
	; Compare w to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump888 ; If w < bound, next iter
	mov qword [rsp + 24], 0 ; w = 0
	add qword [rsp + 16], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump888 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump888 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump888 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 's'
	add qword [rsp + 24], 1
	; Compare s to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump879 ; If s < bound, next iter
	mov qword [rsp + 24], 0 ; s = 0
	add qword [rsp + 16], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump879 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump879 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump879 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump865
.jump864:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump889
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump891
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump891:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump892
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump892:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump893: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 8], 1
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump893 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump893 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump894
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump894:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump895
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump895:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump896
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump896:
	; Computing bound for 'p'
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump897
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	jmp .jump898
.jump897:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump898:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump899
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump899:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if false then l else i) 
	jno .jump900
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump900:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump901
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump901:
	imul rdi, [rsp + 0 + 16] ; multiply by (- d) 
	jno .jump902
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump902:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[p : o, q : i] j) 
	jno .jump903
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump903:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump904: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump905
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump905:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump906
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump906:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump907
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump907:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump908
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump908:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump909
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump909:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump910
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump910:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump911
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump911:
	imul rdi, [rsp + 0 + 24] ; multiply by n 
	jno .jump912
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump912:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump913: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 24], 1
	; Compare w to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump913 ; If w < bound, next iter
	mov qword [rsp + 24], 0 ; w = 0
	add qword [rsp + 16], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump913 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump913 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump913 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 's'
	add qword [rsp + 24], 1
	; Compare s to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump904 ; If s < bound, next iter
	mov qword [rsp + 24], 0 ; s = 0
	add qword [rsp + 16], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump904 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump904 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump904 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump890
.jump889:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump914
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump914:
	; Computing bound for 'r'
	mov rax, [rel const299] ; 129
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump915
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump915:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump916
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump916:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump917
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump917:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump918
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump918:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump919
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump919:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump920
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump920:
	imul rdi, [rsp + 0 + 16] ; multiply by (h % 129) 
	jno .jump921
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump921:
	imul rdi, [rsp + 0 + 24] ; multiply by n 
	jno .jump922
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump922:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump923: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump924
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump924:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump925
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump925:
	; Computing bound for 'u'
	mov rax, [rel const47] ; 289
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump926
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump926:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump927
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump927:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump928
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump928:
	imul rdi, [rsp + 0 + 8] ; multiply by 289 
	jno .jump929
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump929:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump930
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump930:
	imul rdi, [rsp + 0 + 24] ; multiply by l 
	jno .jump931
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump931:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump932: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 24], 1
	; Compare w to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump932 ; If w < bound, next iter
	mov qword [rsp + 24], 0 ; w = 0
	add qword [rsp + 16], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump932 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump932 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump932 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 's'
	add qword [rsp + 24], 1
	; Compare s to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump923 ; If s < bound, next iter
	mov qword [rsp + 24], 0 ; s = 0
	add qword [rsp + 16], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump923 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump923 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump923 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump890:
.jump865:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump863 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump863 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump863 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump854
.jump853:
	sub rsp, 32
	; Moving 32 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump933
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump933:
	cmp rax, [rsp + 24]
	jl .jump934
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump934:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump935
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump935:
	cmp rax, [rsp + 32]
	jl .jump936
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump936:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump937
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump937:
	cmp rax, [rsp + 40]
	jl .jump938
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump938:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump939
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump940
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	jmp .jump941
.jump940:
	mov rax, [rel const2] ; True
	push rax
.jump941:
	pop rax
.jump939:
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump942
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump944
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump944:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump945
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump945:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump946
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump946:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump947
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump947:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump948
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump948:
	imul rdi, [rsp + 0 + 16] ; multiply by j 
	jno .jump949
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump949:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump950: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump951
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump951:
	; Computing bound for 'r'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump952
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump952:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump953
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump953:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump954
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump954:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump955
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump955:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump956: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 's'
	add qword [rsp + 24], 1
	; Compare s to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump956 ; If s < bound, next iter
	mov qword [rsp + 24], 0 ; s = 0
	add qword [rsp + 16], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump956 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump956 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump956 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump957
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump957:
	; Computing bound for 'q'
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump958
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	jmp .jump959
.jump958:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
.jump959:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump960
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump960:
	; Computing bound for 'p'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump961
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump961:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump962
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump962:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump963: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 8], 1
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump963 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump963 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump964
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump964:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump965: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump966
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump966:
	cmp rax, [rsp + 8]
	jl .jump967
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump967:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 0], 1
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump965 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump968
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump968:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[p : (sum[p : m, q : l] p)] k[c]) 
	jno .jump969
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump969:
	imul rdi, [rsp + 0 + 8] ; multiply by (if f() then l else c) 
	jno .jump970
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump970:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[p : b, q : c, r : n, s : h] d) 
	jno .jump971
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump971:
	imul rdi, [rsp + 0 + 24] ; multiply by c 
	jno .jump972
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump972:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump973: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	pop rax
	cmp rax, 0
	jne .jump974
	mov rax, [rel const2] ; True
	push rax
	pop rax
.jump974:
	push rax
	pop rax
	cmp rax, 0
	je .jump975
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump977
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump977:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump978
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump978:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump979
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump979:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump980
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump980:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump981
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump981:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump982
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump982:
	imul rdi, [rsp + 0 + 16] ; multiply by j 
	jno .jump983
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump983:
	imul rdi, [rsp + 0 + 24] ; multiply by p 
	jno .jump984
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump984:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump985: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 24], 1
	; Compare w to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump985 ; If w < bound, next iter
	mov qword [rsp + 24], 0 ; w = 0
	add qword [rsp + 16], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump985 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump985 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump985 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump976
.jump975:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump986
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump986:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump987
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump987:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump988
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump988:
	; Computing bound for 't'
	mov rax, [rel const300] ; 697
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump989
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump989:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 697 
	jno .jump990
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump990:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump991
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump991:
	imul rdi, [rsp + 0 + 16] ; multiply by c 
	jno .jump992
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump992:
	imul rdi, [rsp + 0 + 24] ; multiply by r 
	jno .jump993
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump993:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump994: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 24], 1
	; Compare w to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump994 ; If w < bound, next iter
	mov qword [rsp + 24], 0 ; w = 0
	add qword [rsp + 16], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump994 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump994 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump994 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump976:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 's'
	add qword [rsp + 24], 1
	; Compare s to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump973 ; If s < bound, next iter
	mov qword [rsp + 24], 0 ; s = 0
	add qword [rsp + 16], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump973 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump973 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump973 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump950 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump950 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump950 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump943
.jump942:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump995
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump995:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump996: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 0], 1
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump996 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump997
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump997:
	; Computing bound for 'n'
	mov rax, [rel const301] ; 225
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump998
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump998:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump999
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump999:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump1000
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1000:
	imul rdi, [rsp + 0 + 8] ; multiply by 225 
	jno .jump1001
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1001:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[m : i] d) 
	jno .jump1002
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1002:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1003: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1003 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1003 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1003 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1004
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1004:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1005
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1005:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1006: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1006 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1006 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1007
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1007:
	cmp rax, [rsp + 24]
	jl .jump1008
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1008:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1009
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1009:
	cmp rax, [rsp + 32]
	jl .jump1010
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1010:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1011
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1011:
	cmp rax, [rsp + 40]
	jl .jump1012
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1012:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1013
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1013:
	; Computing bound for 'n'
	mov rax, [rel const302] ; 350
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1014
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1014:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1015
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1015:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump1016
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1016:
	imul rdi, [rsp + 0 + 8] ; multiply by 350 
	jno .jump1017
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1017:
imul rdi, [rsp + 0 + 16] ; multiply by (array[m : l, n : 225, o : (sum[m : i] d)] o)[d, (sum[m : l, n : d] (- d)), b] 
	jno .jump1018
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1018:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1019: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump1020
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
.jump1020:
	push rax
	pop rax
	cmp rax, 0
	je .jump1021
	mov rax, [rel const5] ; False
	push rax
	jmp .jump1022
.jump1021:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump1022:
	pop rax
	cmp rax, 0
	je .jump1023
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1025
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1025:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1026
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1026:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1027
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1027:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1028
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1028:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump1029
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1029:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump1030
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1030:
	imul rdi, [rsp + 0 + 16] ; multiply by l 
	jno .jump1031
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1031:
	imul rdi, [rsp + 0 + 24] ; multiply by l 
	jno .jump1032
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1032:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump1033: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1034
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1034:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1035
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1035:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1036
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1036:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1037
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1037:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump1038
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1038:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump1039
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1039:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump1040
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1040:
	imul rdi, [rsp + 0 + 24] ; multiply by p 
	jno .jump1041
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1041:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump1042: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 24], 1
	; Compare w to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1042 ; If w < bound, next iter
	mov qword [rsp + 24], 0 ; w = 0
	add qword [rsp + 16], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1042 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1042 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1042 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 's'
	add qword [rsp + 24], 1
	; Compare s to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1033 ; If s < bound, next iter
	mov qword [rsp + 24], 0 ; s = 0
	add qword [rsp + 16], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1033 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1033 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1033 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump1024
.jump1023:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1043
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1043:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1044
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1044:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1045
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1045:
	; Computing bound for 'p'
	mov rax, [rel const303] ; 99
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1046
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1046:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 99 
	jno .jump1047
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1047:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump1048
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1048:
	imul rdi, [rsp + 0 + 16] ; multiply by c 
	jno .jump1049
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1049:
	imul rdi, [rsp + 0 + 24] ; multiply by c 
	jno .jump1050
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1050:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump1051: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1052
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1052:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1053
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1053:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1054
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1054:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1055
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1055:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump1056
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1056:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump1057
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1057:
	imul rdi, [rsp + 0 + 16] ; multiply by o 
	jno .jump1058
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1058:
	imul rdi, [rsp + 0 + 24] ; multiply by d 
	jno .jump1059
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1059:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump1060: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const304] ; 724
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 24], 1
	; Compare w to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1060 ; If w < bound, next iter
	mov qword [rsp + 24], 0 ; w = 0
	add qword [rsp + 16], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1060 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1060 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1060 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 's'
	add qword [rsp + 24], 1
	; Compare s to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1051 ; If s < bound, next iter
	mov qword [rsp + 24], 0 ; s = 0
	add qword [rsp + 16], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1051 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1051 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1051 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump1024:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1019 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1019 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1019 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump943:
.jump854:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1061
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1061:
	cmp rax, [rsp + 24]
	jl .jump1062
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1062:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1063
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1063:
	cmp rax, [rsp + 32]
	jl .jump1064
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1064:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1065
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1065:
	cmp rax, [rsp + 40]
	jl .jump1066
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1066:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1067
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1067:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1068
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1068:
	; Computing bound for 'n'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const255] ; 816
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1069
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1069:
	; Computing bound for 'm'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1070
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1070:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1071
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1071:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump1072
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1072:
	imul rdi, [rsp + 0 + 8] ; multiply by (h - i) 
	jno .jump1073
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1073:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1074: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1074 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1074 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1075
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1075:
	cmp rax, [rsp + 16]
	jl .jump1076
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1076:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1077
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1077:
	cmp rax, [rsp + 24]
	jl .jump1078
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1078:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1079
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1079:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (array[m : d, n : (h - i)] i)[d, b] 
	jno .jump1080
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1080:
	imul rdi, [rsp + 0 + 8] ; multiply by 816 
	jno .jump1081
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1081:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1082: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1082 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1082 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const305] ; 33.26
	push rax
	mov rax, [rel const306] ; 63.93
	push rax
	mov rax, [rel const307] ; 11.78
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1083
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump1084
.jump1083:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump1084:
	mov rax, [rel const32] ; 360
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1085
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1085:
	cmp rax, [rsp + 16]
	jl .jump1086
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1086:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1087
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1087:
	cmp rax, [rsp + 24]
	jl .jump1088
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1088:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1089
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1089:
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1090
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	jmp .jump1091
.jump1090:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1092
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1092:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1093
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1093:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1094
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1094:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1095
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1095:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1096: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1096 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1096 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1096 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1096 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
.jump1091:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1097
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1097:
	; Computing bound for 'n'
	mov rax, [rel const308] ; 741
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1098
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1098:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1099
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1099:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1100: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1100 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1100 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1100 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1101
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1101:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1102
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1102:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1103
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1103:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1104: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const186] ; 907
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1104 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1104 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1104 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1105
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1105:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1106: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1106 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1106 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1106 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1106 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1107
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1107:
	cmp rax, [rsp + 32]
	jl .jump1108
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1108:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1109
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1109:
	cmp rax, [rsp + 40]
	jl .jump1110
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1110:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1111
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1111:
	cmp rax, [rsp + 48]
	jl .jump1112
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1112:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1113
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1113:
	cmp rax, [rsp + 56]
	jl .jump1114
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1114:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1115
	sub rsp, 32
	; Moving 32 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1117
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1117:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1118
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1118:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1119
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1119:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (s - i) 
	jno .jump1120
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1120:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump1121
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1121:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump1122
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1122:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump1123: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'x'
	add qword [rsp + 16], 1
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1123 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1123 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1123 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1124
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1124:
	cmp rax, [rsp + 24]
	jl .jump1125
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1125:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1126
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1126:
	cmp rax, [rsp + 32]
	jl .jump1127
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1127:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1128
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1128:
	cmp rax, [rsp + 40]
	jl .jump1129
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1129:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1130
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1130:
	cmp rax, [rsp + 24]
	jl .jump1131
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1131:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1132
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1132:
	cmp rax, [rsp + 32]
	jl .jump1133
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1133:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1134
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1134:
	cmp rax, [rsp + 40]
	jl .jump1135
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1135:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1136
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1138
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1138:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[] 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump1139
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1139:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump1140: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	mov rax, [rel const309] ; 107
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1141
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1141:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 107 
	jno .jump1142
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1142:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump1143: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const2] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 0], 1
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1143 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 32]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'v'
	add qword [rsp + 0], 1
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1140 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1144
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1144:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1145
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump1146
.jump1145:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump1146:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1147
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1147:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1148
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1148:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump1149: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1150
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1150:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1151
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1151:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump1152: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const310] ; 898
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'z'
	add qword [rsp + 8], 1
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1152 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1152 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'x'
	add qword [rsp + 16], 1
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1149 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1149 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1149 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1153
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1153:
	cmp rax, [rsp + 8]
	jl .jump1154
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1154:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1137
.jump1136:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump1155
	mov rax, [rel const2] ; True
	push rax
	pop rax
.jump1155:
	push rax
	pop rax
	cmp rax, 0
	je .jump1156
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1158
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1158:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1159
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1159:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by j 
	jno .jump1160
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1160:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump1161
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1161:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump1162: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 8], 1
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1162 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1162 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const311] ; 320
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1163
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1163:
	cmp rax, [rsp + 16]
	jl .jump1164
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1164:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1165
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1165:
	cmp rax, [rsp + 24]
	jl .jump1166
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1166:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1157
.jump1156:
	mov rax, [rel const312] ; 366
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1167
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1167:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1168
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1168:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump1169
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1169:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump1170
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1170:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump1171: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 8], 1
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1171 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1171 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const313] ; 849
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1172
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1172:
	cmp rax, [rsp + 16]
	jl .jump1173
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1173:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1174
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1174:
	cmp rax, [rsp + 24]
	jl .jump1175
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1175:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1176
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
.jump1176:
	cqo
	idiv r10
	push rax
.jump1157:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1177
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1177:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (if ((c > l) || true) then (array[v : j, w : q] l)[h, 320] else ((array[v : d, w : l] v)[s, 849] / 366)) 
	jno .jump1178
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1178:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump1179: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const314] ; 73.41
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1180
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1180:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump1181: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const315] ; 77.95
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'w'
	add qword [rsp + 0], 1
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1181 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 0], 1
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1179 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump1137:
	mov rax, [rel const316] ; 446
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1182
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1182:
	cmp rax, [rsp + 8]
	jl .jump1183
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1183:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1116
.jump1115:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1184
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1184:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump1185: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'v'
	add qword [rsp + 0], 1
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1185 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const2] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1186
	mov rax, [rel const5] ; False
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
.jump1186:
	push rax
	pop rax
	cmp rax, 0
	je .jump1187
	call _f
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1189
	sub rsp, 40
	; Moving 40 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 88 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 88 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 88 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	jmp .jump1190
.jump1189:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1191
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1191:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1192
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1192:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1193
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1193:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1194
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1194:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump1195
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1195:
	imul rdi, [rsp + 0 + 8] ; multiply by (- q) 
	jno .jump1196
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1196:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump1197
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1197:
	imul rdi, [rsp + 0 + 24] ; multiply by b 
	jno .jump1198
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1198:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump1199: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'y'
	add qword [rsp + 24], 1
	; Compare y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1199 ; If y < bound, next iter
	mov qword [rsp + 24], 0 ; y = 0
	add qword [rsp + 16], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1199 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1199 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1199 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump1190:
	jmp .jump1188
.jump1187:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	mov rax, [rel const317] ; 476
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1200
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1200:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1201
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1201:
	; Computing bound for 'w'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump1202
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	jmp .jump1203
.jump1202:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1204
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1204:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1205
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1205:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump1206: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const318] ; 455
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'w'
	add qword [rsp + 8], 1
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1206 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1206 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump1203:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1207
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1207:
	; Computing bound for 'v'
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1208
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	jmp .jump1209
.jump1208:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump1209:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1210
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1210:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if true then l else i) 
	jno .jump1211
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1211:
imul rdi, [rsp + 0 + 8] ; multiply by (if f() then q else (sum[v : c, w : h] 455)) 
	jno .jump1212
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1212:
	imul rdi, [rsp + 0 + 16] ; multiply by j 
	jno .jump1213
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1213:
	imul rdi, [rsp + 0 + 24] ; multiply by 476 
	jno .jump1214
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1214:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump1215: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'y'
	add qword [rsp + 24], 1
	; Compare y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1215 ; If y < bound, next iter
	mov qword [rsp + 24], 0 ; y = 0
	add qword [rsp + 16], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1215 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1215 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1215 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump1188:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1216
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1216:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1217
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1217:
	cmp rax, [rsp + 32]
	jl .jump1218
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1218:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1219
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1219:
	cmp rax, [rsp + 40]
	jl .jump1220
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1220:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1221
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1221:
	cmp rax, [rsp + 48]
	jl .jump1222
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1222:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1223
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1223:
	cmp rax, [rsp + 56]
	jl .jump1224
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1224:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
.jump1116:
	pop rax
	add rsp, 120 ; Local variables
	pop rbp
	ret
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const5] ; False
	push rax
	pop rax
	add rsp, 128 ; Local variables
	pop rbp
	ret

x:
_x:
	push rbp
	mov rbp, rsp
	push rdi
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	jne .jump2354
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const430] ; 'K'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2354:
	sub rsp, 40
	; Moving 40 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump2355
	mov rax, [rel const2] ; True
	push rax
	jmp .jump2356
.jump2355:
	mov rax, [rel const2] ; True
	push rax
.jump2356:
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump2357
	call _f
	push rax
	pop rax
.jump2357:
	push rax
	pop rax
	cmp rax, 0
	je .jump2358
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	jmp .jump2359
.jump2358:
	mov rax, [rel const431] ; 34.82
	push rax
.jump2359:
	sub rsp, 32
	; Moving 32 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 80 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 80 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2360
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2360:
	cmp rax, [rsp + 24]
	jl .jump2361
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2361:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2362
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2362:
	cmp rax, [rsp + 32]
	jl .jump2363
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2363:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2364
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2364:
	cmp rax, [rsp + 40]
	jl .jump2365
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2365:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump2366
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2368
	call _f
	push rax
	jmp .jump2369
.jump2368:
	call _f
	push rax
.jump2369:
	jmp .jump2367
.jump2366:
	mov rax, [rel const5] ; False
	push rax
.jump2367:
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2370
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2371
	sub rsp, 24
	; Moving 24 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	jmp .jump2372
.jump2371:
	sub rsp, 24
	; Moving 24 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
.jump2372:
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2373
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2373:
	cmp rax, [rsp + 16]
	jl .jump2374
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2374:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2375
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2375:
	cmp rax, [rsp + 24]
	jl .jump2376
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2376:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
.jump2370:
	push rax
	pop rax
	cmp rax, 0
	je .jump2377
	sub rsp, 32
	; Moving 32 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2379
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2379:
	cmp rax, [rsp + 24]
	jl .jump2380
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2380:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2381
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2381:
	cmp rax, [rsp + 32]
	jl .jump2382
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2382:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2383
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2383:
	cmp rax, [rsp + 40]
	jl .jump2384
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2384:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2385
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	jmp .jump2386
.jump2385:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump2387
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	jmp .jump2388
.jump2387:
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
.jump2388:
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const432] ; 84.98
	push rax
	mov rax, [rel const433] ; 79.99
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const434] ; 81.79
	push rax
	mov rax, [rel const435] ; 58.89
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump2386:
	jmp .jump2378
.jump2377:
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2389
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
.jump2389:
	cqo
	idiv r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2390
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2392
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2392:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by z 
	jno .jump2393
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2393:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump2394: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'M'
	add qword [rsp + 0], 1
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2394 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump2391
.jump2390:
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2395
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2395:
	cmp rax, [rsp + 24]
	jl .jump2396
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2396:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2397
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2397:
	cmp rax, [rsp + 32]
	jl .jump2398
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2398:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2399
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2399:
	cmp rax, [rsp + 40]
	jl .jump2400
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2400:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rdi, 64
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 64 bytes from rsp to rax 
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 64
	push rax
	mov rax, 2
	push rax
.jump2391:
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2401
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2401:
	cmp rax, [rsp + 8]
	jl .jump2402
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2402:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2378:
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2403
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2403:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2404
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2404:
	; Computing bound for 'M'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2405
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump2406
.jump2405:
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
.jump2406:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2407
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2407:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2408
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2408:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2409
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2409:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2410
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2410:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump2411: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'P'
	add qword [rsp + 24], 1
	; Compare P to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2411 ; If P < bound, next iter
	mov qword [rsp + 24], 0 ; P = 0
	add qword [rsp + 16], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2411 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2411 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2411 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2412
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2412:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump2413: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'O'
	add qword [rsp + 16], 1
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2413 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2413 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2413 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	sub rsp, 32
	; Moving 32 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2414
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2414:
	cmp rax, [rsp + 24]
	jl .jump2415
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2415:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2416
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2416:
	cmp rax, [rsp + 32]
	jl .jump2417
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2417:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2418
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2418:
	cmp rax, [rsp + 40]
	jl .jump2419
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2419:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2420
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	jmp .jump2421
.jump2420:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'N'
	mov rax, [rel const436] ; 59
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2422
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2422:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2423
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2423:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump2424: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'N'
	add qword [rsp + 8], 1
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2424 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2424 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump2421:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2425
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2425:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2426
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2426:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump2427: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'N'
	add qword [rsp + 8], 1
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2427 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2427 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2428
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump2430
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump2431
	mov rax, [rel const5] ; False
	push rax
	pop rax
.jump2431:
	push rax
	pop rax
.jump2430:
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump2429
.jump2428:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2432
	mov rax, [rel const2] ; True
	push rax
	jmp .jump2433
.jump2432:
	mov rax, [rel const2] ; True
	push rax
.jump2433:
	pop rax
	cmp rax, 0
	jne .jump2434
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	mov rax, [rel const437] ; 932
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2435
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2435:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2436
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2436:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2437
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2437:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2438
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2438:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by z 
	jno .jump2439
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2439:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump2440
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2440:
	imul rdi, [rsp + 0 + 16] ; multiply by l 
	jno .jump2441
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2441:
	imul rdi, [rsp + 0 + 24] ; multiply by 932 
	jno .jump2442
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2442:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump2443: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const2] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'P'
	add qword [rsp + 24], 1
	; Compare P to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2443 ; If P < bound, next iter
	mov qword [rsp + 24], 0 ; P = 0
	add qword [rsp + 16], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2443 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2443 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2443 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const246] ; 948
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2444
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2444:
	cmp rax, [rsp + 32]
	jl .jump2445
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2445:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2446
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2446:
	cmp rax, [rsp + 40]
	jl .jump2447
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2447:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2448
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2448:
	cmp rax, [rsp + 48]
	jl .jump2449
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2449:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2450
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2450:
	cmp rax, [rsp + 56]
	jl .jump2451
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2451:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
.jump2434:
	push rax
.jump2429:
	pop rax
	cmp rax, 0
	je .jump2452
	sub rsp, 56
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const438] ; 10.23
	push rax
	mov rax, [rel const439] ; 37.6
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2454
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump2456
	sub rsp, 32
	; Moving 32 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	jmp .jump2457
.jump2456:
	sub rsp, 32
	; Moving 32 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
.jump2457:
	jmp .jump2455
.jump2454:
	sub rsp, 32
	; Moving 32 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
.jump2455:
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2458
	sub rsp, 16
	; Moving 16 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	jmp .jump2459
.jump2458:
	sub rsp, 16
	; Moving 16 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
.jump2459:
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	lea rdi, [rsp + 120]
	call _x
	add rsp, 40
	add rsp, 16
	add rsp, 32
	add rsp, 32
	; Moving 8 bytes from rsp + 0 to rsp + 48 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	jmp .jump2453
.jump2452:
	sub rsp, 56
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	lea rdi, [rsp + 120]
	call _x
	add rsp, 40
	add rsp, 16
	add rsp, 32
	add rsp, 32
	; Moving 8 bytes from rsp + 0 to rsp + 48 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
.jump2453:
	; Moving 8 bytes from rsp + 48 to rsp + 48 
		mov r10, [rsp + 48 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2460
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2460:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump2461
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2461:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump2462: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2463
	sub rsp, 24
	; Moving 24 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	jmp .jump2464
.jump2463:
	sub rsp, 24
	; Moving 24 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
.jump2464:
	sub rsp, 24
	; Moving 24 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rdi, 48
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 48 bytes from rsp to rax 
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 48
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2465
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2465:
	cmp rax, [rsp + 8]
	jl .jump2466
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2466:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'M'
	add qword [rsp + 0], 1
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2462 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2467
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2467:
	cmp rax, [rsp + 8]
	jl .jump2468
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2468:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2469
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2469:
	cmp rax, [rsp + 16]
	jl .jump2470
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2470:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2471
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2471:
	cmp rax, [rsp + 24]
	jl .jump2472
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2472:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2473
	sub rsp, 56
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2475
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2475:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2476
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2476:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2477
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2477:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump2478
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2478:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump2479
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2479:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump2480
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2480:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump2481: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'O'
	add qword [rsp + 16], 1
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2481 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2481 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2481 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2482
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2482:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2483
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2483:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2484
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2484:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2485
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2485:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof u[] 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump2486
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2486:
	imul rdi, [rsp + 0 + 8] ; multiply by E 
	jno .jump2487
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2487:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump2488
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2488:
	imul rdi, [rsp + 0 + 24] ; multiply by A 
	jno .jump2489
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2489:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump2490: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'P'
	add qword [rsp + 24], 1
	; Compare P to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2490 ; If P < bound, next iter
	mov qword [rsp + 24], 0 ; P = 0
	add qword [rsp + 16], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2490 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2490 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2490 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2491
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2491:
	cmp rax, [rsp + 32]
	jl .jump2492
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2492:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2493
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2493:
	cmp rax, [rsp + 40]
	jl .jump2494
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2494:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2495
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2495:
	cmp rax, [rsp + 48]
	jl .jump2496
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2496:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2497
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2497:
	cmp rax, [rsp + 56]
	jl .jump2498
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2498:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const5] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2499
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump2500
.jump2499:
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump2500:
	lea rdi, [rsp + 120]
	call _x
	add rsp, 40
	add rsp, 16
	add rsp, 32
	add rsp, 32
	; Moving 8 bytes from rsp + 0 to rsp + 48 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	sub rsp, 16
	; Moving 16 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2501
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2501:
	cmp rax, [rsp + 8]
	jl .jump2502
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2502:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 56
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 56
	; Moving 56 bytes from rax to rsp 
		mov r10, [rax + 48]
		mov [rsp + 48], r10
		mov r10, [rax + 40]
		mov [rsp + 40], r10
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 48 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	sub rsp, 56
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2503
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2503:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2504
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2504:
	; Computing bound for 'M'
	mov rax, [rel const440] ; 717
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2505
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2505:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by 717 
	jno .jump2506
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2506:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump2507
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2507:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump2508
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2508:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump2509: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'O'
	add qword [rsp + 16], 1
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2509 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2509 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2509 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2510
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2510:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2511
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2511:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof u[] 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump2512
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2512:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump2513
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2513:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump2514: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'N'
	add qword [rsp + 8], 1
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2514 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2514 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2515
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2515:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2516
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2516:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump2517: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'N'
	add qword [rsp + 8], 1
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2517 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2517 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2518
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2518:
	cmp rax, [rsp + 16]
	jl .jump2519
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2519:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2520
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2520:
	cmp rax, [rsp + 24]
	jl .jump2521
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2521:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 16
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	lea rdi, [rsp + 120]
	call _x
	add rsp, 40
	add rsp, 16
	add rsp, 32
	add rsp, 32
	; Moving 8 bytes from rsp + 0 to rsp + 48 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2522
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2522:
	cmp rax, [rsp + 8]
	jl .jump2523
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2523:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump2474
.jump2473:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2524
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2526
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2526:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2527
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2527:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2528
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2528:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump2529
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2529:
	imul rdi, [rsp + 0 + 8] ; multiply by G 
	jno .jump2530
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2530:
	imul rdi, [rsp + 0 + 16] ; multiply by z 
	jno .jump2531
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2531:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump2532: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 16], 1
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2532 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2532 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2532 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump2525
.jump2524:
	sub rsp, 32
	; Moving 32 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 184 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 184 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
.jump2525:
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2533
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2533:
	cmp rax, [rsp + 24]
	jl .jump2534
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2534:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2535
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2535:
	cmp rax, [rsp + 32]
	jl .jump2536
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2536:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2537
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2537:
	cmp rax, [rsp + 40]
	jl .jump2538
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2538:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2539
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2539:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2540
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2540:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2541
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2541:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by A 
	jno .jump2542
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2542:
	imul rdi, [rsp + 0 + 8] ; multiply by (- k) 
	jno .jump2543
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2543:
imul rdi, [rsp + 0 + 16] ; multiply by ((if false then (array[M : r, N : G, O : z] s) else o)[r, (q * c), k] - (z * z)) 
	jno .jump2544
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2544:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump2545: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump2546
	sub rsp, 56
	sub rsp, 8 ; Add alignment
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	lea rdi, [rsp + 128]
	call _x
	add rsp, 40
	add rsp, 16
	add rsp, 32
	add rsp, 32
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp + 0 to rsp + 48 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	jmp .jump2547
.jump2546:
	sub rsp, 56
	sub rsp, 8 ; Add alignment
	sub rsp, 32
	; Moving 32 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2548
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2548:
	cmp rax, [rsp + 24]
	jl .jump2549
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2549:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2550
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2550:
	cmp rax, [rsp + 32]
	jl .jump2551
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2551:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2552
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2552:
	cmp rax, [rsp + 40]
	jl .jump2553
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2553:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump2554
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump2555
.jump2554:
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump2555:
	lea rdi, [rsp + 128]
	call _x
	add rsp, 40
	add rsp, 16
	add rsp, 32
	add rsp, 32
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp + 0 to rsp + 48 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
.jump2547:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 16], 1
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2545 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2545 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2545 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2556
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2556:
	cmp rax, [rsp + 24]
	jl .jump2557
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2557:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2558
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2558:
	cmp rax, [rsp + 32]
	jl .jump2559
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2559:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2560
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2560:
	cmp rax, [rsp + 40]
	jl .jump2561
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2561:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2474:
	sub rsp, 32
	; Moving 32 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 80 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 80 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const5] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2562
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2564
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2564:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2565
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2565:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof float[][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump2566
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2566:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump2567
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2567:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump2568: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2569
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2569:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2570
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2570:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2571
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2571:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2572
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2572:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump2573
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2573:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump2574
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2574:
	imul rdi, [rsp + 0 + 16] ; multiply by H 
	jno .jump2575
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2575:
	imul rdi, [rsp + 0 + 24] ; multiply by B 
	jno .jump2576
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2576:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump2577: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const441] ; 44.35
	push rax
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'T'
	add qword [rsp + 24], 1
	; Compare T to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2577 ; If T < bound, next iter
	mov qword [rsp + 24], 0 ; T = 0
	add qword [rsp + 16], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2577 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2577 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2577 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'P'
	add qword [rsp + 8], 1
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2568 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2568 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2578
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2578:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2579
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2579:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2580
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2580:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2581
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2581:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by I 
	jno .jump2582
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2582:
	imul rdi, [rsp + 0 + 8] ; multiply by (- E) 
	jno .jump2583
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2583:
	imul rdi, [rsp + 0 + 16] ; multiply by c 
	jno .jump2584
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2584:
	imul rdi, [rsp + 0 + 24] ; multiply by C 
	jno .jump2585
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2585:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump2586: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'R'
	add qword [rsp + 24], 1
	; Compare R to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2586 ; If R < bound, next iter
	mov qword [rsp + 24], 0 ; R = 0
	add qword [rsp + 16], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2586 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2586 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2586 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2587
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2587:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2588
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2588:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump2589: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'P'
	add qword [rsp + 8], 1
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2589 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2589 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2590
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2590:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2591
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2591:
	cmp rax, [rsp + 32]
	jl .jump2592
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2592:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2593
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2593:
	cmp rax, [rsp + 40]
	jl .jump2594
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2594:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2595
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2595:
	cmp rax, [rsp + 48]
	jl .jump2596
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2596:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2597
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2597:
	cmp rax, [rsp + 56]
	jl .jump2598
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2598:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const442] ; 40.99
	push rax
	mov rax, [rel const443] ; 12.35
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2599
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	jmp .jump2600
.jump2599:
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
.jump2600:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2601
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2601:
	cmp rax, [rsp + 16]
	jl .jump2602
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2602:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2603
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2603:
	cmp rax, [rsp + 24]
	jl .jump2604
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2604:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 40
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2605
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2605:
	cmp rax, [rsp + 32]
	jl .jump2606
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2606:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2607
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2607:
	cmp rax, [rsp + 40]
	jl .jump2608
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2608:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2609
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2609:
	cmp rax, [rsp + 48]
	jl .jump2610
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2610:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2611
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2611:
	cmp rax, [rsp + 56]
	jl .jump2612
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2612:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2613
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2613:
	cmp rax, [rsp + 8]
	jl .jump2614
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2614:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump2563
.jump2562:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump2615
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2617
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	jmp .jump2618
.jump2617:
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
.jump2618:
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	jmp .jump2616
.jump2615:
	mov rax, [rel const5] ; False
	push rax
.jump2616:
	pop rax
	cmp rax, 0
	je .jump2619
	mov rax, [rel const444] ; 16.59
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const445] ; 95.23
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 56
	; Moving 56 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - 136 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - 136 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 136 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 136 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 136 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 48 to rsp + 48 
		mov r10, [rsp + 48 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2621
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2621:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2622
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2622:
	; Computing bound for 'O'
	mov rax, [rel const446] ; 287
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2623
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2623:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump2624: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const447] ; 2.74
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2624 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2624 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2624 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2625
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2625:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump2626: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const448] ; 62.06
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'O'
	add qword [rsp + 0], 1
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2626 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 56
	; Moving 56 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - 136 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - 136 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 136 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 136 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 136 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Moving 32 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 24]
		mov [rsp + 24 + 24], r10
		mov r10, [rsp + 16 + 16]
		mov [rsp + 24 + 16], r10
		mov r10, [rsp + 16 + 8]
		mov [rsp + 24 + 8], r10
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const449] ; 22.75
	push rax
	jmp .jump2620
.jump2619:
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2627
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	jmp .jump2628
.jump2627:
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
.jump2628:
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const2] ; True
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump2629
	mov rax, [rel const2] ; True
	push rax
	jmp .jump2630
.jump2629:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump2630:
	pop rax
	cmp rax, 0
	je .jump2631
	sub rsp, 56
	; Moving 56 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - 136 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - 136 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 136 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 136 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 136 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 48 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	jmp .jump2632
.jump2631:
	sub rsp, 56
	; Moving 56 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - 136 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - 136 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 136 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 136 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 136 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 48 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
.jump2632:
	; Moving 32 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 24]
		mov [rsp + 24 + 24], r10
		mov r10, [rsp + 16 + 16]
		mov [rsp + 24 + 16], r10
		mov r10, [rsp + 16 + 8]
		mov [rsp + 24 + 8], r10
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
.jump2620:
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
.jump2563:
	sub rsp, 24
	; Moving 24 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2633
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2633:
	cmp rax, [rsp + 16]
	jl .jump2634
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2634:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2635
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2635:
	cmp rax, [rsp + 24]
	jl .jump2636
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2636:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2637
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump2639
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2641
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2641:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2642
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2642:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2643
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2643:
	; Computing total size of heap memory to allocate
	mov rdi, 56 ; sizeof u 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump2644
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2644:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump2645
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2645:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump2646
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2646:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump2647: ; Begin body of loop
	; Compute loop body
	sub rsp, 56
	; Moving 56 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - 136 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - 136 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 136 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 136 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 136 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 72]
	imul rax, 56
	add rax, [rsp + 104]
	; Move body (56 bytes) to index
	; Moving 56 bytes from rsp to rax 
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 56
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2647 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2647 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2647 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump2640
.jump2639:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2648
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2648:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2649
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2649:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2650
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2650:
	; Computing total size of heap memory to allocate
	mov rdi, 56 ; sizeof u 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump2651
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2651:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump2652
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2652:
	imul rdi, [rsp + 0 + 16] ; multiply by z 
	jno .jump2653
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2653:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump2654: ; Begin body of loop
	; Compute loop body
	sub rsp, 56
	; Moving 56 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - 136 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - 136 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 136 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 136 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 136 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 72]
	imul rax, 56
	add rax, [rsp + 104]
	; Move body (56 bytes) to index
	; Moving 56 bytes from rsp to rax 
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 56
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2654 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2654 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2654 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump2640:
	jmp .jump2638
.jump2637:
	sub rsp, 32
	; Moving 32 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2655
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2655:
	cmp rax, [rsp + 24]
	jl .jump2656
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2656:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2657
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2657:
	cmp rax, [rsp + 32]
	jl .jump2658
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2658:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2659
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2659:
	cmp rax, [rsp + 40]
	jl .jump2660
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2660:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2661
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2663
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2663:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2664
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2664:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2665
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2665:
	; Computing total size of heap memory to allocate
	mov rdi, 56 ; sizeof u 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump2666
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2666:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump2667
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2667:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump2668
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2668:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump2669: ; Begin body of loop
	; Compute loop body
	sub rsp, 56
	; Moving 56 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - 136 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - 136 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 136 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 136 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 136 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 72]
	imul rax, 56
	add rax, [rsp + 104]
	; Move body (56 bytes) to index
	; Moving 56 bytes from rsp to rax 
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 56
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2669 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2669 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2669 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump2662
.jump2661:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2670
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2670:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2671
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2671:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2672
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2672:
	; Computing total size of heap memory to allocate
	mov rdi, 56 ; sizeof u 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump2673
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2673:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump2674
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2674:
	imul rdi, [rsp + 0 + 16] ; multiply by s 
	jno .jump2675
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2675:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump2676: ; Begin body of loop
	; Compute loop body
	sub rsp, 56
	; Moving 56 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - 136 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - 136 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 136 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 136 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 136 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 72]
	imul rax, 56
	add rax, [rsp + 104]
	; Move body (56 bytes) to index
	; Moving 56 bytes from rsp to rax 
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 56
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2676 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2676 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2676 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump2662:
.jump2638:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2677
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2677:
	cmp rax, [rsp + 24]
	jl .jump2678
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2678:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2679
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2679:
	cmp rax, [rsp + 32]
	jl .jump2680
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2680:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2681
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2681:
	cmp rax, [rsp + 40]
	jl .jump2682
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2682:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 56
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 56
	; Moving 56 bytes from rax to rsp 
		mov r10, [rax + 48]
		mov [rsp + 48], r10
		mov r10, [rax + 40]
		mov [rsp + 40], r10
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 48 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	pop rax
	cmp rax, 0
	jne .jump2683
	sub rsp, 32
	; Moving 32 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 168 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 168 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2684
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2684:
	cmp rax, [rsp + 24]
	jl .jump2685
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2685:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2686
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2686:
	cmp rax, [rsp + 32]
	jl .jump2687
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2687:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2688
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2688:
	cmp rax, [rsp + 40]
	jl .jump2689
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2689:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
.jump2683:
	push rax
	pop rax
	cmp rax, 0
	je .jump2690
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump2692
	sub rsp, 56
	; Moving 56 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - 136 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - 136 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 136 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 136 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 136 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	jmp .jump2693
.jump2692:
	sub rsp, 56
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2694
	sub rsp, 32
	; Moving 32 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	jmp .jump2695
.jump2694:
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2696
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
.jump2696:
	push rax
	pop rax
	cmp rax, 0
	je .jump2697
	sub rsp, 32
	; Moving 32 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	jmp .jump2698
.jump2697:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2699
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2699:
	; Computing bound for 'P'
	mov rax, [rel const64] ; 159
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2700
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2700:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2701
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2701:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump2702
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2702:
	imul rdi, [rsp + 0 + 8] ; multiply by 159 
	jno .jump2703
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2703:
	imul rdi, [rsp + 0 + 16] ; multiply by d 
	jno .jump2704
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2704:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump2705: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2705 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2705 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2705 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump2698:
.jump2695:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2706
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2706:
	; Computing total size of heap memory to allocate
	mov rdi, 56 ; sizeof u 
	imul rdi, [rsp + 0 + 0] ; multiply by A 
	jno .jump2707
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2707:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump2708: ; Begin body of loop
	; Compute loop body
	sub rsp, 56
	; Moving 56 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - 136 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - 136 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 136 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 136 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 136 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 48 to rsp + 48 
		mov r10, [rsp + 48 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	sub rsp, 56
	; Moving 56 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - 136 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - 136 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 136 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 136 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 136 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Moving 32 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 24]
		mov [rsp + 24 + 24], r10
		mov r10, [rsp + 16 + 16]
		mov [rsp + 24 + 16], r10
		mov r10, [rsp + 16 + 8]
		mov [rsp + 24 + 8], r10
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const5] ; False
	push rax
	sub rsp, 56
	; Moving 56 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - 136 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - 136 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 136 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 136 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 136 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 48 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 56
	add rax, [rsp + 72]
	; Move body (56 bytes) to index
	; Moving 56 bytes from rsp to rax 
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 56
	; Increment 'O'
	add qword [rsp + 0], 1
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2708 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	lea rdi, [rsp + 120]
	call _x
	add rsp, 40
	add rsp, 16
	add rsp, 32
	add rsp, 32
.jump2693:
	; Moving 32 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 24]
		mov [rsp + 24 + 24], r10
		mov r10, [rsp + 16 + 16]
		mov [rsp + 24 + 16], r10
		mov r10, [rsp + 16 + 8]
		mov [rsp + 24 + 8], r10
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	jmp .jump2691
.jump2690:
	sub rsp, 56
	; Moving 56 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - 136 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - 136 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 136 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 136 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 136 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 48 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2709
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2711
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2711:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2712
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2712:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2713
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2713:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2714
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2714:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump2715: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2716
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2716:
	cmp rax, [rsp + 24]
	jl .jump2717
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2717:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2718
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2718:
	cmp rax, [rsp + 32]
	jl .jump2719
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2719:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2720
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2720:
	cmp rax, [rsp + 40]
	jl .jump2721
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2721:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump2722
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	jmp .jump2723
.jump2722:
	mov rax, [rel const450] ; 39.24
	push rax
.jump2723:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'R'
	add qword [rsp + 24], 1
	; Compare R to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2715 ; If R < bound, next iter
	mov qword [rsp + 24], 0 ; R = 0
	add qword [rsp + 16], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2715 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2715 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2715 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	jmp .jump2710
.jump2709:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2724
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2724:
	; Computing bound for 'O'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2725
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2725:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2726
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2726:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump2727: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'P'
	add qword [rsp + 8], 1
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2727 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2727 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2728
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2728:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[O : l, P : s] P) 
	jno .jump2729
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2729:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump2730
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2730:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump2731: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const451] ; 4.5
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'P'
	add qword [rsp + 8], 1
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2731 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2731 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2732
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2732:
	cmp rax, [rsp + 16]
	jl .jump2733
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2733:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2734
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2734:
	cmp rax, [rsp + 24]
	jl .jump2735
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2735:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2710:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2736
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2736:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2737
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2737:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump2738: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2739
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2739:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump2740: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2741
	mov rax, [rel const452] ; 51.01
	push rax
	jmp .jump2742
.jump2741:
	mov rax, [rel const453] ; 50.64
	push rax
.jump2742:
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'Q'
	add qword [rsp + 0], 1
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2740 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2743
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2743:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump2744: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'Q'
	add qword [rsp + 0], 1
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2744 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'P'
	add qword [rsp + 8], 1
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2738 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2738 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2745
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2745:
	; Computing bound for 'O'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2746
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2746:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2747
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2747:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump2748: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'P'
	add qword [rsp + 8], 1
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2748 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2748 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2749
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2749:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[O : i, P : l] (- l)) 
	jno .jump2750
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2750:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump2751
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2751:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump2752: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const454] ; 70.1
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'P'
	add qword [rsp + 8], 1
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2752 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2752 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const177] ; 284
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2753
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2753:
	cmp rax, [rsp + 16]
	jl .jump2754
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2754:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2755
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2755:
	cmp rax, [rsp + 24]
	jl .jump2756
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2756:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2757
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2757:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump2758
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2758:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump2759: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2760
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2760:
	cmp rax, [rsp + 24]
	jl .jump2761
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2761:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2762
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2762:
	cmp rax, [rsp + 32]
	jl .jump2763
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2763:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2764
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2764:
	cmp rax, [rsp + 40]
	jl .jump2765
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2765:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 0], 1
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2759 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2766
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2766:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2767
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2767:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump2768: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2769
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2769:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2770
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2770:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2771
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2771:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2772
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2772:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump2773: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 320 to rsp 
		mov r10, [rbp - 320 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'T'
	add qword [rsp + 24], 1
	; Compare T to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2773 ; If T < bound, next iter
	mov qword [rsp + 24], 0 ; T = 0
	add qword [rsp + 16], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2773 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2773 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2773 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'P'
	add qword [rsp + 8], 1
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2768 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2768 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2774
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2774:
	cmp rax, [rsp + 8]
	jl .jump2775
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2775:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2776
	sub rsp, 16
	; Moving 16 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2778
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2778:
	cmp rax, [rsp + 8]
	jl .jump2779
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2779:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 56
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 56
	; Moving 56 bytes from rax to rsp 
		mov r10, [rax + 48]
		mov [rsp + 48], r10
		mov r10, [rax + 40]
		mov [rsp + 40], r10
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 48 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	pop rax
	xor rax, 1
	push rax
	jmp .jump2777
.jump2776:
	mov rax, [rel const455] ; 30.85
	push rax
	mov rax, [rel const456] ; 78.44
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
.jump2777:
	pop rax
	cmp rax, 0
	je .jump2780
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump2782
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2784
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2784:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump2785: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const457] ; 45.78
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'O'
	add qword [rsp + 0], 1
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2785 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	sub rsp, 56
	; Moving 56 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - 136 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - 136 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 136 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 136 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 136 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 48 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	jmp .jump2783
.jump2782:
	sub rsp, 56
	; Moving 56 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - 136 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - 136 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 136 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 136 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 136 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
.jump2783:
	; Moving 8 bytes from rsp + 48 to rsp + 48 
		mov r10, [rsp + 48 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	jmp .jump2781
.jump2780:
	sub rsp, 56
	; Moving 56 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - 136 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - 136 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 136 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 136 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 136 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 48 to rsp + 48 
		mov r10, [rsp + 48 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	mov rax, [rel const458] ; 44.58
	push rax
	mov rax, [rel const459] ; 57.27
	push rax
	mov rax, [rel const460] ; 74.4
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const461] ; 53.2
	push rax
	mov rax, [rel const462] ; 79.35
	push rax
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump2781:
.jump2691:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2786
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2786:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2787
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2787:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2788
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2788:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2789
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2789:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump2790
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2790:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump2791
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2791:
	imul rdi, [rsp + 0 + 16] ; multiply by q 
	jno .jump2792
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2792:
	imul rdi, [rsp + 0 + 24] ; multiply by l 
	jno .jump2793
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2793:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump2794: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2795
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2795:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2796
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2796:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2797
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2797:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by P 
	jno .jump2798
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2798:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump2799
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2799:
	imul rdi, [rsp + 0 + 16] ; multiply by O 
	jno .jump2800
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2800:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump2801: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const463] ; 0.23
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'U'
	add qword [rsp + 16], 1
	; Compare U to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2801 ; If U < bound, next iter
	mov qword [rsp + 16], 0 ; U = 0
	add qword [rsp + 8], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2801 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2801 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2802
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2802:
	cmp rax, [rsp + 24]
	jl .jump2803
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2803:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2804
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2804:
	cmp rax, [rsp + 32]
	jl .jump2805
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2805:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2806
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2806:
	cmp rax, [rsp + 40]
	jl .jump2807
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2807:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'R'
	add qword [rsp + 24], 1
	; Compare R to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2794 ; If R < bound, next iter
	mov qword [rsp + 24], 0 ; R = 0
	add qword [rsp + 16], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2794 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2794 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2794 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const114] ; 270
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2808
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2808:
	cmp rax, [rsp + 32]
	jl .jump2809
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2809:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2810
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2810:
	cmp rax, [rsp + 40]
	jl .jump2811
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2811:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2812
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2812:
	cmp rax, [rsp + 48]
	jl .jump2813
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2813:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2814
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2814:
	cmp rax, [rsp + 56]
	jl .jump2815
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2815:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2816
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2816:
	; Computing total size of heap memory to allocate
	mov rdi, 56 ; sizeof u 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump2817
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2817:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump2818: ; Begin body of loop
	; Compute loop body
	sub rsp, 56
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	lea rdi, [rsp + 120]
	call _x
	add rsp, 40
	add rsp, 16
	add rsp, 32
	add rsp, 32
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 56
	add rax, [rsp + 72]
	; Move body (56 bytes) to index
	; Moving 56 bytes from rsp to rax 
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 56
	; Increment 'O'
	add qword [rsp + 0], 1
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2818 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2819
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2819:
	cmp rax, [rsp + 8]
	jl .jump2820
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2820:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 56
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 56
	; Moving 56 bytes from rax to rsp 
		mov r10, [rax + 48]
		mov [rsp + 48], r10
		mov r10, [rax + 40]
		mov [rsp + 40], r10
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 48 to rsp + 48 
		mov r10, [rsp + 48 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2821
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2822
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2822:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump2823
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2823:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump2824: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const2] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 0], 1
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2824 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2825
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2825:
	cmp rax, [rsp + 8]
	jl .jump2826
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2826:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
.jump2821:
	push rax
	sub rsp, 56
	; Moving 56 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - 136 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - 136 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 136 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 136 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 136 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 48 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 56 bytes from rsp to rax 
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 224 ; Local variables
	pop rbp
	ret
	sub rsp, 32
	; Moving 32 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 184 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 184 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 56
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2827
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2827:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2828
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2828:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2829
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2829:
	; Computing bound for 'S'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2830
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2830:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2831
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2831:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump2832: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'T'
	add qword [rsp + 8], 1
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2832 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2832 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2833
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2833:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof rgba[] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[S : p, T : c] h) 
	jno .jump2834
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2834:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump2835
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2835:
	imul rdi, [rsp + 0 + 16] ; multiply by A 
	jno .jump2836
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2836:
	imul rdi, [rsp + 0 + 24] ; multiply by l 
	jno .jump2837
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2837:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump2838: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'W'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 368 to rsp 
		mov r10, [rbp - 368 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2839
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2839:
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2840
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2840:
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2841
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2841:
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2842
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2842:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
	; Initialize 'W' to 0
	mov rax, 0
	push rax
.jump2843: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 456 to rsp 
		mov r10, [rbp - 456 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'Z'
	add qword [rsp + 24], 1
	; Compare Z to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2843 ; If Z < bound, next iter
	mov qword [rsp + 24], 0 ; Z = 0
	add qword [rsp + 16], 1 ; Y++
	; Compare Y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2843 ; If Y < bound, next iter
	mov qword [rsp + 16], 0 ; Y = 0
	add qword [rsp + 8], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2843 ; If X < bound, next iter
	mov qword [rsp + 8], 0 ; X = 0
	add qword [rsp + 0], 1 ; W++
	; Compare W to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2843 ; If W < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2844
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2844:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[W : G, X : b, Y : z, Z : U] X) 
	jno .jump2845
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2845:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'W' to 0
	mov rax, 0
	push rax
.jump2846: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump2847
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	jmp .jump2848
.jump2847:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2849
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2849:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2850
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2850:
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2851
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2851:
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2852
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2852:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by A 
	jno .jump2853
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2853:
	imul rdi, [rsp + 0 + 8] ; multiply by P 
	jno .jump2854
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2854:
	imul rdi, [rsp + 0 + 16] ; multiply by I 
	jno .jump2855
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2855:
	imul rdi, [rsp + 0 + 24] ; multiply by Q 
	jno .jump2856
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2856:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
.jump2857: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'aa'
	add qword [rsp + 24], 1
	; Compare aa to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2857 ; If aa < bound, next iter
	mov qword [rsp + 24], 0 ; aa = 0
	add qword [rsp + 16], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2857 ; If Z < bound, next iter
	mov qword [rsp + 16], 0 ; Z = 0
	add qword [rsp + 8], 1 ; Y++
	; Compare Y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2857 ; If Y < bound, next iter
	mov qword [rsp + 8], 0 ; Y = 0
	add qword [rsp + 0], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2857 ; If X < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2858
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2858:
	cmp rax, [rsp + 32]
	jl .jump2859
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2859:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2860
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2860:
	cmp rax, [rsp + 40]
	jl .jump2861
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2861:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2862
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2862:
	cmp rax, [rsp + 48]
	jl .jump2863
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2863:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2864
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2864:
	cmp rax, [rsp + 56]
	jl .jump2865
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2865:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2848:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'W'
	add qword [rsp + 0], 1
	; Compare W to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2846 ; If W < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'V'
	add qword [rsp + 24], 1
	; Compare V to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2838 ; If V < bound, next iter
	mov qword [rsp + 24], 0 ; V = 0
	add qword [rsp + 16], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2838 ; If U < bound, next iter
	mov qword [rsp + 16], 0 ; U = 0
	add qword [rsp + 8], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2838 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2838 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2866
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2866:
	cmp rax, [rsp + 32]
	jl .jump2867
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2867:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2868
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2868:
	cmp rax, [rsp + 40]
	jl .jump2869
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2869:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2870
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2870:
	cmp rax, [rsp + 48]
	jl .jump2871
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2871:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2872
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2872:
	cmp rax, [rsp + 56]
	jl .jump2873
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2873:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2874
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2874:
	cmp rax, [rsp + 8]
	jl .jump2875
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2875:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump2876
	sub rsp, 32
	; Moving 32 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	jmp .jump2877
.jump2876:
	sub rsp, 32
	; Moving 32 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
.jump2877:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2878
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2878:
	; Computing total size of heap memory to allocate
	mov rdi, 56 ; sizeof u 
	imul rdi, [rsp + 0 + 0] ; multiply by G 
	jno .jump2879
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2879:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump2880: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump2881
	sub rsp, 16
	; Moving 16 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2883
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2883:
	cmp rax, [rsp + 8]
	jl .jump2884
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2884:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 56
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 56
	; Moving 56 bytes from rax to rsp 
		mov r10, [rax + 48]
		mov [rsp + 48], r10
		mov r10, [rax + 40]
		mov [rsp + 40], r10
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 48 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	pop rax
	cmp rax, 0
	je .jump2885
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	jmp .jump2886
.jump2885:
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump2887
	mov rax, [rel const2] ; True
	push rax
	jmp .jump2888
.jump2887:
	mov rax, [rel const5] ; False
	push rax
.jump2888:
.jump2886:
	pop rax
	cmp rax, 0
	je .jump2889
	mov rax, [rel const5] ; False
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	jmp .jump2890
.jump2889:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2891
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2891:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by P 
	jno .jump2892
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2892:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump2893: ; Begin body of loop
	; Compute loop body
	sub rsp, 56
	; Moving 56 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - 136 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - 136 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 136 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 136 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 136 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 48 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'T'
	add qword [rsp + 0], 1
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2893 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const464] ; 844
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2894
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2894:
	cmp rax, [rsp + 8]
	jl .jump2895
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2895:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2890:
	jmp .jump2882
.jump2881:
	mov rax, [rel const465] ; 6.62
	push rax
	sub rsp, 24
	; Moving 24 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2896
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2896:
	cmp rax, [rsp + 16]
	jl .jump2897
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2897:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2898
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2898:
	cmp rax, [rsp + 24]
	jl .jump2899
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2899:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2900
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump2901
	mov rax, [rel const5] ; False
	push rax
	jmp .jump2902
.jump2901:
	mov rax, [rel const5] ; False
	push rax
.jump2902:
	pop rax
.jump2900:
	push rax
	pop rax
	cmp rax, 0
	je .jump2903
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2905
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
.jump2905:
	push rax
	pop rax
	cmp rax, 0
	je .jump2906
	mov rax, [rel const466] ; 35.68
	push rax
	mov rax, [rel const467] ; 15.69
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump2907
.jump2906:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2908
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2908:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2909
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2909:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump2910: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const468] ; 79.42
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'U'
	add qword [rsp + 8], 1
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2910 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2910 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump2907:
	jmp .jump2904
.jump2903:
	mov rax, [rel const469] ; 38.95
	push rax
.jump2904:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
.jump2882:
	pop rax
	cmp rax, 0
	je .jump2911
	sub rsp, 56
	; Moving 56 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - 136 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - 136 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 136 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 136 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 136 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	jmp .jump2912
.jump2911:
	sub rsp, 56
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2913
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2913:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2914
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2914:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2915
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2915:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2916
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2916:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by P 
	jno .jump2917
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2917:
	imul rdi, [rsp + 0 + 8] ; multiply by (k % C) 
	jno .jump2918
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2918:
	imul rdi, [rsp + 0 + 16] ; multiply by P 
	jno .jump2919
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2919:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump2920: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2921
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	jmp .jump2922
.jump2921:
	sub rsp, 32
	; Moving 32 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
.jump2922:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'V'
	add qword [rsp + 16], 1
	; Compare V to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2920 ; If V < bound, next iter
	mov qword [rsp + 16], 0 ; V = 0
	add qword [rsp + 8], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2920 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2920 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2923
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2923:
	cmp rax, [rsp + 24]
	jl .jump2924
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2924:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2925
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2925:
	cmp rax, [rsp + 32]
	jl .jump2926
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2926:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2927
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2927:
	cmp rax, [rsp + 40]
	jl .jump2928
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2928:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2929
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2929:
	cmp rax, [rsp + 16]
	jl .jump2930
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2930:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2931
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2931:
	cmp rax, [rsp + 24]
	jl .jump2932
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2932:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2933
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2933:
	cmp rax, [rsp + 8]
	jl .jump2934
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2934:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2935
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2937
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2937:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2938
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2938:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2939
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
.jump2939:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2940
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2940:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (k / I) 
	jno .jump2941
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2941:
	imul rdi, [rsp + 0 + 8] ; multiply by H 
	jno .jump2942
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2942:
	imul rdi, [rsp + 0 + 16] ; multiply by A 
	jno .jump2943
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2943:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump2944: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'V'
	add qword [rsp + 16], 1
	; Compare V to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2944 ; If V < bound, next iter
	mov qword [rsp + 16], 0 ; V = 0
	add qword [rsp + 8], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2944 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2944 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2945
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2945:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump2946: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'T'
	add qword [rsp + 0], 1
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2946 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2947
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2947:
	cmp rax, [rsp + 24]
	jl .jump2948
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2948:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2949
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2949:
	cmp rax, [rsp + 32]
	jl .jump2950
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2950:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2951
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2951:
	cmp rax, [rsp + 40]
	jl .jump2952
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2952:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump2936
.jump2935:
	mov rax, [rel const470] ; 2.16
	push rax
	mov rax, [rel const471] ; 66.02
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2953
	sub rsp, 56
	; Moving 56 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - 136 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - 136 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 136 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 136 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 136 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 48 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	pop rax
	cmp rax, 0
	je .jump2955
	sub rsp, 32
	; Moving 32 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	jmp .jump2956
.jump2955:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump2957
	sub rsp, 32
	; Moving 32 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	jmp .jump2958
.jump2957:
	sub rsp, 32
	; Moving 32 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
.jump2958:
.jump2956:
	jmp .jump2954
.jump2953:
	sub rsp, 32
	; Moving 32 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
.jump2954:
.jump2936:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2959
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2959:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2960
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2960:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2961
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2961:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2962
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2962:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2963
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2963:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof u[][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (l % i) 
	jno .jump2964
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2964:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump2965
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2965:
	imul rdi, [rsp + 0 + 16] ; multiply by d 
	jno .jump2966
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2966:
	imul rdi, [rsp + 0 + 24] ; multiply by H 
	jno .jump2967
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2967:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump2968: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2969
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2969:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2970
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2970:
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2971
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2971:
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2972
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2972:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof u[] 
	imul rdi, [rsp + 0 + 0] ; multiply by I 
	jno .jump2973
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2973:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump2974
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2974:
	imul rdi, [rsp + 0 + 16] ; multiply by q 
	jno .jump2975
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2975:
	imul rdi, [rsp + 0 + 24] ; multiply by E 
	jno .jump2976
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2976:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
.jump2977: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'aa'
	add qword [rsp + 24], 1
	; Compare aa to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2977 ; If aa < bound, next iter
	mov qword [rsp + 24], 0 ; aa = 0
	add qword [rsp + 16], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2977 ; If Z < bound, next iter
	mov qword [rsp + 16], 0 ; Z = 0
	add qword [rsp + 8], 1 ; Y++
	; Compare Y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2977 ; If Y < bound, next iter
	mov qword [rsp + 8], 0 ; Y = 0
	add qword [rsp + 0], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2977 ; If X < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'W'
	add qword [rsp + 24], 1
	; Compare W to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2968 ; If W < bound, next iter
	mov qword [rsp + 24], 0 ; W = 0
	add qword [rsp + 16], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2968 ; If V < bound, next iter
	mov qword [rsp + 16], 0 ; V = 0
	add qword [rsp + 8], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2968 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2968 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 400 to rsp 
		mov r10, [rbp - 400 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2978
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2978:
	cmp rax, [rsp + 32]
	jl .jump2979
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2979:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2980
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2980:
	cmp rax, [rsp + 40]
	jl .jump2981
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2981:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2982
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2982:
	cmp rax, [rsp + 48]
	jl .jump2983
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2983:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2984
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2984:
	cmp rax, [rsp + 56]
	jl .jump2985
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2985:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 400 to rsp 
		mov r10, [rbp - 400 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2986
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2986:
	cmp rax, [rsp + 32]
	jl .jump2987
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2987:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2988
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2988:
	cmp rax, [rsp + 40]
	jl .jump2989
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2989:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2990
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2990:
	cmp rax, [rsp + 48]
	jl .jump2991
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2991:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2992
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2992:
	cmp rax, [rsp + 56]
	jl .jump2993
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2993:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from rbp - 400 to rsp 
		mov r10, [rbp - 400 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2994
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2994:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2995
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2995:
	; Computing bound for 'U'
	mov rax, [rel const472] ; 321
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2996
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2996:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2997
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2997:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof u[,][,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump2998
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2998:
	imul rdi, [rsp + 0 + 8] ; multiply by 321 
	jno .jump2999
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2999:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump3000
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3000:
	imul rdi, [rsp + 0 + 24] ; multiply by S 
	jno .jump3001
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3001:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump3002: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3003
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3003:
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 400 to rsp 
		mov r10, [rbp - 400 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3004
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3004:
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3005
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3005:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof u[,][,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump3006
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3006:
	imul rdi, [rsp + 0 + 8] ; multiply by S 
	jno .jump3007
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3007:
	imul rdi, [rsp + 0 + 16] ; multiply by z 
	jno .jump3008
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3008:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
.jump3009: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'Z'
	add qword [rsp + 16], 1
	; Compare Z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3009 ; If Z < bound, next iter
	mov qword [rsp + 16], 0 ; Z = 0
	add qword [rsp + 8], 1 ; Y++
	; Compare Y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3009 ; If Y < bound, next iter
	mov qword [rsp + 8], 0 ; Y = 0
	add qword [rsp + 0], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3009 ; If X < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3010
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3010:
	cmp rax, [rsp + 24]
	jl .jump3011
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3011:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3012
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3012:
	cmp rax, [rsp + 32]
	jl .jump3013
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3013:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3014
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3014:
	cmp rax, [rsp + 40]
	jl .jump3015
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3015:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'W'
	add qword [rsp + 24], 1
	; Compare W to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3002 ; If W < bound, next iter
	mov qword [rsp + 24], 0 ; W = 0
	add qword [rsp + 16], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3002 ; If V < bound, next iter
	mov qword [rsp + 16], 0 ; V = 0
	add qword [rsp + 8], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3002 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3002 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3016
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3016:
	cmp rax, [rsp + 32]
	jl .jump3017
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3017:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3018
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3018:
	cmp rax, [rsp + 40]
	jl .jump3019
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3019:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3020
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3020:
	cmp rax, [rsp + 48]
	jl .jump3021
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3021:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3022
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3022:
	cmp rax, [rsp + 56]
	jl .jump3023
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3023:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	lea rdi, [rsp + 120]
	call _x
	add rsp, 40
	add rsp, 16
	add rsp, 32
	add rsp, 32
.jump2912:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 56
	add rax, [rsp + 72]
	; Move body (56 bytes) to index
	; Moving 56 bytes from rsp to rax 
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 56
	; Increment 'S'
	add qword [rsp + 0], 1
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2880 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 56
	; Moving 56 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - 136 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - 136 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 136 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 136 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 136 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 48 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	pop rax
	cmp rax, 0
	je .jump3024
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump3026
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3028
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3028:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof u[,][,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by Q 
	jno .jump3029
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3029:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump3030: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'S'
	add qword [rsp + 0], 1
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3030 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump3027
.jump3026:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3031
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3031:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof u[,][,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump3032
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3032:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump3033: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'S'
	add qword [rsp + 0], 1
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3033 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump3027:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3034
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3034:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof u[,][,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump3035
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3035:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump3036: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump3037
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3039
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump3040
.jump3039:
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump3040:
	jmp .jump3038
.jump3037:
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3041
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump3042
.jump3041:
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump3042:
.jump3038:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'S'
	add qword [rsp + 0], 1
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3036 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3043
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3043:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3044
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3044:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof u[,][,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by A 
	jno .jump3045
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3045:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump3046
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3046:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump3047: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'T'
	add qword [rsp + 8], 1
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3047 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3047 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3048
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3048:
	cmp rax, [rsp + 16]
	jl .jump3049
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3049:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3050
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3050:
	cmp rax, [rsp + 24]
	jl .jump3051
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3051:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 40
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3052
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3052:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3053
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3053:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3054
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3054:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof u[,][,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump3055
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3055:
	imul rdi, [rsp + 0 + 8] ; multiply by I 
	jno .jump3056
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3056:
	imul rdi, [rsp + 0 + 16] ; multiply by A 
	jno .jump3057
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3057:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump3058: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'U'
	add qword [rsp + 16], 1
	; Compare U to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3058 ; If U < bound, next iter
	mov qword [rsp + 16], 0 ; U = 0
	add qword [rsp + 8], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3058 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3058 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3059
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3059:
	cmp rax, [rsp + 24]
	jl .jump3060
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3060:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3061
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3061:
	cmp rax, [rsp + 32]
	jl .jump3062
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3062:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3063
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3063:
	cmp rax, [rsp + 40]
	jl .jump3064
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3064:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3065
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3065:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3066
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3066:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof u[,][,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump3067
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3067:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump3068
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3068:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump3069: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'T'
	add qword [rsp + 8], 1
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3069 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3069 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3070
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3070:
	cmp rax, [rsp + 16]
	jl .jump3071
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3071:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3072
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3072:
	cmp rax, [rsp + 24]
	jl .jump3073
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3073:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 40
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rdi, 120
	call _jpl_alloc
	; Moving 120 bytes from rsp to rax 
		mov r10, [rsp + 112]
		mov [rax + 112], r10
		mov r10, [rsp + 104]
		mov [rax + 104], r10
		mov r10, [rsp + 96]
		mov [rax + 96], r10
		mov r10, [rsp + 88]
		mov [rax + 88], r10
		mov r10, [rsp + 80]
		mov [rax + 80], r10
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 120
	push rax
	mov rax, 3
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3074
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3074:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof u[,][,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump3075
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3075:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump3076: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3077
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3077:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3078
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3078:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3079
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3079:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3080
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3080:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof u[,][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump3081
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3081:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump3082
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3082:
	imul rdi, [rsp + 0 + 16] ; multiply by B 
	jno .jump3083
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3083:
	imul rdi, [rsp + 0 + 24] ; multiply by R 
	jno .jump3084
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3084:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump3085: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 528 to rsp 
		mov r10, [rbp - 528 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 536 to rsp 
		mov r10, [rbp - 536 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 464 to rsp 
		mov r10, [rbp - 464 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3086
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3086:
	cmp rax, [rsp + 32]
	jl .jump3087
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3087:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3088
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3088:
	cmp rax, [rsp + 40]
	jl .jump3089
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3089:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3090
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3090:
	cmp rax, [rsp + 48]
	jl .jump3091
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3091:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3092
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3092:
	cmp rax, [rsp + 56]
	jl .jump3093
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3093:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'W'
	add qword [rsp + 24], 1
	; Compare W to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3085 ; If W < bound, next iter
	mov qword [rsp + 24], 0 ; W = 0
	add qword [rsp + 16], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3085 ; If V < bound, next iter
	mov qword [rsp + 16], 0 ; V = 0
	add qword [rsp + 8], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3085 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3085 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'S'
	add qword [rsp + 0], 1
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3076 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rdi, 64
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 64 bytes from rsp to rax 
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 64
	push rax
	mov rax, 4
	push rax
	jmp .jump3025
.jump3024:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3094
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3094:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3095
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3095:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof u[,][,,][,,,][][] 
	imul rdi, [rsp + 0 + 0] ; multiply by B 
	jno .jump3096
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3096:
	imul rdi, [rsp + 0 + 8] ; multiply by R 
	jno .jump3097
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3097:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump3098: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3099
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3099:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof u[,][,,][,,,][] 
	imul rdi, [rsp + 0 + 0] ; multiply by B 
	jno .jump3100
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3100:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
.jump3101: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rdi, 40
	call _jpl_alloc
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	push rax
	mov rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 32]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'U'
	add qword [rsp + 0], 1
	; Compare U to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3101 ; If U < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'T'
	add qword [rsp + 8], 1
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3098 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3098 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3102
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3102:
	cmp rax, [rsp + 16]
	jl .jump3103
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3103:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3104
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3104:
	cmp rax, [rsp + 24]
	jl .jump3105
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3105:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 16
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump3025:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3106
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3106:
	cmp rax, [rsp + 8]
	jl .jump3107
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3107:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3108
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3108:
	cmp rax, [rsp + 8]
	jl .jump3109
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3109:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	lea rdi, [rsp + 120]
	call _x
	add rsp, 40
	add rsp, 16
	add rsp, 32
	add rsp, 32
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 56 bytes from rsp to rax 
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 312 ; Local variables
	pop rbp
	ret

z:
_z:
	push rbp
	mov rbp, rsp
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const473] ; 91.48
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const474] ; 76.09
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const475] ; 31.87
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3110
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3110:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3111
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3111:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump3112
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3112:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump3113
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3113:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3114: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const476] ; 11.43
	push rax
	mov rax, [rel const477] ; 96.42
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3114 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3114 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3115
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3115:
	cmp rax, [rsp + 16]
	jl .jump3116
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3116:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3117
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3117:
	cmp rax, [rsp + 24]
	jl .jump3118
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3118:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3119
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3121
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump3122
.jump3121:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump3122:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3123
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3125
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3125:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3126
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3126:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3127: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3127 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3127 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3128
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3128:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3129
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3129:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3130
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3130:
	; Computing bound for 'A'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3131
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3131:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3132: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'A'
	add qword [rsp + 0], 1
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3132 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3133
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3133:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[A : i] d) 
	jno .jump3134
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3134:
	imul rdi, [rsp + 0 + 8] ; multiply by (- w) 
	jno .jump3135
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3135:
	imul rdi, [rsp + 0 + 16] ; multiply by c 
	jno .jump3136
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3136:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[A : n, B : k] k) 
	jno .jump3137
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3137:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3138: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3139
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3139:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3140
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3140:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3141
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3141:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump3142
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3142:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump3143
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3143:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump3144
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3144:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3145: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const2] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'G'
	add qword [rsp + 16], 1
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3145 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3145 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3145 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3138 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3138 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3138 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3138 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump3124
.jump3123:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	mov rax, [rel const76] ; 530
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3146
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3146:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3147
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3147:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3148
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3148:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3149
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3149:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump3150
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3150:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump3151
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3151:
	imul rdi, [rsp + 0 + 16] ; multiply by q 
	jno .jump3152
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3152:
	imul rdi, [rsp + 0 + 24] ; multiply by 530 
	jno .jump3153
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3153:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3154: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3154 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3154 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3154 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3154 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump3124:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3155
	sub rsp, 16
	; Moving 16 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3157
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3157:
	cmp rax, [rsp + 8]
	jl .jump3158
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3158:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3156
.jump3155:
	call _f
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3159
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump3160
.jump3159:
	mov rax, [rel const478] ; 831
	push rax
.jump3160:
.jump3156:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3161
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3161:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3162
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3162:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3163
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3163:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3164: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3164 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3164 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3164 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3165
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3165:
	cmp rax, [rsp + 32]
	jl .jump3166
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3166:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3167
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3167:
	cmp rax, [rsp + 40]
	jl .jump3168
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3168:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3169
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3169:
	cmp rax, [rsp + 48]
	jl .jump3170
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3170:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3171
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3171:
	cmp rax, [rsp + 56]
	jl .jump3172
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3172:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3120
.jump3119:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3173
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3173:
	; Computing bound for 'C'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3174
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3174:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3175
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3175:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3176: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3176 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3176 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3177
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3177:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3178
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3178:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3179
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3179:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[,,][] 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump3180
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3180:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump3181
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3181:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[A : k, B : b] d) 
	jno .jump3182
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3182:
	imul rdi, [rsp + 0 + 24] ; multiply by q 
	jno .jump3183
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3183:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3184: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3185
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3185:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by C 
	jno .jump3186
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3186:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3187: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'E'
	add qword [rsp + 0], 1
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3187 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3184 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3184 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3184 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3184 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3188
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3188:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump3189
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3189:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3190: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'A'
	add qword [rsp + 0], 1
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3190 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3191
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3191:
	cmp rax, [rsp + 8]
	jl .jump3192
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3192:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3193
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3193:
	cmp rax, [rsp + 32]
	jl .jump3194
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3194:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3195
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3195:
	cmp rax, [rsp + 40]
	jl .jump3196
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3196:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3197
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3197:
	cmp rax, [rsp + 48]
	jl .jump3198
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3198:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3199
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3199:
	cmp rax, [rsp + 56]
	jl .jump3200
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3200:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3201
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3201:
	cmp rax, [rsp + 24]
	jl .jump3202
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3202:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3203
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3203:
	cmp rax, [rsp + 32]
	jl .jump3204
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3204:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3205
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3205:
	cmp rax, [rsp + 40]
	jl .jump3206
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3206:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3207
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3209
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3209:
	cqo
	idiv r10
	push rax
	jmp .jump3208
.jump3207:
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
.jump3208:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3210
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3210:
	cmp rax, [rsp + 8]
	jl .jump3211
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3211:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump3120:
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3212
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3212:
	cmp rax, [rsp + 24]
	jl .jump3213
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3213:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3214
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3214:
	cmp rax, [rsp + 32]
	jl .jump3215
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3215:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3216
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3216:
	cmp rax, [rsp + 40]
	jl .jump3217
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3217:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3218
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	jmp .jump3219
.jump3218:
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
.jump3219:
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump3220
	lea rdi, [rel const479] ; 'A'
	call _fail_assertion
.jump3220:
	sub rsp, 16
	; Moving 16 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 40
	; Moving 40 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3221
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3221:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3222
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3222:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3223: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 216 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3224
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3224:
	cmp rax, [rsp + 16]
	jl .jump3225
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3225:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3226
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3226:
	cmp rax, [rsp + 24]
	jl .jump3227
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3227:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3223 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3223 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3228
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3228:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3229
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3229:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3230
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3230:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump3231
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3231:
	imul rdi, [rsp + 0 + 8] ; multiply by G 
	jno .jump3232
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3232:
	imul rdi, [rsp + 0 + 16] ; multiply by G 
	jno .jump3233
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3233:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3234: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const480] ; 21.18
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3234 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3234 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3234 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3235
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3235:
	cmp rax, [rsp + 24]
	jl .jump3236
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3236:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3237
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3237:
	cmp rax, [rsp + 32]
	jl .jump3238
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3238:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3239
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3239:
	cmp rax, [rsp + 40]
	jl .jump3240
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3240:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3241
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3241:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3242
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3242:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3243
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3243:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump3244
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3244:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump3245
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3245:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump3246
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3246:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3247: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const481] ; 38.51
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3247 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3247 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3247 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3248
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3248:
	cmp rax, [rsp + 24]
	jl .jump3249
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3249:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3250
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3250:
	cmp rax, [rsp + 32]
	jl .jump3251
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3251:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3252
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3252:
	cmp rax, [rsp + 40]
	jl .jump3253
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3253:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	mov rax, [rel const2] ; True
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3254
	mov rax, [rel const482] ; 3.34
	push rax
	jmp .jump3255
.jump3254:
	mov rax, [rel const483] ; 50.16
	push rax
	mov rax, [rel const484] ; 14.72
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
.jump3255:
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3256
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3258
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3258:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3259
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3259:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3260: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const485] ; 28.7
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3260 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3260 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump3257
.jump3256:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'L'
	mov rax, [rel const486] ; 45
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3261
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3261:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3262
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3262:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3263
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3263:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3264: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const487] ; 77.05
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3264 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3264 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3264 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump3257:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3265
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3265:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3266
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3266:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3267
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3267:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3268
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3268:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump3269
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3269:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump3270
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3270:
	imul rdi, [rsp + 0 + 16] ; multiply by F 
	jno .jump3271
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3271:
	imul rdi, [rsp + 0 + 24] ; multiply by I 
	jno .jump3272
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3272:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3273: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'M'
	add qword [rsp + 24], 1
	; Compare M to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3273 ; If M < bound, next iter
	mov qword [rsp + 24], 0 ; M = 0
	add qword [rsp + 16], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3273 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3273 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3273 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3274
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3274:
	cmp rax, [rsp + 32]
	jl .jump3275
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3275:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3276
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3276:
	cmp rax, [rsp + 40]
	jl .jump3277
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3277:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3278
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3278:
	cmp rax, [rsp + 48]
	jl .jump3279
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3279:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3280
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3280:
	cmp rax, [rsp + 56]
	jl .jump3281
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3281:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3282
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	jmp .jump3283
.jump3282:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	xor rax, 1
	push rax
.jump3283:
	pop rax
	cmp rax, 0
	je .jump3284
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3286
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump3287
.jump3286:
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	push rax
.jump3287:
	jmp .jump3285
.jump3284:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3288
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3288:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3289
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3289:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump3290
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3290:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump3291
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3291:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3292: ; Begin body of loop
	; Compute loop body
	call _z
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3292 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3292 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3293
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3293:
	cmp rax, [rsp + 16]
	jl .jump3294
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3294:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3295
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3295:
	cmp rax, [rsp + 24]
	jl .jump3296
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3296:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump3285:
	; Moving 8 bytes from rsp + 8 to rsp + 48 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	pop rax
	cmp rax, 0
	jne .jump3297
	mov rax, [rel const488] ; 47.02
	push rax
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump3298
	sub rsp, 24
	; Moving 24 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 216 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	jmp .jump3299
.jump3298:
	sub rsp, 24
	; Moving 24 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 216 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
.jump3299:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3300
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3300:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3301
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3301:
	; Computing bound for 'J'
	mov rax, [rel const28] ; 279
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3302
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3302:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3303: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3303 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3303 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3303 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3304
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3304:
	cmp rax, [rsp + 16]
	jl .jump3305
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3305:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3306
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3306:
	cmp rax, [rsp + 24]
	jl .jump3307
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3307:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3308
	mov rax, [rel const2] ; True
	push rax
	jmp .jump3309
.jump3308:
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump3310
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	jmp .jump3311
.jump3310:
	mov rax, [rel const2] ; True
	push rax
.jump3311:
.jump3309:
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	push rax
	; Moving 8 bytes from rsp + 8 to rsp + 48 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	pop rax
.jump3297:
	push rax
	pop rax
	cmp rax, 0
	je .jump3312
	mov rax, [rel const2] ; True
	push rax
	pop rax
.jump3312:
	push rax
	mov rax, [rel const489] ; 61.55
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3313
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3313:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3314
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3314:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3315
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3315:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3316: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'M'
	mov rax, [rel const490] ; 990
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3317
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3317:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump3318: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const491] ; 99.09
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'M'
	add qword [rsp + 0], 1
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3318 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3316 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3316 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3316 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3319
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3319:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3320
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3320:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3321: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const492] ; 79.29
	push rax
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3322
	mov rax, [rel const493] ; 98.1
	push rax
	jmp .jump3323
.jump3322:
	mov rax, [rel const494] ; 10.34
	push rax
.jump3323:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3321 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3321 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3324
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	jmp .jump3325
.jump3324:
	mov rax, [rel const2] ; True
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3326
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3326:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3327
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3327:
	; Computing bound for 'J'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3328
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3328:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3329
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3329:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3330: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3330 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3330 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3331
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3331:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[J : s, K : h] I) 
	jno .jump3332
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3332:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump3333
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3333:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump3334
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3334:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3335: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const495] ; 64.44
	push rax
	mov rax, [rel const496] ; 10.6
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3335 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3335 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3335 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 16
	; Moving 16 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3336
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3336:
	cmp rax, [rsp + 8]
	jl .jump3337
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3337:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3338
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3338:
	cmp rax, [rsp + 24]
	jl .jump3339
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3339:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3340
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3340:
	cmp rax, [rsp + 32]
	jl .jump3341
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3341:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3342
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3342:
	cmp rax, [rsp + 40]
	jl .jump3343
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3343:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
.jump3325:
	pop rax
	cmp rax, 0
	jne .jump3344
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3345
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3347
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3347:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3348
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3348:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3349
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3349:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump3350
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3350:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump3351
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3351:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump3352
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3352:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3353: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3354
	sub rsp, 32
	; Moving 32 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump3355
.jump3354:
	sub rsp, 32
	; Moving 32 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
.jump3355:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const497] ; 540
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3356
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3356:
	cmp rax, [rsp + 24]
	jl .jump3357
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3357:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3358
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3358:
	cmp rax, [rsp + 32]
	jl .jump3359
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3359:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3360
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3360:
	cmp rax, [rsp + 40]
	jl .jump3361
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3361:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3362
	mov rax, [rel const5] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump3362:
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3353 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3353 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3353 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump3346
.jump3345:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3363
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3363:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3364
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3364:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3365
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3365:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump3366
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3366:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump3367
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3367:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump3368
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3368:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3369: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3369 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3369 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3369 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3370
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3370:
	cmp rax, [rsp + 8]
	jl .jump3371
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3371:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump3372
	mov rax, [rel const498] ; 34.56
	push rax
	mov rax, [rel const499] ; 73.6
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
.jump3372:
	push rax
	pop rax
	cmp rax, 0
	je .jump3373
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	jmp .jump3374
.jump3373:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3375
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3375:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3376
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3376:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3377
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3377:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3378
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3378:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3379: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'M'
	add qword [rsp + 24], 1
	; Compare M to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3379 ; If M < bound, next iter
	mov qword [rsp + 24], 0 ; M = 0
	add qword [rsp + 16], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3379 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3379 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3379 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const420] ; 947
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
.jump3374:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3380
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3380:
	cmp rax, [rsp + 24]
	jl .jump3381
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3381:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3382
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3382:
	cmp rax, [rsp + 32]
	jl .jump3383
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3383:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3384
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3384:
	cmp rax, [rsp + 40]
	jl .jump3385
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3385:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump3346:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3386
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3386:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3387
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3387:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3388
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3388:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3389
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3389:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3390: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const93] ; 987
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'M'
	add qword [rsp + 24], 1
	; Compare M to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3390 ; If M < bound, next iter
	mov qword [rsp + 24], 0 ; M = 0
	add qword [rsp + 16], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3390 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3390 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3390 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3391
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3391:
	cmp rax, [rsp + 24]
	jl .jump3392
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3392:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3393
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3393:
	cmp rax, [rsp + 32]
	jl .jump3394
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3394:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3395
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3395:
	cmp rax, [rsp + 40]
	jl .jump3396
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3396:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
.jump3344:
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump3397
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const500] ; 'J'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3397:
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	push rax
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3398
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3398:
	cmp rax, [rsp + 8]
	jl .jump3399
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3399:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add rsp, 72 ; Local variables
	pop rbp
	ret

B:
_B:
	push rbp
	mov rbp, rsp
	sub rsp, 8
	movsd [rsp], xmm0
	push rdi
	push rsi
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3721
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3721:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3722
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3722:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3723
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3723:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[][,,][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump3724
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3724:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump3725
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3725:
	imul rdi, [rsp + 0 + 16] ; multiply by q 
	jno .jump3726
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3726:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump3727: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3728
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3728:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3729
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3729:
	; Computing bound for 'J'
	mov rax, [rel const28] ; 279
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3730
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3730:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 279 
	jno .jump3731
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3731:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump3732
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3732:
	imul rdi, [rsp + 0 + 16] ; multiply by G 
	jno .jump3733
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3733:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3734: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3735
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3735:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3736
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3736:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3737
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3737:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by J 
	jno .jump3738
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3738:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump3739
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3739:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump3740
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3740:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump3741: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'O'
	add qword [rsp + 16], 1
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3741 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3741 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3741 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3734 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3734 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3734 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'I'
	add qword [rsp + 16], 1
	; Compare I to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3727 ; If I < bound, next iter
	mov qword [rsp + 16], 0 ; I = 0
	add qword [rsp + 8], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3727 ; If H < bound, next iter
	mov qword [rsp + 8], 0 ; H = 0
	add qword [rsp + 0], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3727 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3742
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3742:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3743
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3743:
	; Computing bound for 'G'
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump3744
	call _f
	push rax
	jmp .jump3745
.jump3744:
	call _f
	push rax
.jump3745:
	pop rax
	cmp rax, 0
	je .jump3746
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	jmp .jump3747
.jump3746:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
.jump3747:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3748
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3748:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[][,,][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if (if f() then f() else f()) then q else b) 
	jno .jump3749
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3749:
	imul rdi, [rsp + 0 + 8] ; multiply by (- r) 
	jno .jump3750
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3750:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump3751
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3751:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump3752: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3753
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3753:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3754
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3754:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3755
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3755:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- n) 
	jno .jump3756
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3756:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump3757
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3757:
	imul rdi, [rsp + 0 + 16] ; multiply by d 
	jno .jump3758
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3758:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3759: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3760
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3760:
	; Computing bound for 'N'
	mov rax, [rel const524] ; 999
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3761
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3761:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3762
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3762:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by K 
	jno .jump3763
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3763:
	imul rdi, [rsp + 0 + 8] ; multiply by 999 
	jno .jump3764
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3764:
	imul rdi, [rsp + 0 + 16] ; multiply by L 
	jno .jump3765
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3765:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump3766: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'O'
	add qword [rsp + 16], 1
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3766 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3766 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3766 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3759 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3759 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3759 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'I'
	add qword [rsp + 16], 1
	; Compare I to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3752 ; If I < bound, next iter
	mov qword [rsp + 16], 0 ; I = 0
	add qword [rsp + 8], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3752 ; If H < bound, next iter
	mov qword [rsp + 8], 0 ; H = 0
	add qword [rsp + 0], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3752 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rdi, 64
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 64 bytes from rsp to rax 
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 64
	push rax
	mov rax, 2
	push rax
	mov rax, [rel const238] ; 918
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3767
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3767:
	cmp rax, [rsp + 8]
	jl .jump3768
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3768:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const525] ; 85.73
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3769
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3769:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3770
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3770:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3771
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3771:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3772
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3772:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump3773
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3773:
	imul rdi, [rsp + 0 + 8] ; multiply by A 
	jno .jump3774
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3774:
	imul rdi, [rsp + 0 + 16] ; multiply by E 
	jno .jump3775
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3775:
	imul rdi, [rsp + 0 + 24] ; multiply by c 
	jno .jump3776
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3776:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump3777: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'J'
	add qword [rsp + 24], 1
	; Compare J to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3777 ; If J < bound, next iter
	mov qword [rsp + 24], 0 ; J = 0
	add qword [rsp + 16], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3777 ; If I < bound, next iter
	mov qword [rsp + 16], 0 ; I = 0
	add qword [rsp + 8], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3777 ; If H < bound, next iter
	mov qword [rsp + 8], 0 ; H = 0
	add qword [rsp + 0], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3777 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3778
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3778:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3779
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3779:
	cmp rax, [rsp + 32]
	jl .jump3780
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3780:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3781
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3781:
	cmp rax, [rsp + 40]
	jl .jump3782
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3782:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3783
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3783:
	cmp rax, [rsp + 48]
	jl .jump3784
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3784:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3785
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3785:
	cmp rax, [rsp + 56]
	jl .jump3786
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3786:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 32 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 24]
		mov [rsp + 24 + 24], r10
		mov r10, [rsp + 16 + 16]
		mov [rsp + 24 + 16], r10
		mov r10, [rsp + 16 + 8]
		mov [rsp + 24 + 8], r10
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const526] ; 204
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const527] ; 79.49
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	pop rdi
	pop rsi
	call _B
	add rsp, 32
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const528] ; 991
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3787
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3787:
	cmp rax, [rsp + 24]
	jl .jump3788
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3788:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3789
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3789:
	cmp rax, [rsp + 32]
	jl .jump3790
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3790:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3791
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3791:
	cmp rax, [rsp + 40]
	jl .jump3792
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3792:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3793
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3793:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3794
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3794:
	cmp rax, [rsp + 24]
	jl .jump3795
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3795:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3796
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3796:
	cmp rax, [rsp + 32]
	jl .jump3797
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3797:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3798
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3798:
	cmp rax, [rsp + 40]
	jl .jump3799
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3799:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump3800
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump3801
.jump3800:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3802
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3802:
	; Computing total size of heap memory to allocate
	mov rdi, 56 ; sizeof u 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump3803
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3803:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump3804: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	call _z
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 56
	add rax, [rsp + 72]
	; Move body (56 bytes) to index
	; Moving 56 bytes from rsp to rax 
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 56
	; Increment 'G'
	add qword [rsp + 0], 1
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3804 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3805
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3805:
	cmp rax, [rsp + 8]
	jl .jump3806
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3806:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 56
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 56
	; Moving 56 bytes from rax to rsp 
		mov r10, [rax + 48]
		mov [rsp + 48], r10
		mov r10, [rax + 40]
		mov [rsp + 40], r10
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 48 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
.jump3801:
	pop rax
	cmp rax, 0
	je .jump3807
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump3809
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	jmp .jump3810
.jump3809:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump3810:
	jmp .jump3808
.jump3807:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump3808:
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3811
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3811:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3812
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3812:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3813
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3813:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3814
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3814:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3815
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3815:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump3816
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3816:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump3817
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3817:
	imul rdi, [rsp + 0 + 16] ; multiply by (l % E) 
	jno .jump3818
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3818:
	imul rdi, [rsp + 0 + 24] ; multiply by b 
	jno .jump3819
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3819:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump3820: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3821
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3821:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump3822: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'K'
	add qword [rsp + 0], 1
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3822 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'J'
	add qword [rsp + 24], 1
	; Compare J to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3820 ; If J < bound, next iter
	mov qword [rsp + 24], 0 ; J = 0
	add qword [rsp + 16], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3820 ; If I < bound, next iter
	mov qword [rsp + 16], 0 ; I = 0
	add qword [rsp + 8], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3820 ; If H < bound, next iter
	mov qword [rsp + 8], 0 ; H = 0
	add qword [rsp + 0], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3820 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const529] ; 522
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3823
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3823:
	cmp rax, [rsp + 32]
	jl .jump3824
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3824:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3825
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3825:
	cmp rax, [rsp + 40]
	jl .jump3826
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3826:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3827
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3827:
	cmp rax, [rsp + 48]
	jl .jump3828
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3828:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3829
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3829:
	cmp rax, [rsp + 56]
	jl .jump3830
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3830:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3831
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3833
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3833:
	; Computing bound for 'G'
	mov rax, [rel const530] ; 395
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3834
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3834:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump3835: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const531] ; 28.44
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'H'
	add qword [rsp + 8], 1
	; Compare H to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3835 ; If H < bound, next iter
	mov qword [rsp + 8], 0 ; H = 0
	add qword [rsp + 0], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3835 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump3832
.jump3831:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3836
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3836:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3837
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3837:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3838
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3838:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump3839
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3839:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump3840
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3840:
	imul rdi, [rsp + 0 + 16] ; multiply by A 
	jno .jump3841
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3841:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump3842: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3843
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3843:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3844
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3844:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3845
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3845:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3846: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const532] ; 42.98
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3846 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3846 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3846 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'I'
	add qword [rsp + 16], 1
	; Compare I to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3842 ; If I < bound, next iter
	mov qword [rsp + 16], 0 ; I = 0
	add qword [rsp + 8], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3842 ; If H < bound, next iter
	mov qword [rsp + 8], 0 ; H = 0
	add qword [rsp + 0], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3842 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3847
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3847:
	cqo
	idiv r10
	push rax
	mov rax, [rel const188] ; 201
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3848
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump3849
.jump3848:
	sub rsp, 16
	; Moving 16 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3850
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3850:
	cmp rax, [rsp + 8]
	jl .jump3851
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3851:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump3849:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3852
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3852:
	cmp rax, [rsp + 24]
	jl .jump3853
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3853:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3854
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3854:
	cmp rax, [rsp + 32]
	jl .jump3855
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3855:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3856
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3856:
	cmp rax, [rsp + 40]
	jl .jump3857
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3857:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump3832:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3858
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3860
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3860:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3861
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3861:
	; Computing bound for 'G'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3862
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3862:
	; Computing bound for 'I'
	mov rax, [rel const533] ; 363
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3863
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3863:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3864
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3864:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3865
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3865:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump3866
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3866:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump3867
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3867:
	imul rdi, [rsp + 0 + 16] ; multiply by 363 
	jno .jump3868
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3868:
	imul rdi, [rsp + 0 + 24] ; multiply by k 
	jno .jump3869
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3869:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump3870: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'J'
	add qword [rsp + 24], 1
	; Compare J to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3870 ; If J < bound, next iter
	mov qword [rsp + 24], 0 ; J = 0
	add qword [rsp + 16], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3870 ; If I < bound, next iter
	mov qword [rsp + 16], 0 ; I = 0
	add qword [rsp + 8], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3870 ; If H < bound, next iter
	mov qword [rsp + 8], 0 ; H = 0
	add qword [rsp + 0], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3870 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3871
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3871:
	cmp rax, [rsp + 32]
	jl .jump3872
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3872:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3873
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3873:
	cmp rax, [rsp + 40]
	jl .jump3874
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3874:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3875
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3875:
	cmp rax, [rsp + 48]
	jl .jump3876
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3876:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3877
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3877:
	cmp rax, [rsp + 56]
	jl .jump3878
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3878:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3879
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3879:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump3880: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'I'
	add qword [rsp + 16], 1
	; Compare I to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3880 ; If I < bound, next iter
	mov qword [rsp + 16], 0 ; I = 0
	add qword [rsp + 8], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3880 ; If H < bound, next iter
	mov qword [rsp + 8], 0 ; H = 0
	add qword [rsp + 0], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3880 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3881
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3881:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[G : (array[G : p, H : s, I : 363, J : k] E)[c, b, n, (- l)], H : l, I : l] i) 
	jno .jump3882
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3882:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump3883: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'G'
	add qword [rsp + 0], 1
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3883 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump3859
.jump3858:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump3884
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const2] ; True
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	jmp .jump3885
.jump3884:
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
.jump3885:
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump3886
	mov rax, [rel const5] ; False
	push rax
	jmp .jump3887
.jump3886:
	mov rax, [rel const5] ; False
	push rax
.jump3887:
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	call _f
	push rax
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const534] ; 434
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3888
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
.jump3888:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3889
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3889:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3890
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3890:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3891
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3891:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3892
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3892:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump3893: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'J'
	add qword [rsp + 24], 1
	; Compare J to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3893 ; If J < bound, next iter
	mov qword [rsp + 24], 0 ; J = 0
	add qword [rsp + 16], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3893 ; If I < bound, next iter
	mov qword [rsp + 16], 0 ; I = 0
	add qword [rsp + 8], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3893 ; If H < bound, next iter
	mov qword [rsp + 8], 0 ; H = 0
	add qword [rsp + 0], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3893 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3894
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3894:
	cmp rax, [rsp + 8]
	jl .jump3895
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3895:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3896
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3898
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	mov rax, [rel const201] ; 909
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3900
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3900:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 909 
	jno .jump3901
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3901:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump3902: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const535] ; 557
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'G'
	add qword [rsp + 0], 1
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3902 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump3899
.jump3898:
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const536] ; 818
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
.jump3899:
	jmp .jump3897
.jump3896:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3903
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3903:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump3904
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3904:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump3905: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const5] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'G'
	add qword [rsp + 0], 1
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3905 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3906
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3906:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3907
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3907:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
.jump3908: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'H'
	add qword [rsp + 8], 1
	; Compare H to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3908 ; If H < bound, next iter
	mov qword [rsp + 8], 0 ; H = 0
	add qword [rsp + 0], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3908 ; If G < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3909
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3909:
	cmp rax, [rsp + 8]
	jl .jump3910
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3910:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3911
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump3912
.jump3911:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump3912:
	pop rax
	cmp rax, 0
	je .jump3913
	sub rsp, 16
	; Moving 16 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	jmp .jump3914
.jump3913:
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
.jump3914:
.jump3897:
.jump3859:
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3915
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3915:
	cmp rax, [rsp + 8]
	jl .jump3916
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3916:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3917
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3917:
	cmp rax, [rsp + 24]
	jl .jump3918
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3918:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3919
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3919:
	cmp rax, [rsp + 32]
	jl .jump3920
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3920:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3921
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3921:
	cmp rax, [rsp + 40]
	jl .jump3922
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3922:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3923
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3923:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump3924: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const537] ; 50.8
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'I'
	add qword [rsp + 0], 1
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3924 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3925
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump3927
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
.jump3927:
	push rax
	pop rax
	cmp rax, 0
	jne .jump3928
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3929
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
.jump3929:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3930
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3930:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3931
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3931:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3932
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3932:
	; Computing total size of heap memory to allocate
	mov rdi, 56 ; sizeof u 
	imul rdi, [rsp + 0 + 0] ; multiply by (l % k) 
	jno .jump3933
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3933:
	imul rdi, [rsp + 0 + 8] ; multiply by (l / H) 
	jno .jump3934
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3934:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump3935: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const2] ; True
	push rax
	call _z
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 56
	add rax, [rsp + 88]
	; Move body (56 bytes) to index
	; Moving 56 bytes from rsp to rax 
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 56
	; Increment 'J'
	add qword [rsp + 8], 1
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3935 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3935 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3936
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3936:
	cmp rax, [rsp + 16]
	jl .jump3937
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3937:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3938
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3938:
	cmp rax, [rsp + 24]
	jl .jump3939
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3939:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 56
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 56
	; Moving 56 bytes from rax to rsp 
		mov r10, [rax + 48]
		mov [rsp + 48], r10
		mov r10, [rax + 40]
		mov [rsp + 40], r10
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 48 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	pop rax
.jump3928:
	push rax
	jmp .jump3926
.jump3925:
	mov rax, [rel const538] ; 95.57
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3940
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3940:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3941
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3941:
	; Computing bound for 'I'
	mov rax, [rel const308] ; 741
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3942
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3942:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump3943: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'K'
	add qword [rsp + 16], 1
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3943 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3943 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3943 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	pop rdi
	pop rsi
	call _B
	add rsp, 32
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3944
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3944:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3945
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3945:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3946
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3946:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3947
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3947:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump3948: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 216 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3949
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	jmp .jump3950
.jump3949:
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
.jump3950:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3951
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3951:
	cmp rax, [rsp + 16]
	jl .jump3952
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3952:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3953
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3953:
	cmp rax, [rsp + 24]
	jl .jump3954
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3954:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'L'
	add qword [rsp + 24], 1
	; Compare L to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3948 ; If L < bound, next iter
	mov qword [rsp + 24], 0 ; L = 0
	add qword [rsp + 16], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3948 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3948 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3948 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
.jump3926:
	pop rax
	cmp rax, 0
	je .jump3955
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3957
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3957:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump3958
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3958:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump3959: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'I'
	add qword [rsp + 0], 1
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3959 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3960
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3960:
	cmp rax, [rsp + 8]
	jl .jump3961
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3961:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3962
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3964
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3964:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3965
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3965:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3966
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3966:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump3967
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3967:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump3968
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3968:
	imul rdi, [rsp + 0 + 16] ; multiply by s 
	jno .jump3969
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3969:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump3970: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const539] ; 54.03
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 16], 1
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3970 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3970 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3970 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3971
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3971:
	cmp rax, [rsp + 8]
	jl .jump3972
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3972:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3963
.jump3962:
	sub rsp, 24
	; Moving 24 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3973
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3973:
	cmp rax, [rsp + 16]
	jl .jump3974
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3974:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3975
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3975:
	cmp rax, [rsp + 24]
	jl .jump3976
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3976:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3977
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3979
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3979:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3980
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3980:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3981
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3981:
	; Computing bound for 'I'
	sub rsp, 16
	; Moving 16 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3982
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3982:
	cmp rax, [rsp + 8]
	jl .jump3983
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3983:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3984
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3984:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by G[A] 
	jno .jump3985
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3985:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump3986
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3986:
	imul rdi, [rsp + 0 + 16] ; multiply by (- r) 
	jno .jump3987
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3987:
	imul rdi, [rsp + 0 + 24] ; multiply by c 
	jno .jump3988
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3988:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump3989: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3990
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3990:
	; Computing bound for 'N'
	mov rax, [rel const540] ; 338
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3991
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3991:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3992
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3992:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump3993
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3993:
	imul rdi, [rsp + 0 + 8] ; multiply by 338 
	jno .jump3994
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3994:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump3995
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3995:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump3996: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const541] ; 29.78
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 16], 1
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3996 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3996 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3996 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'L'
	add qword [rsp + 24], 1
	; Compare L to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3989 ; If L < bound, next iter
	mov qword [rsp + 24], 0 ; L = 0
	add qword [rsp + 16], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3989 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3989 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3989 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3997
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3997:
	cmp rax, [rsp + 32]
	jl .jump3998
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3998:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3999
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3999:
	cmp rax, [rsp + 40]
	jl .jump4000
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4000:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4001
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4001:
	cmp rax, [rsp + 48]
	jl .jump4002
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4002:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4003
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4003:
	cmp rax, [rsp + 56]
	jl .jump4004
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4004:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3978
.jump3977:
	mov rax, [rel const542] ; 78.66
	push rax
	mov rax, [rel const543] ; 62.51
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4005
	sub rsp, 32
	; Moving 32 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4007
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4007:
	cmp rax, [rsp + 24]
	jl .jump4008
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4008:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4009
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4009:
	cmp rax, [rsp + 32]
	jl .jump4010
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4010:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4011
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4011:
	cmp rax, [rsp + 40]
	jl .jump4012
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4012:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4006
.jump4005:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	xor rax, 1
	push rax
.jump4006:
	pop rax
	cmp rax, 0
	je .jump4013
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump4015
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4017
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4017:
	; Computing bound for 'J'
	mov rax, [rel const464] ; 844
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4018
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4018:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4019
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4019:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump4020
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4020:
	imul rdi, [rsp + 0 + 8] ; multiply by 844 
	jno .jump4021
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4021:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump4022
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4022:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4023: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 16], 1
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4023 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4023 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4023 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4016
.jump4015:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4024
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4024:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4025
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4025:
	; Computing bound for 'I'
	mov rax, [rel const544] ; 801
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4026
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4026:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by 801 
	jno .jump4027
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4027:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump4028
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4028:
	imul rdi, [rsp + 0 + 16] ; multiply by r 
	jno .jump4029
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4029:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4030: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const480] ; 21.18
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 16], 1
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4030 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4030 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4030 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4016:
	jmp .jump4014
.jump4013:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4031
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4031:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4032
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4032:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4033
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4033:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump4034
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4034:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump4035
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4035:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump4036
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4036:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4037: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump4038
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	jmp .jump4039
.jump4038:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
.jump4039:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 16], 1
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4037 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4037 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4037 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4014:
.jump3978:
.jump3963:
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4040
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4040:
	cmp rax, [rsp + 24]
	jl .jump4041
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4041:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4042
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4042:
	cmp rax, [rsp + 32]
	jl .jump4043
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4043:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4044
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4044:
	cmp rax, [rsp + 40]
	jl .jump4045
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4045:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3956
.jump3955:
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4046
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump4047
.jump4046:
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump4047:
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const545] ; 18.89
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const546] ; 86.69
	push rax
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4048
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4048:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4049
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4049:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by F 
	jno .jump4050
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4050:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump4051
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4051:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4052: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'J'
	add qword [rsp + 8], 1
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4052 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4052 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4053
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4053:
	cmp rax, [rsp + 16]
	jl .jump4054
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4054:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4055
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4055:
	cmp rax, [rsp + 24]
	jl .jump4056
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4056:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const547] ; 67.48
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4057
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4059
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4059:
	; Computing bound for 'J'
	mov rax, [rel const548] ; 281
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4060
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4060:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4061
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4061:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by A 
	jno .jump4062
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4062:
	imul rdi, [rsp + 0 + 8] ; multiply by 281 
	jno .jump4063
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4063:
	imul rdi, [rsp + 0 + 16] ; multiply by w 
	jno .jump4064
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4064:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4065: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 16], 1
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4065 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4065 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4065 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const58] ; 79
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4066
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4066:
	cmp rax, [rsp + 24]
	jl .jump4067
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4067:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4068
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4068:
	cmp rax, [rsp + 32]
	jl .jump4069
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4069:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4070
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4070:
	cmp rax, [rsp + 40]
	jl .jump4071
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4071:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4058
.jump4057:
	mov rax, [rel const2] ; True
	push rax
.jump4058:
	pop rax
	xor rax, 1
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'I'
	mov rax, [rel const20] ; 207
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4072
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4072:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by 207 
	jno .jump4073
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4073:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4074: ; Begin body of loop
	; Compute loop body
	call _z
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'I'
	add qword [rsp + 0], 1
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4074 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4075
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4075:
	cmp rax, [rsp + 8]
	jl .jump4076
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4076:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 48 to rsp + 48 
		mov r10, [rsp + 48 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
.jump3956:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	call _f
	push rax
	pop rax
	cmp rax, 0
	jne .jump4077
	lea rdi, [rel const500] ; 'J'
	call _fail_assertion
.jump4077:
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	add rsp, 48 ; Local variables
	pop rbp
	ret
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4078
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4080
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const549] ; 59.81
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4082
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4084
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4084:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump4085: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'K'
	add qword [rsp + 0], 1
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4085 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump4083
.jump4082:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4086
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4086:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4087
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4087:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4088
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4088:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump4089: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'M'
	add qword [rsp + 16], 1
	; Compare M to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4089 ; If M < bound, next iter
	mov qword [rsp + 16], 0 ; M = 0
	add qword [rsp + 8], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4089 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4089 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump4083:
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4090
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump4091
.jump4090:
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4092
	mov rax, [rel const550] ; 31.84
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const551] ; 2.35
	push rax
	jmp .jump4093
.jump4092:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
.jump4093:
.jump4091:
	call _f
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	push rax
	; Moving 8 bytes from rsp + 0 to rsp + 48 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	jmp .jump4081
.jump4080:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump4094
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump4095
.jump4094:
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump4095:
	; Moving 32 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 24]
		mov [rsp + 32 + 24], r10
		mov r10, [rsp + 32 + 16]
		mov [rsp + 32 + 16], r10
		mov r10, [rsp + 32 + 8]
		mov [rsp + 32 + 8], r10
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	call _f
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump4096
	call _f
	push rax
	pop rax
.jump4096:
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4097
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4097:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4098
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4098:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4099
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4099:
	; Computing bound for 'K'
	sub rsp, 8 ; Add alignment
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const552] ; 993
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const553] ; 52.82
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	pop rdi
	pop rsi
	call _B
	add rsp, 32
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4100
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4100:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by B(C, 52.82, l, 993) 
	jno .jump4101
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4101:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump4102
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4102:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump4103
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4103:
	imul rdi, [rsp + 0 + 24] ; multiply by k 
	jno .jump4104
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4104:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump4105: ; Begin body of loop
	; Compute loop body
	call _z
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'N'
	add qword [rsp + 24], 1
	; Compare N to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4105 ; If N < bound, next iter
	mov qword [rsp + 24], 0 ; N = 0
	add qword [rsp + 16], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4105 ; If M < bound, next iter
	mov qword [rsp + 16], 0 ; M = 0
	add qword [rsp + 8], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4105 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4105 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4106
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4106:
	cmp rax, [rsp + 32]
	jl .jump4107
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4107:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4108
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4108:
	cmp rax, [rsp + 40]
	jl .jump4109
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4109:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4110
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4110:
	cmp rax, [rsp + 48]
	jl .jump4111
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4111:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4112
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4112:
	cmp rax, [rsp + 56]
	jl .jump4113
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4113:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4081:
	; Moving 8 bytes from rsp + 8 to rsp + 48 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	pop rax
	cmp rax, 0
	je .jump4114
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4116
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4118
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4118:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump4119
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4119:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump4120: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'K'
	add qword [rsp + 0], 1
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4120 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const554] ; 729
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4121
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4121:
	cmp rax, [rsp + 8]
	jl .jump4122
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4122:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4117
.jump4116:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 32
	; Moving 32 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump4123
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const192] ; 65
	push rax
	mov rax, [rel const555] ; 96.21
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	pop rdi
	pop rsi
	call _B
	add rsp, 32
	push rax
	jmp .jump4124
.jump4123:
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
.jump4124:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4125
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4125:
	cmp rax, [rsp + 24]
	jl .jump4126
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4126:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4127
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4127:
	cmp rax, [rsp + 32]
	jl .jump4128
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4128:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4129
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4129:
	cmp rax, [rsp + 40]
	jl .jump4130
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4130:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4131
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump4133
	sub rsp, 24
	; Moving 24 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 216 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	jmp .jump4134
.jump4133:
	sub rsp, 24
	; Moving 24 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 216 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
.jump4134:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4135
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4135:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4136
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4136:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump4137: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'L'
	add qword [rsp + 8], 1
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4137 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4137 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4138
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4138:
	cmp rax, [rsp + 16]
	jl .jump4139
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4139:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4140
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4140:
	cmp rax, [rsp + 24]
	jl .jump4141
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4141:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	pop rdi
	pop rsi
	call _B
	add rsp, 32
	push rax
	jmp .jump4132
.jump4131:
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump4142
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump4143
.jump4142:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
.jump4143:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4144
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4144:
	; Computing bound for 'M'
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const556] ; 88.34
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	pop rdi
	pop rsi
	call _B
	add rsp, 32
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4145
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4145:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4146
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4146:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4147
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4147:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump4148: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'N'
	add qword [rsp + 24], 1
	; Compare N to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4148 ; If N < bound, next iter
	mov qword [rsp + 24], 0 ; N = 0
	add qword [rsp + 16], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4148 ; If M < bound, next iter
	mov qword [rsp + 16], 0 ; M = 0
	add qword [rsp + 8], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4148 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4148 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	pop rdi
	pop rsi
	call _B
	add rsp, 32
	push rax
.jump4132:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4149
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4149:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4150
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4150:
	; Computing bound for 'L'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4151
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4151:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4152
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4152:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4153
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4153:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump4154: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'M'
	add qword [rsp + 16], 1
	; Compare M to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4154 ; If M < bound, next iter
	mov qword [rsp + 16], 0 ; M = 0
	add qword [rsp + 8], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4154 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4154 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8 ; Add alignment
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	pop rdi
	pop rsi
	call _B
	add rsp, 32
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4155
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
.jump4155:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4156
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4156:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4157
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4157:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump4158
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4158:
imul rdi, [rsp + 0 + 8] ; multiply by (B(C, D, (l - (- w)), p) / (sum[K : p, L : d, M : i] d)) 
	jno .jump4159
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4159:
	imul rdi, [rsp + 0 + 16] ; multiply by A 
	jno .jump4160
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4160:
imul rdi, [rsp + 0 + 24] ; multiply by (if a[d, (b - F), (if f() then B(C, 96.21, 65, A) else q)] then B((if f() then t else t)[h, (sum[K : r, L : p] K)], I, n, b) else B(rgba {I, J, I, (if f() then J else I)}, (sum[K : r, L : h, M : B(C, 88.34, b, d), N : b] J), d, r)) 
	jno .jump4161
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4161:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump4162: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8 ; Add alignment
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	pop rdi
	pop rsi
	call _B
	add rsp, 32
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4163
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4163:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4164
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4164:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (- K) 
	jno .jump4165
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4165:
	imul rdi, [rsp + 0 + 8] ; multiply by B(rgba {(- I), D, J, C.r}, J, q, r) 
	jno .jump4166
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4166:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4167: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const2] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'P'
	add qword [rsp + 8], 1
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4167 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4167 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'N'
	add qword [rsp + 24], 1
	; Compare N to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4162 ; If N < bound, next iter
	mov qword [rsp + 24], 0 ; N = 0
	add qword [rsp + 16], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4162 ; If M < bound, next iter
	mov qword [rsp + 16], 0 ; M = 0
	add qword [rsp + 8], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4162 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4162 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump4117:
	jmp .jump4115
.jump4114:
	sub rsp, 40
	; Moving 40 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
.jump4115:
	jmp .jump4079
.jump4078:
	sub rsp, 40
	; Moving 40 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
.jump4079:
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const5] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump4168
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4169
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4169:
	; Computing bound for 'S'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4170
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4170:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4171
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4171:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4172
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4172:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4173
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4173:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump4174: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'T'
	add qword [rsp + 24], 1
	; Compare T to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4174 ; If T < bound, next iter
	mov qword [rsp + 24], 0 ; T = 0
	add qword [rsp + 16], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4174 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4174 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4174 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4175
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4175:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4176
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4176:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4177
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4177:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump4178: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const557] ; 90.2
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'T'
	add qword [rsp + 24], 1
	; Compare T to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4178 ; If T < bound, next iter
	mov qword [rsp + 24], 0 ; T = 0
	add qword [rsp + 16], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4178 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4178 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4178 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump4168:
	push rax
	pop rax
	cmp rax, 0
	je .jump4179
	mov rax, [rel const2] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4181
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4183
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4183:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4184
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4184:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4185
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4185:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump4186: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'S'
	add qword [rsp + 16], 1
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4186 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4186 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4186 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const2] ; True
	push rax
	call _z
	push rax
	; Moving 8 bytes from rsp + 8 to rsp + 48 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	pop rax
	cmp rax, 0
	jne .jump4187
	call _f
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump4188
	mov rax, [rel const5] ; False
	push rax
	pop rax
.jump4188:
	push rax
	pop rax
.jump4187:
	push rax
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump4182
.jump4181:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	push rax
.jump4182:
	jmp .jump4180
.jump4179:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4189
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4189:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump4190: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'Q'
	add qword [rsp + 0], 1
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4190 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4191
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4191:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4192
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4192:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4193
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4193:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump4194
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4194:
	imul rdi, [rsp + 0 + 8] ; multiply by A 
	jno .jump4195
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4195:
	imul rdi, [rsp + 0 + 16] ; multiply by M 
	jno .jump4196
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4196:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump4197: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'S'
	add qword [rsp + 16], 1
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4197 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4197 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4197 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4198
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4198:
	cmp rax, [rsp + 24]
	jl .jump4199
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4199:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4200
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4200:
	cmp rax, [rsp + 32]
	jl .jump4201
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4201:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4202
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4202:
	cmp rax, [rsp + 40]
	jl .jump4203
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4203:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4204
	call _f
	push rax
	pop rax
.jump4204:
	push rax
	pop rax
	cmp rax, 0
	je .jump4205
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	jmp .jump4206
.jump4205:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump4206:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const558] ; 70.02
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const559] ; 80.72
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const5] ; False
	push rax
	call _z
	push rax
	mov rdi, 112
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 112 bytes from rsp to rax 
		mov r10, [rsp + 104]
		mov [rax + 104], r10
		mov r10, [rsp + 96]
		mov [rax + 96], r10
		mov r10, [rsp + 88]
		mov [rax + 88], r10
		mov r10, [rsp + 80]
		mov [rax + 80], r10
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 112
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4207
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4207:
	cmp rax, [rsp + 8]
	jl .jump4208
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4208:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 56
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 56
	; Moving 56 bytes from rax to rsp 
		mov r10, [rax + 48]
		mov [rsp + 48], r10
		mov r10, [rax + 40]
		mov [rsp + 40], r10
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4180:
	; Moving 8 bytes from rsp + 8 to rsp + 48 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	pop rax
	cmp rax, 0
	je .jump4209
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	jmp .jump4210
.jump4209:
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
.jump4210:
	pop rax
	add rsp, 104 ; Local variables
	pop rbp
	ret

H:
_H:
	push rbp
	mov rbp, rsp
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const566] ; 6.87
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4278
	mov rax, [rel const567] ; 2.39
	push rax
	jmp .jump4279
.jump4278:
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
.jump4279:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump4280
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4282
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4282:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4283
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4283:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4284
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4284:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump4285
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4285:
	imul rdi, [rsp + 0 + 8] ; multiply by D 
	jno .jump4286
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4286:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump4287
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4287:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4288: ; Begin body of loop
	; Compute loop body
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 16], 1
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4288 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4288 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4288 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4281
.jump4280:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump4289
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4291
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4291:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4292
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4292:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4293
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4293:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump4294
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4294:
	imul rdi, [rsp + 0 + 8] ; multiply by F 
	jno .jump4295
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4295:
	imul rdi, [rsp + 0 + 16] ; multiply by F 
	jno .jump4296
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4296:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4297: ; Begin body of loop
	; Compute loop body
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 16], 1
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4297 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4297 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4297 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4290
.jump4289:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4298
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4298:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4299
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4299:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4300
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4300:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump4301
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4301:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump4302
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4302:
	imul rdi, [rsp + 0 + 16] ; multiply by w 
	jno .jump4303
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4303:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4304: ; Begin body of loop
	; Compute loop body
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 16], 1
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4304 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4304 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4304 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4290:
.jump4281:
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4305
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4305:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4306: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'I'
	add qword [rsp + 0], 1
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4306 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4307
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4307:
	cmp rax, [rsp + 24]
	jl .jump4308
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4308:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4309
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4309:
	cmp rax, [rsp + 32]
	jl .jump4310
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4310:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4311
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4311:
	cmp rax, [rsp + 40]
	jl .jump4312
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4312:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4313
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4313:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4314
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4314:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4315: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'J'
	add qword [rsp + 8], 1
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4315 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4315 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4316
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4316:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4317
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4317:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by A 
	jno .jump4318
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4318:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[I : h, J : w] b) 
	jno .jump4319
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4319:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4320: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump4321
	sub rsp, 32
	; Moving 32 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump4322
.jump4321:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4323
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4323:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4324
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4324:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4325
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4325:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4326
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4326:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump4327
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4327:
	imul rdi, [rsp + 0 + 8] ; multiply by J 
	jno .jump4328
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4328:
	imul rdi, [rsp + 0 + 16] ; multiply by c 
	jno .jump4329
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4329:
	imul rdi, [rsp + 0 + 24] ; multiply by p 
	jno .jump4330
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4330:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump4331: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'N'
	add qword [rsp + 24], 1
	; Compare N to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4331 ; If N < bound, next iter
	mov qword [rsp + 24], 0 ; N = 0
	add qword [rsp + 16], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4331 ; If M < bound, next iter
	mov qword [rsp + 16], 0 ; M = 0
	add qword [rsp + 8], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4331 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4331 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4332
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4332:
	cmp rax, [rsp + 32]
	jl .jump4333
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4333:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4334
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4334:
	cmp rax, [rsp + 40]
	jl .jump4335
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4335:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4336
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4336:
	cmp rax, [rsp + 48]
	jl .jump4337
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4337:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4338
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4338:
	cmp rax, [rsp + 56]
	jl .jump4339
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4339:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4322:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'J'
	add qword [rsp + 8], 1
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4320 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4320 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4340
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4340:
	cmp rax, [rsp + 16]
	jl .jump4341
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4341:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4342
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4342:
	cmp rax, [rsp + 24]
	jl .jump4343
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4343:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4344
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4344:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4345
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4345:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4346
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4346:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump4347
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4347:
	imul rdi, [rsp + 0 + 8] ; multiply by A 
	jno .jump4348
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4348:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump4349
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4349:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4350: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const568] ; 71.2
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4351
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4351:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4352
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4352:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4353: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4353 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4353 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'K'
	add qword [rsp + 16], 1
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4350 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4350 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4350 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4354
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4354:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4355: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'I'
	add qword [rsp + 0], 1
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4355 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4356
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4356:
	cmp rax, [rsp + 24]
	jl .jump4357
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4357:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4358
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4358:
	cmp rax, [rsp + 32]
	jl .jump4359
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4359:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4360
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4360:
	cmp rax, [rsp + 40]
	jl .jump4361
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4361:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4362
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	jmp .jump4363
.jump4362:
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
.jump4363:
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const569] ; 19.05
	push rax
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	pop rdi
	pop rsi
	call _B
	add rsp, 32
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4364
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4364:
	cmp rax, [rsp + 24]
	jl .jump4365
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4365:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4366
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4366:
	cmp rax, [rsp + 32]
	jl .jump4367
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4367:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4368
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4368:
	cmp rax, [rsp + 40]
	jl .jump4369
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4369:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump4370
	lea rdi, [rel const570] ; 'I'
	call _fail_assertion
.jump4370:
	sub rsp, 24
	; Moving 24 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 184 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 184 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	sub rsp, 32
	; Moving 32 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4371
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4371:
	cmp rax, [rsp + 24]
	jl .jump4372
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4372:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4373
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4373:
	cmp rax, [rsp + 32]
	jl .jump4374
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4374:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4375
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4375:
	cmp rax, [rsp + 40]
	jl .jump4376
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4376:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4377
	mov rax, [rel const571] ; 21.57
	push rax
	jmp .jump4378
.jump4377:
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
.jump4378:
	mov rax, [rel const572] ; 18.05
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4379
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4379:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump4380: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4381
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4381:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4382
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4382:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4383
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4383:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4384
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4384:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump4385: ; Begin body of loop
	; Compute loop body
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'V'
	add qword [rsp + 24], 1
	; Compare V to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4385 ; If V < bound, next iter
	mov qword [rsp + 24], 0 ; V = 0
	add qword [rsp + 16], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4385 ; If U < bound, next iter
	mov qword [rsp + 16], 0 ; U = 0
	add qword [rsp + 8], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4385 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4385 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'R'
	add qword [rsp + 0], 1
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4380 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const573] ; 28.76
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4386
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4386:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4387
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4387:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump4388
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4388:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump4389
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4389:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump4390: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'S'
	add qword [rsp + 8], 1
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4390 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4390 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4391
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4391:
	cmp rax, [rsp + 16]
	jl .jump4392
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4392:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4393
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4393:
	cmp rax, [rsp + 24]
	jl .jump4394
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4394:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const2] ; True
	push rax
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4395
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump4397
	call _z
	push rax
	jmp .jump4398
.jump4397:
	call _z
	push rax
.jump4398:
	jmp .jump4396
.jump4395:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4399
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4399:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4400
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4400:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4401
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4401:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4402
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4402:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by N 
	jno .jump4403
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4403:
	imul rdi, [rsp + 0 + 8] ; multiply by A 
	jno .jump4404
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4404:
	imul rdi, [rsp + 0 + 16] ; multiply by E 
	jno .jump4405
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4405:
	imul rdi, [rsp + 0 + 24] ; multiply by b 
	jno .jump4406
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4406:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump4407: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'U'
	add qword [rsp + 24], 1
	; Compare U to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4407 ; If U < bound, next iter
	mov qword [rsp + 24], 0 ; U = 0
	add qword [rsp + 16], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4407 ; If T < bound, next iter
	mov qword [rsp + 16], 0 ; T = 0
	add qword [rsp + 8], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4407 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4407 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4408
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4408:
	cmp rax, [rsp + 32]
	jl .jump4409
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4409:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4410
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4410:
	cmp rax, [rsp + 40]
	jl .jump4411
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4411:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4412
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4412:
	cmp rax, [rsp + 48]
	jl .jump4413
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4413:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4414
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4414:
	cmp rax, [rsp + 56]
	jl .jump4415
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4415:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4396:
	; Moving 8 bytes from rsp + 48 to rsp + 48 
		mov r10, [rsp + 48 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	sub rsp, 8 ; Add alignment
	mov rax, [rel const574] ; 1.45
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4416
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4416:
	; Computing bound for 'R'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4417
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4417:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4418
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4418:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4419
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4419:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump4420: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'T'
	add qword [rsp + 16], 1
	; Compare T to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4420 ; If T < bound, next iter
	mov qword [rsp + 16], 0 ; T = 0
	add qword [rsp + 8], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4420 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4420 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4421
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4421:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[R : i, S : b, T : p] p) 
	jno .jump4422
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4422:
	imul rdi, [rsp + 0 + 8] ; multiply by K 
	jno .jump4423
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4423:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump4424: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const575] ; 71.83
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'S'
	add qword [rsp + 8], 1
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4424 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4424 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4425
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4425:
	cmp rax, [rsp + 16]
	jl .jump4426
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4426:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4427
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4427:
	cmp rax, [rsp + 24]
	jl .jump4428
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4428:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump4429
	mov rax, [rel const576] ; 58.56
	push rax
	jmp .jump4430
.jump4429:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4431
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4431:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump4432: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const577] ; 87.02
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'R'
	add qword [rsp + 0], 1
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4432 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump4430:
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const578] ; 49.09
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4433
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4433:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4434
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4434:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4435
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4435:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4436
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4436:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof float[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by O 
	jno .jump4437
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4437:
	imul rdi, [rsp + 0 + 8] ; multiply by (- r) 
	jno .jump4438
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4438:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump4439
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4439:
	imul rdi, [rsp + 0 + 24] ; multiply by O 
	jno .jump4440
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4440:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump4441: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4442
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4444
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4444:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4445
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4445:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by Q 
	jno .jump4446
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4446:
	imul rdi, [rsp + 0 + 8] ; multiply by R 
	jno .jump4447
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4447:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump4448: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const579] ; 15.86
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'W'
	add qword [rsp + 8], 1
	; Compare W to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4448 ; If W < bound, next iter
	mov qword [rsp + 8], 0 ; W = 0
	add qword [rsp + 0], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4448 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump4443
.jump4442:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4449
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4449:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4450
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4450:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump4451
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4451:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump4452
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4452:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump4453: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const580] ; 63.1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'W'
	add qword [rsp + 8], 1
	; Compare W to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4453 ; If W < bound, next iter
	mov qword [rsp + 8], 0 ; W = 0
	add qword [rsp + 0], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4453 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump4443:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'U'
	add qword [rsp + 24], 1
	; Compare U to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4441 ; If U < bound, next iter
	mov qword [rsp + 24], 0 ; U = 0
	add qword [rsp + 16], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4441 ; If T < bound, next iter
	mov qword [rsp + 16], 0 ; T = 0
	add qword [rsp + 8], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4441 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4441 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4454
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4454:
	cmp rax, [rsp + 32]
	jl .jump4455
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4455:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4456
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4456:
	cmp rax, [rsp + 40]
	jl .jump4457
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4457:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4458
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4458:
	cmp rax, [rsp + 48]
	jl .jump4459
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4459:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4460
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4460:
	cmp rax, [rsp + 56]
	jl .jump4461
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4461:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4462
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4462:
	cmp rax, [rsp + 16]
	jl .jump4463
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4463:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4464
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4464:
	cmp rax, [rsp + 24]
	jl .jump4465
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4465:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'R'
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4466
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	jmp .jump4467
.jump4466:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump4468
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	jmp .jump4469
.jump4468:
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
.jump4469:
.jump4467:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4470
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4470:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump4471: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4472
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4472:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4473
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4473:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4474
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4474:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump4475: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4476
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4476:
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4477
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4477:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4478
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4478:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump4479
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4479:
	imul rdi, [rsp + 0 + 8] ; multiply by E 
	jno .jump4480
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4480:
	imul rdi, [rsp + 0 + 16] ; multiply by A 
	jno .jump4481
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4481:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'X' to 0
	mov rax, 0
	push rax
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump4482: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	mov rax, [rel const581] ; 22.92
	push rax
	mov rax, [rel const582] ; 38.34
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'X'
	add qword [rsp + 16], 1
	; Compare X to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4482 ; If X < bound, next iter
	mov qword [rsp + 16], 0 ; X = 0
	add qword [rsp + 8], 1 ; W++
	; Compare W to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4482 ; If W < bound, next iter
	mov qword [rsp + 8], 0 ; W = 0
	add qword [rsp + 0], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4482 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4483
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	jmp .jump4484
.jump4483:
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
.jump4484:
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4485
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4485:
	cmp rax, [rsp + 24]
	jl .jump4486
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4486:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4487
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4487:
	cmp rax, [rsp + 32]
	jl .jump4488
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4488:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4489
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4489:
	cmp rax, [rsp + 40]
	jl .jump4490
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4490:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'U'
	add qword [rsp + 16], 1
	; Compare U to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4475 ; If U < bound, next iter
	mov qword [rsp + 16], 0 ; U = 0
	add qword [rsp + 8], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4475 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4475 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'R'
	add qword [rsp + 0], 1
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4471 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	pop rdi
	pop rsi
	call _B
	add rsp, 32
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	sub rsp, 16
	; Moving 16 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const583] ; 25.92
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 104 ; Local variables
	pop rbp
	ret

J:
_J:
	push rbp
	mov rbp, rsp
	push rdi
	sub rsp, 32
	; Moving 32 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 216 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -64 to rsp 
		mov r10, [rbp - -64 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4534
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4534:
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4535
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4535:
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4536
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4536:
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4537
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4537:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump4538
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4538:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump4539
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4539:
	imul rdi, [rsp + 0 + 16] ; multiply by w 
	jno .jump4540
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4540:
	imul rdi, [rsp + 0 + 24] ; multiply by S 
	jno .jump4541
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4541:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
	; Initialize 'W' to 0
	mov rax, 0
	push rax
.jump4542: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'Z'
	add qword [rsp + 24], 1
	; Compare Z to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4542 ; If Z < bound, next iter
	mov qword [rsp + 24], 0 ; Z = 0
	add qword [rsp + 16], 1 ; Y++
	; Compare Y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4542 ; If Y < bound, next iter
	mov qword [rsp + 16], 0 ; Y = 0
	add qword [rsp + 8], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4542 ; If X < bound, next iter
	mov qword [rsp + 8], 0 ; X = 0
	add qword [rsp + 0], 1 ; W++
	; Compare W to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4542 ; If W < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4543
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4543:
	cmp rax, [rsp + 32]
	jl .jump4544
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4544:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4545
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4545:
	cmp rax, [rsp + 40]
	jl .jump4546
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4546:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4547
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4547:
	cmp rax, [rsp + 48]
	jl .jump4548
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4548:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4549
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4549:
	cmp rax, [rsp + 56]
	jl .jump4550
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4550:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4551
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump4552
.jump4551:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4553
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4553:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump4554
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4554:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'W' to 0
	mov rax, 0
	push rax
.jump4555: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'W'
	add qword [rsp + 0], 1
	; Compare W to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4555 ; If W < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4556
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4556:
	cmp rax, [rsp + 8]
	jl .jump4557
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4557:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4552:
	; Moving 32 bytes from rsp + 0 to rsp + 32 
		mov r10, [rsp + 0 + 24]
		mov [rsp + 32 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 32 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 32 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump4558
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'X'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4559
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4559:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'W' to 0
	mov rax, 0
	push rax
.jump4560: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'W'
	add qword [rsp + 0], 1
	; Compare W to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4560 ; If W < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4561
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4561:
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4562
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4562:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'X' to 0
	mov rax, 0
	push rax
	; Initialize 'W' to 0
	mov rax, 0
	push rax
.jump4563: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'X'
	add qword [rsp + 8], 1
	; Compare X to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4563 ; If X < bound, next iter
	mov qword [rsp + 8], 0 ; X = 0
	add qword [rsp + 0], 1 ; W++
	; Compare W to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4563 ; If W < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
.jump4558:
	push rax
	pop rax
	cmp rax, 0
	je .jump4564
	sub rsp, 24
	; Moving 24 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 216 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4566
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4566:
	cmp rax, [rsp + 16]
	jl .jump4567
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4567:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4568
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4568:
	cmp rax, [rsp + 24]
	jl .jump4569
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4569:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump4570
	sub rsp, 8
	; Moving 8 bytes from rbp - -64 to rsp 
		mov r10, [rbp - -64 + 0]
		mov [rsp + 0], r10
	jmp .jump4571
.jump4570:
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
.jump4571:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4572
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4572:
	; Computing bound for 'X'
	mov rax, [rel const592] ; 506
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4573
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4573:
	; Computing bound for 'W'
	mov rax, [rel const593] ; 701
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4574
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4574:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
	; Initialize 'W' to 0
	mov rax, 0
	push rax
.jump4575: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'Y'
	add qword [rsp + 16], 1
	; Compare Y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4575 ; If Y < bound, next iter
	mov qword [rsp + 16], 0 ; Y = 0
	add qword [rsp + 8], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4575 ; If X < bound, next iter
	mov qword [rsp + 8], 0 ; X = 0
	add qword [rsp + 0], 1 ; W++
	; Compare W to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4575 ; If W < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4576
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4576:
	cmp rax, [rsp + 16]
	jl .jump4577
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4577:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4578
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4578:
	cmp rax, [rsp + 24]
	jl .jump4579
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4579:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 32 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 24]
		mov [rsp + 32 + 24], r10
		mov r10, [rsp + 32 + 16]
		mov [rsp + 32 + 16], r10
		mov r10, [rsp + 32 + 8]
		mov [rsp + 32 + 8], r10
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	jmp .jump4565
.jump4564:
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump4565:
	; Moving 32 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 24]
		mov [rsp + 32 + 24], r10
		mov r10, [rsp + 32 + 16]
		mov [rsp + 32 + 16], r10
		mov r10, [rsp + 32 + 8]
		mov [rsp + 32 + 8], r10
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 216 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 32
	; Moving 32 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 184 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 184 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4580
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4580:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4581
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4581:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4582
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4582:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4583
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4583:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump4584: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'ah'
	add qword [rsp + 24], 1
	; Compare ah to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4584 ; If ah < bound, next iter
	mov qword [rsp + 24], 0 ; ah = 0
	add qword [rsp + 16], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4584 ; If ag < bound, next iter
	mov qword [rsp + 16], 0 ; ag = 0
	add qword [rsp + 8], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4584 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4584 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4585
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4585:
	cmp rax, [rsp + 24]
	jl .jump4586
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4586:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4587
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4587:
	cmp rax, [rsp + 32]
	jl .jump4588
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4588:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4589
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4589:
	cmp rax, [rsp + 40]
	jl .jump4590
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4590:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4591
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4591:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4592
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4592:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4593
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4593:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4594
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4594:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4595
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4595:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by Q 
	jno .jump4596
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4596:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump4597
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4597:
	imul rdi, [rsp + 0 + 16] ; multiply by w 
	jno .jump4598
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4598:
imul rdi, [rsp + 0 + 24] ; multiply by (T / o[r, (sum[ae : T, af : ad, ag : q, ah : Y] b), M]) 
	jno .jump4599
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4599:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump4600: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump4601
	mov rax, [rel const2] ; True
	push rax
	pop rax
.jump4601:
	push rax
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4602
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump4603
.jump4602:
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	push rax
.jump4603:
	; Moving 8 bytes from rsp + 8 to rsp + 48 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	pop rax
	cmp rax, 0
	je .jump4604
	mov rax, [rel const5] ; False
	push rax
	pop rax
.jump4604:
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ah'
	add qword [rsp + 24], 1
	; Compare ah to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4600 ; If ah < bound, next iter
	mov qword [rsp + 24], 0 ; ah = 0
	add qword [rsp + 16], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4600 ; If ag < bound, next iter
	mov qword [rsp + 16], 0 ; ag = 0
	add qword [rsp + 8], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4600 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4600 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4605
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4605:
	cmp rax, [rsp + 32]
	jl .jump4606
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4606:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4607
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4607:
	cmp rax, [rsp + 40]
	jl .jump4608
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4608:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4609
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4609:
	cmp rax, [rsp + 48]
	jl .jump4610
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4610:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4611
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4611:
	cmp rax, [rsp + 56]
	jl .jump4612
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4612:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4613
	call _f
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump4614
.jump4613:
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
.jump4614:
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	mov rax, [rel const2] ; True
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4615
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4615:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump4616: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'ae'
	add qword [rsp + 0], 1
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4616 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const594] ; 49.81
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const595] ; 94.13
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4617
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4617:
	cmp rax, [rsp + 8]
	jl .jump4618
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4618:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump4619
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4620
	sub rsp, 24
	; Moving 24 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	pop rdi
	pop rsi
	call _B
	add rsp, 32
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4622
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4622:
	cmp rax, [rsp + 16]
	jl .jump4623
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4623:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4624
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4624:
	cmp rax, [rsp + 24]
	jl .jump4625
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4625:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4626
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4628
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4628:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4629
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4629:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4630
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4630:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4631
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4631:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by ab 
	jno .jump4632
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4632:
	imul rdi, [rsp + 0 + 8] ; multiply by Q 
	jno .jump4633
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4633:
	imul rdi, [rsp + 0 + 16] ; multiply by V 
	jno .jump4634
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4634:
	imul rdi, [rsp + 0 + 24] ; multiply by ac 
	jno .jump4635
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4635:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump4636: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ah'
	add qword [rsp + 24], 1
	; Compare ah to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4636 ; If ah < bound, next iter
	mov qword [rsp + 24], 0 ; ah = 0
	add qword [rsp + 16], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4636 ; If ag < bound, next iter
	mov qword [rsp + 16], 0 ; ag = 0
	add qword [rsp + 8], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4636 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4636 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump4627
.jump4626:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4637
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4637:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4638
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4638:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4639
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4639:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4640
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4640:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump4641
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4641:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump4642
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4642:
	imul rdi, [rsp + 0 + 16] ; multiply by Q 
	jno .jump4643
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4643:
	imul rdi, [rsp + 0 + 24] ; multiply by n 
	jno .jump4644
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4644:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump4645: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const596] ; 5.64
	push rax
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ah'
	add qword [rsp + 24], 1
	; Compare ah to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4645 ; If ah < bound, next iter
	mov qword [rsp + 24], 0 ; ah = 0
	add qword [rsp + 16], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4645 ; If ag < bound, next iter
	mov qword [rsp + 16], 0 ; ag = 0
	add qword [rsp + 8], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4645 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4645 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump4627:
	jmp .jump4621
.jump4620:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4646
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4646:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const597] ; 96.87
	push rax
	mov rax, [rel const598] ; 77.52
	push rax
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const599] ; 90.6
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	pop rdi
	pop rsi
	call _B
	add rsp, 32
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4647
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4647:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4648
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4648:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4649
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4649:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump4650
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4650:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump4651
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4651:
	imul rdi, [rsp + 0 + 16] ; multiply by B(rgba {H(), 77.52, 96.87, W}, 90.6, G, (Y - ab)) 
	jno .jump4652
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4652:
	imul rdi, [rsp + 0 + 24] ; multiply by w 
	jno .jump4653
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4653:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump4654: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump4655
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
.jump4655:
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ah'
	add qword [rsp + 24], 1
	; Compare ah to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4654 ; If ah < bound, next iter
	mov qword [rsp + 24], 0 ; ah = 0
	add qword [rsp + 16], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4654 ; If ag < bound, next iter
	mov qword [rsp + 16], 0 ; ag = 0
	add qword [rsp + 8], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4654 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4654 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump4621:
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -64 to rsp 
		mov r10, [rbp - -64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4656
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4656:
	cmp rax, [rsp + 32]
	jl .jump4657
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4657:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4658
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4658:
	cmp rax, [rsp + 40]
	jl .jump4659
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4659:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4660
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4660:
	cmp rax, [rsp + 48]
	jl .jump4661
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4661:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4662
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4662:
	cmp rax, [rsp + 56]
	jl .jump4663
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4663:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
.jump4619:
	push rax
	pop rax
	cmp rax, 0
	je .jump4664
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4666
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4666:
	; Computing bound for 'ag'
	mov rax, [rel const600] ; 500
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4667
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4667:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4668
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4668:
	; Computing bound for 'ae'
	sub rsp, 24
	; Moving 24 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4669
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4669:
	cmp rax, [rsp + 16]
	jl .jump4670
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4670:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4671
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4671:
	cmp rax, [rsp + 24]
	jl .jump4672
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4672:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4673
	sub rsp, 24
	; Moving 24 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	jmp .jump4674
.jump4673:
	sub rsp, 24
	; Moving 24 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 216 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
.jump4674:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4675
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4675:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4676
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4676:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump4677: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'af'
	add qword [rsp + 8], 1
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4677 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4677 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4678
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4678:
	cmp rax, [rsp + 16]
	jl .jump4679
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4679:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4680
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4680:
	cmp rax, [rsp + 24]
	jl .jump4681
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4681:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4682
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4682:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump4683: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4684
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4684:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4685
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4685:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4686
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4686:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
.jump4687: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'ah'
	add qword [rsp + 16], 1
	; Compare ah to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4687 ; If ah < bound, next iter
	mov qword [rsp + 16], 0 ; ah = 0
	add qword [rsp + 8], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4687 ; If ag < bound, next iter
	mov qword [rsp + 8], 0 ; ag = 0
	add qword [rsp + 0], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4687 ; If af < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'ae'
	add qword [rsp + 0], 1
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4683 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	pop rdi
	pop rsi
	call _B
	add rsp, 32
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4688
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4688:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by B((if g[D, F] then X else t)[Y, (sum[ae : c, af : Z] G)], (sum[ae : E] (sum[af : T, ag : i, ah : Y] W)), w, D) 
	jno .jump4689
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4689:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump4690
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4690:
	imul rdi, [rsp + 0 + 16] ; multiply by 500 
	jno .jump4691
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4691:
	imul rdi, [rsp + 0 + 24] ; multiply by N 
	jno .jump4692
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4692:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump4693: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ak'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4694
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4694:
	; Computing bound for 'aj'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4695
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4695:
	; Computing bound for 'ai'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4696
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4696:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by af 
	jno .jump4697
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4697:
	imul rdi, [rsp + 0 + 8] ; multiply by ad 
	jno .jump4698
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4698:
	imul rdi, [rsp + 0 + 16] ; multiply by A 
	jno .jump4699
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4699:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ak' to 0
	mov rax, 0
	push rax
	; Initialize 'aj' to 0
	mov rax, 0
	push rax
	; Initialize 'ai' to 0
	mov rax, 0
	push rax
.jump4700: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ak'
	add qword [rsp + 16], 1
	; Compare ak to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4700 ; If ak < bound, next iter
	mov qword [rsp + 16], 0 ; ak = 0
	add qword [rsp + 8], 1 ; aj++
	; Compare aj to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4700 ; If aj < bound, next iter
	mov qword [rsp + 8], 0 ; aj = 0
	add qword [rsp + 0], 1 ; ai++
	; Compare ai to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4700 ; If ai < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ak'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4701
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4701:
	; Computing bound for 'aj'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4702
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4702:
	; Computing bound for 'ai'
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4703
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4703:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ak' to 0
	mov rax, 0
	push rax
	; Initialize 'aj' to 0
	mov rax, 0
	push rax
	; Initialize 'ai' to 0
	mov rax, 0
	push rax
.jump4704: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'ak'
	add qword [rsp + 16], 1
	; Compare ak to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4704 ; If ak < bound, next iter
	mov qword [rsp + 16], 0 ; ak = 0
	add qword [rsp + 8], 1 ; aj++
	; Compare aj to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4704 ; If aj < bound, next iter
	mov qword [rsp + 8], 0 ; aj = 0
	add qword [rsp + 0], 1 ; ai++
	; Compare ai to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4704 ; If ai < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4705
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump4706
.jump4705:
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
.jump4706:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ai'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4707
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4707:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'ai' to 0
	mov rax, 0
	push rax
.jump4708: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'ai'
	add qword [rsp + 0], 1
	; Compare ai to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4708 ; If ai < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	lea rdi, [rsp + 72]
	call _J
	add rsp, 32
	add rsp, 32
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4709
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4709:
	cmp rax, [rsp + 8]
	jl .jump4710
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4710:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ah'
	add qword [rsp + 24], 1
	; Compare ah to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4693 ; If ah < bound, next iter
	mov qword [rsp + 24], 0 ; ah = 0
	add qword [rsp + 16], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4693 ; If ag < bound, next iter
	mov qword [rsp + 16], 0 ; ag = 0
	add qword [rsp + 8], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4693 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4693 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4711
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4711:
	cmp rax, [rsp + 32]
	jl .jump4712
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4712:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4713
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4713:
	cmp rax, [rsp + 40]
	jl .jump4714
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4714:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4715
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4715:
	cmp rax, [rsp + 48]
	jl .jump4716
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4716:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4717
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4717:
	cmp rax, [rsp + 56]
	jl .jump4718
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4718:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4665
.jump4664:
	mov rax, [rel const601] ; 54.64
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump4719
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4720
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4720:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4721
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4721:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4722
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4722:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4723
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4723:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump4724: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'ah'
	add qword [rsp + 24], 1
	; Compare ah to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4724 ; If ah < bound, next iter
	mov qword [rsp + 24], 0 ; ah = 0
	add qword [rsp + 16], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4724 ; If ag < bound, next iter
	mov qword [rsp + 16], 0 ; ag = 0
	add qword [rsp + 8], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4724 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4724 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4725
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4725:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4726
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4726:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4727
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump4728
.jump4727:
	sub rsp, 8
	; Moving 8 bytes from rbp - -64 to rsp 
		mov r10, [rbp - -64 + 0]
		mov [rsp + 0], r10
.jump4728:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4729
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4729:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4730
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4730:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump4731: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const602] ; 56.2
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump4732
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump4733
.jump4732:
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump4733:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'ah'
	add qword [rsp + 24], 1
	; Compare ah to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4731 ; If ah < bound, next iter
	mov qword [rsp + 24], 0 ; ah = 0
	add qword [rsp + 16], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4731 ; If ag < bound, next iter
	mov qword [rsp + 16], 0 ; ag = 0
	add qword [rsp + 8], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4731 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4731 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
.jump4719:
	push rax
.jump4665:
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 160 ; Local variables
	pop rbp
	ret

X:
_X:
	push rbp
	mov rbp, rsp
	push rdi
	push rsi
	sub rsp, 16
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5112
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5112:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5113
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5113:
	; Computing bound for 'ad'
	sub rsp, 8
	; Moving 8 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5114
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5114:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (n + ac) 
	jno .jump5115
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5115:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump5116
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5116:
	imul rdi, [rsp + 0 + 16] ; multiply by E 
	jno .jump5117
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5117:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
	; Initialize 'ad' to 0
	mov rax, 0
	push rax
.jump5118: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 424 to rsp 
		mov r10, [r12 - 424 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'af'
	add qword [rsp + 16], 1
	; Compare af to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5118 ; If af < bound, next iter
	mov qword [rsp + 16], 0 ; af = 0
	add qword [rsp + 8], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5118 ; If ae < bound, next iter
	mov qword [rsp + 8], 0 ; ae = 0
	add qword [rsp + 0], 1 ; ad++
	; Compare ad to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5118 ; If ad < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 32
	; Moving 32 bytes from r12 - 392 to rsp 
		mov r10, [r12 - 392 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 392 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 392 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 392 + 0]
		mov [rsp + 0], r10
	lea rdi, [rsp + 64]
	call _J
	add rsp, 32
	add rsp, 32
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ai'
	sub rsp, 8
	; Moving 8 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5119
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5119:
	; Computing bound for 'ah'
	sub rsp, 32
	; Moving 32 bytes from r12 - 392 to rsp 
		mov r10, [r12 - 392 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 392 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 392 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 392 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 344 to rsp 
		mov r10, [r12 - 344 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5120
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5120:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5121
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5121:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5122
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5122:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
.jump5123: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ak'
	sub rsp, 8
	; Moving 8 bytes from r12 - 360 to rsp 
		mov r10, [r12 - 360 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5124
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5124:
	; Computing bound for 'aj'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5125
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5125:
	; Computing bound for 'ai'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5126
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5126:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by F 
	jno .jump5127
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5127:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump5128
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5128:
	imul rdi, [rsp + 0 + 16] ; multiply by L 
	jno .jump5129
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5129:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ak' to 0
	mov rax, 0
	push rax
	; Initialize 'aj' to 0
	mov rax, 0
	push rax
	; Initialize 'ai' to 0
	mov rax, 0
	push rax
.jump5130: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'an'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5131
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5131:
	; Computing bound for 'am'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5132
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5132:
	; Computing bound for 'al'
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5133
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5133:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'an' to 0
	mov rax, 0
	push rax
	; Initialize 'am' to 0
	mov rax, 0
	push rax
	; Initialize 'al' to 0
	mov rax, 0
	push rax
.jump5134: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const630] ; 58.71
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'an'
	add qword [rsp + 16], 1
	; Compare an to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5134 ; If an < bound, next iter
	mov qword [rsp + 16], 0 ; an = 0
	add qword [rsp + 8], 1 ; am++
	; Compare am to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5134 ; If am < bound, next iter
	mov qword [rsp + 8], 0 ; am = 0
	add qword [rsp + 0], 1 ; al++
	; Compare al to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5134 ; If al < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ak'
	add qword [rsp + 16], 1
	; Compare ak to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5130 ; If ak < bound, next iter
	mov qword [rsp + 16], 0 ; ak = 0
	add qword [rsp + 8], 1 ; aj++
	; Compare aj to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5130 ; If aj < bound, next iter
	mov qword [rsp + 8], 0 ; aj = 0
	add qword [rsp + 0], 1 ; ai++
	; Compare ai to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5130 ; If ai < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 440 to rsp 
		mov r10, [r12 - 440 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 464 to rsp 
		mov r10, [r12 - 464 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5135
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5135:
	cmp rax, [rsp + 24]
	jl .jump5136
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5136:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5137
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5137:
	cmp rax, [rsp + 32]
	jl .jump5138
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5138:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5139
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5139:
	cmp rax, [rsp + 40]
	jl .jump5140
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5140:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const631] ; 16.14
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'ah'
	add qword [rsp + 16], 1
	; Compare ah to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5123 ; If ah < bound, next iter
	mov qword [rsp + 16], 0 ; ah = 0
	add qword [rsp + 8], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5123 ; If ag < bound, next iter
	mov qword [rsp + 8], 0 ; ag = 0
	add qword [rsp + 0], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5123 ; If af < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	pop rdi
	pop rsi
	call _B
	add rsp, 32
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5141
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5141:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 416 to rsp 
		mov r10, [r12 - 416 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5142
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5142:
	; Computing bound for 'af'
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5143
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump5145
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5147
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5147:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 344 to rsp 
		mov r10, [r12 - 344 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5148
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5148:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5149
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5149:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump5150
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5150:
	imul rdi, [rsp + 0 + 8] ; multiply by (- N) 
	jno .jump5151
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5151:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump5152
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5152:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
.jump5153: ; Begin body of loop
	; Compute loop body
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 32 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 24]
		mov [rsp + 24 + 24], r10
		mov r10, [rsp + 16 + 16]
		mov [rsp + 24 + 16], r10
		mov r10, [rsp + 16 + 8]
		mov [rsp + 24 + 8], r10
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'ah'
	add qword [rsp + 16], 1
	; Compare ah to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5153 ; If ah < bound, next iter
	mov qword [rsp + 16], 0 ; ah = 0
	add qword [rsp + 8], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5153 ; If ag < bound, next iter
	mov qword [rsp + 8], 0 ; ag = 0
	add qword [rsp + 0], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5153 ; If af < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump5146
.jump5145:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5154
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5154:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 360 to rsp 
		mov r10, [r12 - 360 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5155
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5155:
	; Computing bound for 'af'
	mov rax, [rel const592] ; 506
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5156
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5156:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by (b * 506) 
	jno .jump5157
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5157:
	imul rdi, [rsp + 0 + 8] ; multiply by L 
	jno .jump5158
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5158:
	imul rdi, [rsp + 0 + 16] ; multiply by l 
	jno .jump5159
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5159:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
.jump5160: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 392 to rsp 
		mov r10, [r12 - 392 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 392 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 392 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 392 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'ah'
	add qword [rsp + 16], 1
	; Compare ah to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5160 ; If ah < bound, next iter
	mov qword [rsp + 16], 0 ; ah = 0
	add qword [rsp + 8], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5160 ; If ag < bound, next iter
	mov qword [rsp + 8], 0 ; ag = 0
	add qword [rsp + 0], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5160 ; If af < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump5146:
	jmp .jump5144
.jump5143:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5161
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5161:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const632] ; 356
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5162
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
.jump5162:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5163
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5163:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 456 to rsp 
		mov r10, [r12 - 456 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5164
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5164:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by W 
	jno .jump5165
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5165:
	imul rdi, [rsp + 0 + 8] ; multiply by (356 % r) 
	jno .jump5166
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5166:
	imul rdi, [rsp + 0 + 16] ; multiply by G 
	jno .jump5167
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5167:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
.jump5168: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 392 to rsp 
		mov r10, [r12 - 392 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 392 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 392 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 392 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'ah'
	add qword [rsp + 16], 1
	; Compare ah to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5168 ; If ah < bound, next iter
	mov qword [rsp + 16], 0 ; ah = 0
	add qword [rsp + 8], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5168 ; If ag < bound, next iter
	mov qword [rsp + 8], 0 ; ag = 0
	add qword [rsp + 0], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5168 ; If af < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump5144:
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 464 to rsp 
		mov r10, [r12 - 464 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5169
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5169:
	cmp rax, [rsp + 24]
	jl .jump5170
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5170:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5171
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5171:
	cmp rax, [rsp + 32]
	jl .jump5172
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5172:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5173
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5173:
	cmp rax, [rsp + 40]
	jl .jump5174
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5174:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 440 to rsp 
		mov r10, [r12 - 440 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5175
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5175:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'af' to 0
	mov rax, 0
	push rax
.jump5176: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const633] ; 99.54
	push rax
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const634] ; 97.29
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5177
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5177:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 416 to rsp 
		mov r10, [r12 - 416 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5178
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5178:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
.jump5179: ; Begin body of loop
	; Compute loop body
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 48 to rsp + 48 
		mov r10, [rsp + 48 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'ah'
	add qword [rsp + 8], 1
	; Compare ah to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5179 ; If ah < bound, next iter
	mov qword [rsp + 8], 0 ; ah = 0
	add qword [rsp + 0], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5179 ; If ag < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const635] ; 21.21
	push rax
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'af'
	add qword [rsp + 0], 1
	; Compare af to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5176 ; If af < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	pop rdi
	pop rsi
	call _B
	add rsp, 32
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5180
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5180:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by B((if true then (if f() then (array[af : i, ag : (- N), ah : m] Y.c) else (array[af : (b * 506), ag : L, ah : l] O)) else (array[af : W, ag : (356 % r), ah : G] O))[V, h, h], (sum[af : Q] rgba {21.21, (sum[ag : T, ah : q] Y.d), 97.29, (- (H() + 99.54))}.r), ae, E) 
	jno .jump5181
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5181:
	imul rdi, [rsp + 0 + 8] ; multiply by T 
	jno .jump5182
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5182:
imul rdi, [rsp + 0 + 16] ; multiply by B(O, (sum[af : s, ag : s, ah : m] (16.14 / (array[ai : F, aj : w, ak : L] (sum[al : D, am : i, an : w] 58.71))[V, Q, i])), N, ab) 
	jno .jump5183
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5183:
	imul rdi, [rsp + 0 + 24] ; multiply by ab 
	jno .jump5184
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5184:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ai' to 0
	mov rax, 0
	push rax
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
.jump5185: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const2] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ai'
	add qword [rsp + 24], 1
	; Compare ai to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5185 ; If ai < bound, next iter
	mov qword [rsp + 24], 0 ; ai = 0
	add qword [rsp + 16], 1 ; ah++
	; Compare ah to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5185 ; If ah < bound, next iter
	mov qword [rsp + 16], 0 ; ah = 0
	add qword [rsp + 8], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5185 ; If ag < bound, next iter
	mov qword [rsp + 8], 0 ; ag = 0
	add qword [rsp + 0], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5185 ; If af < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 360 to rsp 
		mov r10, [r12 - 360 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const636] ; 864
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5186
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5186:
	cmp rax, [rsp + 32]
	jl .jump5187
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5187:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5188
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5188:
	cmp rax, [rsp + 40]
	jl .jump5189
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5189:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5190
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5190:
	cmp rax, [rsp + 48]
	jl .jump5191
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5191:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5192
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5192:
	cmp rax, [rsp + 56]
	jl .jump5193
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5193:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump5194
	lea rdi, [rel const637] ; 'af'
	call _fail_assertion
.jump5194:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5195
	sub rsp, 32
	; Moving 32 bytes from r12 - 392 to rsp 
		mov r10, [r12 - 392 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 392 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 392 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 392 + 0]
		mov [rsp + 0], r10
	jmp .jump5196
.jump5195:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5197
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5197:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5198
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5198:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump5199
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5199:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump5200
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5200:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
.jump5201: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 392 to rsp 
		mov r10, [r12 - 392 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 392 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 392 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 392 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'ag'
	add qword [rsp + 8], 1
	; Compare ag to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5201 ; If ag < bound, next iter
	mov qword [rsp + 8], 0 ; ag = 0
	add qword [rsp + 0], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5201 ; If af < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5202
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5202:
	cmp rax, [rsp + 16]
	jl .jump5203
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5203:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5204
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5204:
	cmp rax, [rsp + 24]
	jl .jump5205
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5205:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5196:
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ai'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ai'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5206
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5206:
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5207
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5207:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 424 to rsp 
		mov r10, [r12 - 424 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5208
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5208:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5209
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5209:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump5210
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5210:
	imul rdi, [rsp + 0 + 8] ; multiply by S 
	jno .jump5211
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5211:
	imul rdi, [rsp + 0 + 16] ; multiply by G 
	jno .jump5212
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5212:
	imul rdi, [rsp + 0 + 24] ; multiply by c 
	jno .jump5213
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5213:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ai' to 0
	mov rax, 0
	push rax
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
.jump5214: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 392 to rsp 
		mov r10, [r12 - 392 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 392 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 392 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 392 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'ai'
	add qword [rsp + 24], 1
	; Compare ai to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5214 ; If ai < bound, next iter
	mov qword [rsp + 24], 0 ; ai = 0
	add qword [rsp + 16], 1 ; ah++
	; Compare ah to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5214 ; If ah < bound, next iter
	mov qword [rsp + 16], 0 ; ah = 0
	add qword [rsp + 8], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5214 ; If ag < bound, next iter
	mov qword [rsp + 8], 0 ; ag = 0
	add qword [rsp + 0], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5214 ; If af < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const638] ; 973
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 456 to rsp 
		mov r10, [r12 - 456 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5215
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5215:
	cmp rax, [rsp + 32]
	jl .jump5216
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5216:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5217
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5217:
	cmp rax, [rsp + 40]
	jl .jump5218
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5218:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5219
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5219:
	cmp rax, [rsp + 48]
	jl .jump5220
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5220:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5221
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5221:
	cmp rax, [rsp + 56]
	jl .jump5222
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5222:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 344 to rsp 
		mov r10, [r12 - 344 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5223
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5223:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'af' to 0
	mov rax, 0
	push rax
.jump5224: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const639] ; 6.09
	push rax
	sub rsp, 32
	; Moving 32 bytes from r12 - 392 to rsp 
		mov r10, [r12 - 392 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 392 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 392 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 392 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	push rax
	; Moving 8 bytes from rsp + 48 to rsp + 48 
		mov r10, [rsp + 48 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'af'
	add qword [rsp + 0], 1
	; Compare af to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5224 ; If af < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	pop rdi
	pop rsi
	call _B
	add rsp, 32
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5225
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5225:
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5226
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5226:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5227
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5227:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 464 to rsp 
		mov r10, [r12 - 464 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5228
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5228:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ai' to 0
	mov rax, 0
	push rax
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
.jump5229: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const640] ; 11.39
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'ai'
	add qword [rsp + 24], 1
	; Compare ai to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5229 ; If ai < bound, next iter
	mov qword [rsp + 24], 0 ; ai = 0
	add qword [rsp + 16], 1 ; ah++
	; Compare ah to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5229 ; If ah < bound, next iter
	mov qword [rsp + 16], 0 ; ah = 0
	add qword [rsp + 8], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5229 ; If ag < bound, next iter
	mov qword [rsp + 8], 0 ; ag = 0
	add qword [rsp + 0], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5229 ; If af < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5230
	mov rax, [rel const5] ; False
	push rax
	jmp .jump5231
.jump5230:
	sub rsp, 8
	; Moving 8 bytes from r12 - 360 to rsp 
		mov r10, [r12 - 360 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 48 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
.jump5231:
	pop rax
	cmp rax, 0
	je .jump5232
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5234
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5234:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5235
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5235:
	; Computing bound for 'af'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump5236
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	jmp .jump5237
.jump5236:
	sub rsp, 8
	; Moving 8 bytes from r12 - 440 to rsp 
		mov r10, [r12 - 440 + 0]
		mov [rsp + 0], r10
.jump5237:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5238
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5238:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if f() then w else Q) 
	jno .jump5239
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5239:
	imul rdi, [rsp + 0 + 8] ; multiply by E 
	jno .jump5240
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5240:
	imul rdi, [rsp + 0 + 16] ; multiply by w 
	jno .jump5241
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5241:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
.jump5242: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ah'
	add qword [rsp + 16], 1
	; Compare ah to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5242 ; If ah < bound, next iter
	mov qword [rsp + 16], 0 ; ah = 0
	add qword [rsp + 8], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5242 ; If ag < bound, next iter
	mov qword [rsp + 8], 0 ; ag = 0
	add qword [rsp + 0], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5242 ; If af < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump5233
.jump5232:
	sub rsp, 32
	; Moving 32 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 184 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 184 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
.jump5233:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aj'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5243
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5243:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump5244
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5244:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'aj' to 0
	mov rax, 0
	push rax
.jump5245: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 456 to rsp 
		mov r10, [r12 - 456 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'aj'
	add qword [rsp + 0], 1
	; Compare aj to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5245 ; If aj < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 32
	; Moving 32 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 64 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 64 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5246
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump5247
.jump5246:
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump5247:
	; Moving 8 bytes from rsp + 48 to rsp + 48 
		mov r10, [rsp + 48 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 48 to rsp + 48 
		mov r10, [rsp + 48 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'aq'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5248
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5248:
	; Computing bound for 'ap'
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5249
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5249:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'aq' to 0
	mov rax, 0
	push rax
	; Initialize 'ap' to 0
	mov rax, 0
	push rax
.jump5250: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'aq'
	add qword [rsp + 8], 1
	; Compare aq to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5250 ; If aq < bound, next iter
	mov qword [rsp + 8], 0 ; aq = 0
	add qword [rsp + 0], 1 ; ap++
	; Compare ap to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5250 ; If ap < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5251
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5253
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump5254
.jump5253:
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump5254:
	; Moving 32 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 24]
		mov [rsp + 24 + 24], r10
		mov r10, [rsp + 16 + 16]
		mov [rsp + 24 + 16], r10
		mov r10, [rsp + 16 + 8]
		mov [rsp + 24 + 8], r10
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	jmp .jump5252
.jump5251:
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 48 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	pop rax
	cmp rax, 0
	je .jump5255
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump5255:
	push rax
	pop rax
	cmp rax, 0
	je .jump5256
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'aq'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5258
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5258:
	; Computing bound for 'ap'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5259
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5259:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'aq' to 0
	mov rax, 0
	push rax
	; Initialize 'ap' to 0
	mov rax, 0
	push rax
.jump5260: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const641] ; 19.33
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'aq'
	add qword [rsp + 8], 1
	; Compare aq to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5260 ; If aq < bound, next iter
	mov qword [rsp + 8], 0 ; aq = 0
	add qword [rsp + 0], 1 ; ap++
	; Compare ap to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5260 ; If ap < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump5257
.jump5256:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ar'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5261
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5261:
	; Computing bound for 'aq'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5262
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5262:
	; Computing bound for 'ap'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5263
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5263:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump5264
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5264:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump5265
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5265:
	imul rdi, [rsp + 0 + 16] ; multiply by q 
	jno .jump5266
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5266:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ar' to 0
	mov rax, 0
	push rax
	; Initialize 'aq' to 0
	mov rax, 0
	push rax
	; Initialize 'ap' to 0
	mov rax, 0
	push rax
.jump5267: ; Begin body of loop
	; Compute loop body
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ar'
	add qword [rsp + 16], 1
	; Compare ar to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5267 ; If ar < bound, next iter
	mov qword [rsp + 16], 0 ; ar = 0
	add qword [rsp + 8], 1 ; aq++
	; Compare aq to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5267 ; If aq < bound, next iter
	mov qword [rsp + 8], 0 ; aq = 0
	add qword [rsp + 0], 1 ; ap++
	; Compare ap to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5267 ; If ap < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5268
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5268:
	cmp rax, [rsp + 24]
	jl .jump5269
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5269:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5270
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5270:
	cmp rax, [rsp + 32]
	jl .jump5271
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5271:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5272
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5272:
	cmp rax, [rsp + 40]
	jl .jump5273
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5273:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5257:
.jump5252:
	mov rax, [rel const642] ; 11.42
	push rax
	sub rsp, 8 ; Add alignment
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const643] ; 24.66
	push rax
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const644] ; 66.76
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5274
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5274:
	cmp rax, [rsp + 8]
	jl .jump5275
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5275:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const5] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5276
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'as'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5278
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5278:
	; Computing bound for 'ar'
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 416 to rsp 
		mov r10, [r12 - 416 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5279
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5279:
	cmp rax, [rsp + 24]
	jl .jump5280
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5280:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5281
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5281:
	cmp rax, [rsp + 32]
	jl .jump5282
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5282:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5283
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5283:
	cmp rax, [rsp + 40]
	jl .jump5284
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5284:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5285
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5285:
	; Computing bound for 'aq'
	sub rsp, 8
	; Moving 8 bytes from r12 - 416 to rsp 
		mov r10, [r12 - 416 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5286
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5286:
	; Computing bound for 'ap'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5287
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5287:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump5288
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5288:
	imul rdi, [rsp + 0 + 8] ; multiply by T 
	jno .jump5289
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5289:
	imul rdi, [rsp + 0 + 16] ; multiply by al[T, D, n] 
	jno .jump5290
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5290:
	imul rdi, [rsp + 0 + 24] ; multiply by ag 
	jno .jump5291
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5291:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'as' to 0
	mov rax, 0
	push rax
	; Initialize 'ar' to 0
	mov rax, 0
	push rax
	; Initialize 'aq' to 0
	mov rax, 0
	push rax
	; Initialize 'ap' to 0
	mov rax, 0
	push rax
.jump5292: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'at'
	sub rsp, 8
	; Moving 8 bytes from r12 - 352 to rsp 
		mov r10, [r12 - 352 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5293
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5293:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'at' to 0
	mov rax, 0
	push rax
.jump5294: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'at'
	add qword [rsp + 0], 1
	; Compare at to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5294 ; If at < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'as'
	add qword [rsp + 24], 1
	; Compare as to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5292 ; If as < bound, next iter
	mov qword [rsp + 24], 0 ; as = 0
	add qword [rsp + 16], 1 ; ar++
	; Compare ar to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5292 ; If ar < bound, next iter
	mov qword [rsp + 16], 0 ; ar = 0
	add qword [rsp + 8], 1 ; aq++
	; Compare aq to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5292 ; If aq < bound, next iter
	mov qword [rsp + 8], 0 ; aq = 0
	add qword [rsp + 0], 1 ; ap++
	; Compare ap to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5292 ; If ap < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'as'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5295
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5295:
	; Computing bound for 'ar'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5296
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5296:
	; Computing bound for 'aq'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5297
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5297:
	; Computing bound for 'ap'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5298
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5298:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'as' to 0
	mov rax, 0
	push rax
	; Initialize 'ar' to 0
	mov rax, 0
	push rax
	; Initialize 'aq' to 0
	mov rax, 0
	push rax
	; Initialize 'ap' to 0
	mov rax, 0
	push rax
.jump5299: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'as'
	add qword [rsp + 24], 1
	; Compare as to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5299 ; If as < bound, next iter
	mov qword [rsp + 24], 0 ; as = 0
	add qword [rsp + 16], 1 ; ar++
	; Compare ar to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5299 ; If ar < bound, next iter
	mov qword [rsp + 16], 0 ; ar = 0
	add qword [rsp + 8], 1 ; aq++
	; Compare aq to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5299 ; If aq < bound, next iter
	mov qword [rsp + 8], 0 ; aq = 0
	add qword [rsp + 0], 1 ; ap++
	; Compare ap to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5299 ; If ap < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5300
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5300:
	cmp rax, [rsp + 32]
	jl .jump5301
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5301:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5302
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5302:
	cmp rax, [rsp + 40]
	jl .jump5303
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5303:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5304
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5304:
	cmp rax, [rsp + 48]
	jl .jump5305
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5305:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5306
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5306:
	cmp rax, [rsp + 56]
	jl .jump5307
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5307:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5308
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5308:
	cmp rax, [rsp + 8]
	jl .jump5309
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5309:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5277
.jump5276:
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 48 to rsp + 48 
		mov r10, [rsp + 48 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
.jump5277:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5310
	sub rsp, 24
	; Moving 24 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	jmp .jump5311
.jump5310:
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 32
	sub rsp, 8 ; Add alignment
	mov rax, [rel const645] ; 22.58
	push rax
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5312
	sub rsp, 24
	; Moving 24 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	jmp .jump5313
.jump5312:
	sub rsp, 24
	; Moving 24 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
.jump5313:
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const2] ; True
	push rax
	pop rsi
	lea rdi, [rsp + 88]
	call _X
	add rsp, 56
	add rsp, 24
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ar'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5314
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5314:
	; Computing bound for 'aq'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5315
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5315:
	; Computing bound for 'ap'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5316
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5316:
	; Computing total size of heap memory to allocate
	mov rdi, 56 ; sizeof u 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump5317
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5317:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump5318
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5318:
	imul rdi, [rsp + 0 + 16] ; multiply by q 
	jno .jump5319
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5319:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ar' to 0
	mov rax, 0
	push rax
	; Initialize 'aq' to 0
	mov rax, 0
	push rax
	; Initialize 'ap' to 0
	mov rax, 0
	push rax
.jump5320: ; Begin body of loop
	; Compute loop body
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 72]
	imul rax, 56
	add rax, [rsp + 104]
	; Move body (56 bytes) to index
	; Moving 56 bytes from rsp to rax 
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 56
	; Increment 'ar'
	add qword [rsp + 16], 1
	; Compare ar to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5320 ; If ar < bound, next iter
	mov qword [rsp + 16], 0 ; ar = 0
	add qword [rsp + 8], 1 ; aq++
	; Compare aq to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5320 ; If aq < bound, next iter
	mov qword [rsp + 8], 0 ; aq = 0
	add qword [rsp + 0], 1 ; ap++
	; Compare ap to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5320 ; If ap < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ar'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5321
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5321:
	; Computing bound for 'aq'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5322
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5322:
	; Computing bound for 'ap'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5323
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5323:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ar' to 0
	mov rax, 0
	push rax
	; Initialize 'aq' to 0
	mov rax, 0
	push rax
	; Initialize 'ap' to 0
	mov rax, 0
	push rax
.jump5324: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'ar'
	add qword [rsp + 16], 1
	; Compare ar to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5324 ; If ar < bound, next iter
	mov qword [rsp + 16], 0 ; ar = 0
	add qword [rsp + 8], 1 ; aq++
	; Compare aq to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5324 ; If aq < bound, next iter
	mov qword [rsp + 8], 0 ; aq = 0
	add qword [rsp + 0], 1 ; ap++
	; Compare ap to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5324 ; If ap < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ar'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5325
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5325:
	; Computing bound for 'aq'
	sub rsp, 8
	; Moving 8 bytes from r12 - 352 to rsp 
		mov r10, [r12 - 352 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5326
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5326:
	; Computing bound for 'ap'
	sub rsp, 8
	; Moving 8 bytes from r12 - 456 to rsp 
		mov r10, [r12 - 456 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5327
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5327:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ar' to 0
	mov rax, 0
	push rax
	; Initialize 'aq' to 0
	mov rax, 0
	push rax
	; Initialize 'ap' to 0
	mov rax, 0
	push rax
.jump5328: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'ar'
	add qword [rsp + 16], 1
	; Compare ar to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5328 ; If ar < bound, next iter
	mov qword [rsp + 16], 0 ; ar = 0
	add qword [rsp + 8], 1 ; aq++
	; Compare aq to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5328 ; If aq < bound, next iter
	mov qword [rsp + 8], 0 ; aq = 0
	add qword [rsp + 0], 1 ; ap++
	; Compare ap to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5328 ; If ap < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5329
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5329:
	cmp rax, [rsp + 24]
	jl .jump5330
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5330:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5331
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5331:
	cmp rax, [rsp + 32]
	jl .jump5332
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5332:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5333
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5333:
	cmp rax, [rsp + 40]
	jl .jump5334
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5334:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 56
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 56
	; Moving 56 bytes from rax to rsp 
		mov r10, [rax + 48]
		mov [rsp + 48], r10
		mov r10, [rax + 40]
		mov [rsp + 40], r10
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 48 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	; Moving 8 bytes from rsp + 8 to rsp + 48 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	sub rsp, 16
	; Moving 16 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5335
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5335:
	cmp rax, [rsp + 8]
	jl .jump5336
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5336:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 456 to rsp 
		mov r10, [r12 - 456 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5337
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'as'
	sub rsp, 8
	; Moving 8 bytes from r12 - 432 to rsp 
		mov r10, [r12 - 432 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5339
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5339:
	; Computing bound for 'ar'
	sub rsp, 8
	; Moving 8 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5340
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5340:
	; Computing bound for 'aq'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5341
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	jmp .jump5342
.jump5341:
	sub rsp, 8
	; Moving 8 bytes from r12 - 432 to rsp 
		mov r10, [r12 - 432 + 0]
		mov [rsp + 0], r10
.jump5342:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5343
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5343:
	; Computing bound for 'ap'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5344
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5344:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump5345
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5345:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (! Z) then w else R) 
	jno .jump5346
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5346:
	imul rdi, [rsp + 0 + 16] ; multiply by ab 
	jno .jump5347
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5347:
	imul rdi, [rsp + 0 + 24] ; multiply by R 
	jno .jump5348
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5348:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'as' to 0
	mov rax, 0
	push rax
	; Initialize 'ar' to 0
	mov rax, 0
	push rax
	; Initialize 'aq' to 0
	mov rax, 0
	push rax
	; Initialize 'ap' to 0
	mov rax, 0
	push rax
.jump5349: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'av'
	mov rax, [rel const55] ; 725
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5350
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5350:
	; Computing bound for 'au'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5351
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5351:
	; Computing bound for 'at'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5352
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5352:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by as 
	jno .jump5353
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5353:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump5354
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5354:
	imul rdi, [rsp + 0 + 16] ; multiply by 725 
	jno .jump5355
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5355:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'av' to 0
	mov rax, 0
	push rax
	; Initialize 'au' to 0
	mov rax, 0
	push rax
	; Initialize 'at' to 0
	mov rax, 0
	push rax
.jump5356: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'av'
	add qword [rsp + 16], 1
	; Compare av to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5356 ; If av < bound, next iter
	mov qword [rsp + 16], 0 ; av = 0
	add qword [rsp + 8], 1 ; au++
	; Compare au to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5356 ; If au < bound, next iter
	mov qword [rsp + 8], 0 ; au = 0
	add qword [rsp + 0], 1 ; at++
	; Compare at to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5356 ; If at < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'as'
	add qword [rsp + 24], 1
	; Compare as to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5349 ; If as < bound, next iter
	mov qword [rsp + 24], 0 ; as = 0
	add qword [rsp + 16], 1 ; ar++
	; Compare ar to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5349 ; If ar < bound, next iter
	mov qword [rsp + 16], 0 ; ar = 0
	add qword [rsp + 8], 1 ; aq++
	; Compare aq to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5349 ; If aq < bound, next iter
	mov qword [rsp + 8], 0 ; aq = 0
	add qword [rsp + 0], 1 ; ap++
	; Compare ap to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5349 ; If ap < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 32 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 24]
		mov [rsp + 24 + 24], r10
		mov r10, [rsp + 16 + 16]
		mov [rsp + 24 + 16], r10
		mov r10, [rsp + 16 + 8]
		mov [rsp + 24 + 8], r10
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from r12 - 432 to rsp 
		mov r10, [r12 - 432 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	pop rdi
	pop rsi
	call _B
	add rsp, 32
	push rax
	sub rsp, 8 ; Add alignment
	sub rsp, 32
	; Moving 32 bytes from r12 - 392 to rsp 
		mov r10, [r12 - 392 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 392 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 392 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 392 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from r12 - 392 to rsp 
		mov r10, [r12 - 392 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 392 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 392 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 392 + 0]
		mov [rsp + 0], r10
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 32 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 24]
		mov [rsp + 24 + 24], r10
		mov r10, [rsp + 16 + 16]
		mov [rsp + 24 + 16], r10
		mov r10, [rsp + 16 + 8]
		mov [rsp + 24 + 8], r10
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 216 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5357
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5357:
	cmp rax, [rsp + 16]
	jl .jump5358
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5358:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5359
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5359:
	cmp rax, [rsp + 24]
	jl .jump5360
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5360:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rdi, 128
	call _jpl_alloc
	; Moving 128 bytes from rsp to rax 
		mov r10, [rsp + 120]
		mov [rax + 120], r10
		mov r10, [rsp + 112]
		mov [rax + 112], r10
		mov r10, [rsp + 104]
		mov [rax + 104], r10
		mov r10, [rsp + 96]
		mov [rax + 96], r10
		mov r10, [rsp + 88]
		mov [rax + 88], r10
		mov r10, [rsp + 80]
		mov [rax + 80], r10
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 128
	push rax
	mov rax, 4
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5361
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5361:
	cmp rax, [rsp + 8]
	jl .jump5362
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5362:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'aq'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5363
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5363:
	; Computing bound for 'ap'
	sub rsp, 8
	; Moving 8 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5364
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5364:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'aq' to 0
	mov rax, 0
	push rax
	; Initialize 'ap' to 0
	mov rax, 0
	push rax
.jump5365: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 392 to rsp 
		mov r10, [r12 - 392 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 392 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 392 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 392 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const646] ; 97.65
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'aq'
	add qword [rsp + 8], 1
	; Compare aq to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5365 ; If aq < bound, next iter
	mov qword [rsp + 8], 0 ; aq = 0
	add qword [rsp + 0], 1 ; ap++
	; Compare ap to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5365 ; If ap < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	pop rdi
	pop rsi
	call _B
	add rsp, 32
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 32
	; Moving 32 bytes from r12 - 392 to rsp 
		mov r10, [r12 - 392 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 392 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 392 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 392 + 0]
		mov [rsp + 0], r10
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 32 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 24]
		mov [rsp + 24 + 24], r10
		mov r10, [rsp + 16 + 16]
		mov [rsp + 24 + 16], r10
		mov r10, [rsp + 16 + 8]
		mov [rsp + 24 + 8], r10
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Moving 32 bytes from rsp + 32 to rsp + 32 
		mov r10, [rsp + 32 + 24]
		mov [rsp + 32 + 24], r10
		mov r10, [rsp + 32 + 16]
		mov [rsp + 32 + 16], r10
		mov r10, [rsp + 32 + 8]
		mov [rsp + 32 + 8], r10
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 416 to rsp 
		mov r10, [r12 - 416 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const647] ; 6.67
	push rax
	mov rax, [rel const648] ; 69.26
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 48 to rsp + 48 
		mov r10, [rsp + 48 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	mov rax, [rel const649] ; 39.4
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump5366
	mov rax, [rel const650] ; 52.94
	push rax
	jmp .jump5367
.jump5366:
	mov rax, [rel const651] ; 44.65
	push rax
.jump5367:
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	pop rdi
	pop rsi
	call _B
	add rsp, 32
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5368
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5368:
	cmp rax, [rsp + 32]
	jl .jump5369
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5369:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5370
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5370:
	cmp rax, [rsp + 40]
	jl .jump5371
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5371:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5372
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5372:
	cmp rax, [rsp + 48]
	jl .jump5373
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5373:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5374
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5374:
	cmp rax, [rsp + 56]
	jl .jump5375
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5375:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5376
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	jmp .jump5377
.jump5376:
	sub rsp, 8
	; Moving 8 bytes from r12 - 456 to rsp 
		mov r10, [r12 - 456 + 0]
		mov [rsp + 0], r10
.jump5377:
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5378
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5378:
	cmp rax, [rsp + 24]
	jl .jump5379
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5379:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5380
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5380:
	cmp rax, [rsp + 32]
	jl .jump5381
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5381:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5382
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5382:
	cmp rax, [rsp + 40]
	jl .jump5383
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5383:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5338
.jump5337:
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump5384
	call _f
	push rax
	pop rax
	cmp rax, 0
	jne .jump5386
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const263] ; 581
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
.jump5386:
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5387
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5389
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aq'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5391
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5391:
	; Computing bound for 'ap'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5392
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5392:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by ag 
	jno .jump5393
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5393:
	imul rdi, [rsp + 0 + 8] ; multiply by ai 
	jno .jump5394
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5394:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'aq' to 0
	mov rax, 0
	push rax
	; Initialize 'ap' to 0
	mov rax, 0
	push rax
.jump5395: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'aq'
	add qword [rsp + 8], 1
	; Compare aq to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5395 ; If aq < bound, next iter
	mov qword [rsp + 8], 0 ; aq = 0
	add qword [rsp + 0], 1 ; ap++
	; Compare ap to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5395 ; If ap < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump5390
.jump5389:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ar'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5396
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5396:
	; Computing bound for 'aq'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5397
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5397:
	; Computing bound for 'ap'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5398
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5398:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump5399
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5399:
	imul rdi, [rsp + 0 + 8] ; multiply by A 
	jno .jump5400
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5400:
	imul rdi, [rsp + 0 + 16] ; multiply by ah 
	jno .jump5401
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5401:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ar' to 0
	mov rax, 0
	push rax
	; Initialize 'aq' to 0
	mov rax, 0
	push rax
	; Initialize 'ap' to 0
	mov rax, 0
	push rax
.jump5402: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'at'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5403
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5403:
	; Computing bound for 'as'
	sub rsp, 8
	; Moving 8 bytes from r12 - 456 to rsp 
		mov r10, [r12 - 456 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5404
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5404:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by W 
	jno .jump5405
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5405:
	imul rdi, [rsp + 0 + 8] ; multiply by ak 
	jno .jump5406
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5406:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'at' to 0
	mov rax, 0
	push rax
	; Initialize 'as' to 0
	mov rax, 0
	push rax
.jump5407: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'at'
	add qword [rsp + 8], 1
	; Compare at to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5407 ; If at < bound, next iter
	mov qword [rsp + 8], 0 ; at = 0
	add qword [rsp + 0], 1 ; as++
	; Compare as to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5407 ; If as < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'ar'
	add qword [rsp + 16], 1
	; Compare ar to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5402 ; If ar < bound, next iter
	mov qword [rsp + 16], 0 ; ar = 0
	add qword [rsp + 8], 1 ; aq++
	; Compare aq to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5402 ; If aq < bound, next iter
	mov qword [rsp + 8], 0 ; aq = 0
	add qword [rsp + 0], 1 ; ap++
	; Compare ap to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5402 ; If ap < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5408
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5408:
	cmp rax, [rsp + 24]
	jl .jump5409
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5409:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5410
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5410:
	cmp rax, [rsp + 32]
	jl .jump5411
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5411:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5412
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5412:
	cmp rax, [rsp + 40]
	jl .jump5413
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5413:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5390:
	jmp .jump5388
.jump5387:
	sub rsp, 40
	; Moving 40 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 352 to rsp 
		mov r10, [r12 - 352 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5414
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5414:
	cmp rax, [rsp + 32]
	jl .jump5415
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5415:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5416
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5416:
	cmp rax, [rsp + 40]
	jl .jump5417
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5417:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5418
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5418:
	cmp rax, [rsp + 48]
	jl .jump5419
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5419:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5420
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5420:
	cmp rax, [rsp + 56]
	jl .jump5421
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5421:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5388:
	jmp .jump5385
.jump5384:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aq'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5422
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5422:
	; Computing bound for 'ap'
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5423
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5423:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by E 
	jno .jump5424
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5424:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump5425
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5425:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'aq' to 0
	mov rax, 0
	push rax
	; Initialize 'ap' to 0
	mov rax, 0
	push rax
.jump5426: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'aq'
	add qword [rsp + 8], 1
	; Compare aq to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5426 ; If aq < bound, next iter
	mov qword [rsp + 8], 0 ; aq = 0
	add qword [rsp + 0], 1 ; ap++
	; Compare ap to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5426 ; If ap < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump5385:
.jump5338:
.jump5311:
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const5] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5427
	sub rsp, 56
	sub rsp, 8 ; Add alignment
	sub rsp, 32
	sub rsp, 8 ; Add alignment
	sub rsp, 24
	; Moving 24 bytes from rbp - -72 to rsp 
		mov r10, [rbp - -72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from r12 - 392 to rsp 
		mov r10, [r12 - 392 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 392 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 392 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 392 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5429
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 32 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 24]
		mov [rsp + 24 + 24], r10
		mov r10, [rsp + 16 + 16]
		mov [rsp + 24 + 16], r10
		mov r10, [rsp + 16 + 8]
		mov [rsp + 24 + 8], r10
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	jmp .jump5430
.jump5429:
	sub rsp, 24
	; Moving 24 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 216 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5431
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5431:
	cmp rax, [rsp + 16]
	jl .jump5432
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5432:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5433
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5433:
	cmp rax, [rsp + 24]
	jl .jump5434
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5434:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5430:
	mov rax, [rel const652] ; 12.89
	push rax
	mov rax, [rel const653] ; 27.49
	push rax
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 48 to rsp + 48 
		mov r10, [rsp + 48 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ax'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5435
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5435:
	; Computing bound for 'aw'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5436
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5436:
	; Computing total size of heap memory to allocate
	mov rdi, 56 ; sizeof u 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump5437
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5437:
	imul rdi, [rsp + 0 + 8] ; multiply by au 
	jno .jump5438
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5438:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ax' to 0
	mov rax, 0
	push rax
	; Initialize 'aw' to 0
	mov rax, 0
	push rax
.jump5439: ; Begin body of loop
	; Compute loop body
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 56
	add rax, [rsp + 88]
	; Move body (56 bytes) to index
	; Moving 56 bytes from rsp to rax 
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 56
	; Increment 'ax'
	add qword [rsp + 8], 1
	; Compare ax to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5439 ; If ax < bound, next iter
	mov qword [rsp + 8], 0 ; ax = 0
	add qword [rsp + 0], 1 ; aw++
	; Compare aw to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5439 ; If aw < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 424 to rsp 
		mov r10, [r12 - 424 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 344 to rsp 
		mov r10, [r12 - 344 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5440
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5440:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5441
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5441:
	cmp rax, [rsp + 16]
	jl .jump5442
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5442:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5443
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5443:
	cmp rax, [rsp + 24]
	jl .jump5444
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5444:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 56
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 56
	; Moving 56 bytes from rax to rsp 
		mov r10, [rax + 48]
		mov [rsp + 48], r10
		mov r10, [rax + 40]
		mov [rsp + 40], r10
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 48 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	mov rax, [rel const5] ; False
	push rax
	pop rsi
	lea rdi, [rsp + 88]
	call _X
	add rsp, 56
	add rsp, 24
	add rsp, 8 ; Remove alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ay'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5445
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5445:
	; Computing bound for 'ax'
	sub rsp, 8
	; Moving 8 bytes from r12 - 416 to rsp 
		mov r10, [r12 - 416 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5446
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5446:
	; Computing bound for 'aw'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5447
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5447:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump5448
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5448:
	imul rdi, [rsp + 0 + 8] ; multiply by T 
	jno .jump5449
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5449:
	imul rdi, [rsp + 0 + 16] ; multiply by ar 
	jno .jump5450
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5450:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ay' to 0
	mov rax, 0
	push rax
	; Initialize 'ax' to 0
	mov rax, 0
	push rax
	; Initialize 'aw' to 0
	mov rax, 0
	push rax
.jump5451: ; Begin body of loop
	; Compute loop body
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const654] ; 22.41
	push rax
	mov rax, [rel const655] ; 35.19
	push rax
	sub rsp, 32
	; Moving 32 bytes from r12 - 392 to rsp 
		mov r10, [r12 - 392 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 392 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 392 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 392 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const656] ; 98.24
	push rax
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'ay'
	add qword [rsp + 16], 1
	; Compare ay to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5451 ; If ay < bound, next iter
	mov qword [rsp + 16], 0 ; ay = 0
	add qword [rsp + 8], 1 ; ax++
	; Compare ax to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5451 ; If ax < bound, next iter
	mov qword [rsp + 8], 0 ; ax = 0
	add qword [rsp + 0], 1 ; aw++
	; Compare aw to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5451 ; If aw < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ax'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5452
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5452:
	; Computing bound for 'aw'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5453
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5453:
	; Computing total size of heap memory to allocate
	mov rdi, 56 ; sizeof u 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump5454
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5454:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump5455
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5455:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ax' to 0
	mov rax, 0
	push rax
	; Initialize 'aw' to 0
	mov rax, 0
	push rax
.jump5456: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'az'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5457
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5457:
	; Computing bound for 'ay'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5458
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5458:
	; Computing total size of heap memory to allocate
	mov rdi, 56 ; sizeof u 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump5459
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5459:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump5460
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5460:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'az' to 0
	mov rax, 0
	push rax
	; Initialize 'ay' to 0
	mov rax, 0
	push rax
.jump5461: ; Begin body of loop
	; Compute loop body
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 56
	add rax, [rsp + 88]
	; Move body (56 bytes) to index
	; Moving 56 bytes from rsp to rax 
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 56
	; Increment 'az'
	add qword [rsp + 8], 1
	; Compare az to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5461 ; If az < bound, next iter
	mov qword [rsp + 8], 0 ; az = 0
	add qword [rsp + 0], 1 ; ay++
	; Compare ay to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5461 ; If ay < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5462
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5462:
	cmp rax, [rsp + 16]
	jl .jump5463
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5463:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5464
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5464:
	cmp rax, [rsp + 24]
	jl .jump5465
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5465:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 56
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 56
	; Moving 56 bytes from rax to rsp 
		mov r10, [rax + 48]
		mov [rsp + 48], r10
		mov r10, [rax + 40]
		mov [rsp + 40], r10
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 56
	add rax, [rsp + 88]
	; Move body (56 bytes) to index
	; Moving 56 bytes from rsp to rax 
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 56
	; Increment 'ax'
	add qword [rsp + 8], 1
	; Compare ax to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5456 ; If ax < bound, next iter
	mov qword [rsp + 8], 0 ; ax = 0
	add qword [rsp + 0], 1 ; aw++
	; Compare aw to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5456 ; If aw < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const5] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5466
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ax'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5468
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5468:
	; Computing bound for 'aw'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5469
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5469:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by ao 
	jno .jump5470
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5470:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump5471
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5471:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ax' to 0
	mov rax, 0
	push rax
	; Initialize 'aw' to 0
	mov rax, 0
	push rax
.jump5472: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ax'
	add qword [rsp + 8], 1
	; Compare ax to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5472 ; If ax < bound, next iter
	mov qword [rsp + 8], 0 ; ax = 0
	add qword [rsp + 0], 1 ; aw++
	; Compare aw to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5472 ; If aw < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump5467
.jump5466:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ax'
	sub rsp, 8
	; Moving 8 bytes from r12 - 424 to rsp 
		mov r10, [r12 - 424 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5473
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5473:
	; Computing bound for 'aw'
	sub rsp, 8
	; Moving 8 bytes from r12 - 344 to rsp 
		mov r10, [r12 - 344 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5474
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5474:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by N 
	jno .jump5475
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5475:
	imul rdi, [rsp + 0 + 8] ; multiply by S 
	jno .jump5476
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5476:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ax' to 0
	mov rax, 0
	push rax
	; Initialize 'aw' to 0
	mov rax, 0
	push rax
.jump5477: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ax'
	add qword [rsp + 8], 1
	; Compare ax to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5477 ; If ax < bound, next iter
	mov qword [rsp + 8], 0 ; ax = 0
	add qword [rsp + 0], 1 ; aw++
	; Compare aw to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5477 ; If aw < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump5467:
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5478
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5478:
	cmp rax, [rsp + 16]
	jl .jump5479
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5479:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5480
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5480:
	cmp rax, [rsp + 24]
	jl .jump5481
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5481:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5482
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5482:
	cmp rax, [rsp + 16]
	jl .jump5483
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5483:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5484
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5484:
	cmp rax, [rsp + 24]
	jl .jump5485
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5485:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 56
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 56
	; Moving 56 bytes from rax to rsp 
		mov r10, [rax + 48]
		mov [rsp + 48], r10
		mov r10, [rax + 40]
		mov [rsp + 40], r10
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump5486
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump5488
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump5489
.jump5488:
	mov rax, [rel const657] ; 47.67
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump5489:
	jmp .jump5487
.jump5486:
	sub rsp, 24
	; Moving 24 bytes from r12 - 464 to rsp 
		mov r10, [r12 - 464 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 464 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 464 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5490
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5490:
	cmp rax, [rsp + 16]
	jl .jump5491
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5491:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5492
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5492:
	cmp rax, [rsp + 24]
	jl .jump5493
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5493:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
.jump5487:
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 48 to rsp + 48 
		mov r10, [rsp + 48 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 32
	; Moving 32 bytes from r12 - 392 to rsp 
		mov r10, [r12 - 392 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 392 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 392 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 392 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5494
	sub rsp, 8
	; Moving 8 bytes from r12 - 424 to rsp 
		mov r10, [r12 - 424 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	jmp .jump5495
.jump5494:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5496
	mov rax, [rel const5] ; False
	push rax
	jmp .jump5497
.jump5496:
	mov rax, [rel const2] ; True
	push rax
.jump5497:
.jump5495:
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 48 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump5498
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump5499
.jump5498:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ay'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5500
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5500:
	; Computing bound for 'ax'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5501
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5501:
	; Computing bound for 'aw'
	sub rsp, 8
	; Moving 8 bytes from r12 - 464 to rsp 
		mov r10, [r12 - 464 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5502
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5502:
	; Computing total size of heap memory to allocate
	mov rdi, 56 ; sizeof u 
	imul rdi, [rsp + 0 + 0] ; multiply by V 
	jno .jump5503
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5503:
	imul rdi, [rsp + 0 + 8] ; multiply by (- p) 
	jno .jump5504
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5504:
	imul rdi, [rsp + 0 + 16] ; multiply by q 
	jno .jump5505
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5505:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ay' to 0
	mov rax, 0
	push rax
	; Initialize 'ax' to 0
	mov rax, 0
	push rax
	; Initialize 'aw' to 0
	mov rax, 0
	push rax
.jump5506: ; Begin body of loop
	; Compute loop body
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 72]
	imul rax, 56
	add rax, [rsp + 104]
	; Move body (56 bytes) to index
	; Moving 56 bytes from rsp to rax 
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 56
	; Increment 'ay'
	add qword [rsp + 16], 1
	; Compare ay to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5506 ; If ay < bound, next iter
	mov qword [rsp + 16], 0 ; ay = 0
	add qword [rsp + 8], 1 ; ax++
	; Compare ax to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5506 ; If ax < bound, next iter
	mov qword [rsp + 8], 0 ; ax = 0
	add qword [rsp + 0], 1 ; aw++
	; Compare aw to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5506 ; If aw < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5507
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5507:
	cmp rax, [rsp + 24]
	jl .jump5508
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5508:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5509
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5509:
	cmp rax, [rsp + 32]
	jl .jump5510
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5510:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5511
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5511:
	cmp rax, [rsp + 40]
	jl .jump5512
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5512:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 56
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 56
	; Moving 56 bytes from rax to rsp 
		mov r10, [rax + 48]
		mov [rsp + 48], r10
		mov r10, [rax + 40]
		mov [rsp + 40], r10
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5499:
	mov rdi, 168
	call _jpl_alloc
	; Moving 168 bytes from rsp to rax 
		mov r10, [rsp + 160]
		mov [rax + 160], r10
		mov r10, [rsp + 152]
		mov [rax + 152], r10
		mov r10, [rsp + 144]
		mov [rax + 144], r10
		mov r10, [rsp + 136]
		mov [rax + 136], r10
		mov r10, [rsp + 128]
		mov [rax + 128], r10
		mov r10, [rsp + 120]
		mov [rax + 120], r10
		mov r10, [rsp + 112]
		mov [rax + 112], r10
		mov r10, [rsp + 104]
		mov [rax + 104], r10
		mov r10, [rsp + 96]
		mov [rax + 96], r10
		mov r10, [rsp + 88]
		mov [rax + 88], r10
		mov r10, [rsp + 80]
		mov [rax + 80], r10
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 168
	push rax
	mov rax, 3
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aw'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5513
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5513:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof u[,][,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by an 
	jno .jump5514
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5514:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'aw' to 0
	mov rax, 0
	push rax
.jump5515: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aA'
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5516
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5516:
	; Computing bound for 'az'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5517
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5517:
	; Computing bound for 'ay'
	mov rax, [rel const658] ; 652
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5518
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5518:
	; Computing bound for 'ax'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5519
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5519:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof u[,][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by ah 
	jno .jump5520
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5520:
	imul rdi, [rsp + 0 + 8] ; multiply by 652 
	jno .jump5521
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5521:
	imul rdi, [rsp + 0 + 16] ; multiply by am 
	jno .jump5522
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5522:
	imul rdi, [rsp + 0 + 24] ; multiply by D 
	jno .jump5523
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5523:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'aA' to 0
	mov rax, 0
	push rax
	; Initialize 'az' to 0
	mov rax, 0
	push rax
	; Initialize 'ay' to 0
	mov rax, 0
	push rax
	; Initialize 'ax' to 0
	mov rax, 0
	push rax
.jump5524: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aD'
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5525
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5525:
	; Computing bound for 'aC'
	sub rsp, 8
	; Moving 8 bytes from rbp - 408 to rsp 
		mov r10, [rbp - 408 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5526
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5526:
	; Computing bound for 'aB'
	sub rsp, 8
	; Moving 8 bytes from rbp - 384 to rsp 
		mov r10, [rbp - 384 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5527
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5527:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof u[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by aA 
	jno .jump5528
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5528:
	imul rdi, [rsp + 0 + 8] ; multiply by ax 
	jno .jump5529
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5529:
	imul rdi, [rsp + 0 + 16] ; multiply by D 
	jno .jump5530
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5530:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'aD' to 0
	mov rax, 0
	push rax
	; Initialize 'aC' to 0
	mov rax, 0
	push rax
	; Initialize 'aB' to 0
	mov rax, 0
	push rax
.jump5531: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aF'
	sub rsp, 8
	; Moving 8 bytes from rbp - 448 to rsp 
		mov r10, [rbp - 448 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5532
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5532:
	; Computing bound for 'aE'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5533
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5533:
	; Computing total size of heap memory to allocate
	mov rdi, 56 ; sizeof u 
	imul rdi, [rsp + 0 + 0] ; multiply by am 
	jno .jump5534
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5534:
	imul rdi, [rsp + 0 + 8] ; multiply by aD 
	jno .jump5535
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5535:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'aF' to 0
	mov rax, 0
	push rax
	; Initialize 'aE' to 0
	mov rax, 0
	push rax
.jump5536: ; Begin body of loop
	; Compute loop body
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 56
	add rax, [rsp + 88]
	; Move body (56 bytes) to index
	; Moving 56 bytes from rsp to rax 
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 56
	; Increment 'aF'
	add qword [rsp + 8], 1
	; Compare aF to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5536 ; If aF < bound, next iter
	mov qword [rsp + 8], 0 ; aF = 0
	add qword [rsp + 0], 1 ; aE++
	; Compare aE to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5536 ; If aE < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'aD'
	add qword [rsp + 16], 1
	; Compare aD to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5531 ; If aD < bound, next iter
	mov qword [rsp + 16], 0 ; aD = 0
	add qword [rsp + 8], 1 ; aC++
	; Compare aC to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5531 ; If aC < bound, next iter
	mov qword [rsp + 8], 0 ; aC = 0
	add qword [rsp + 0], 1 ; aB++
	; Compare aB to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5531 ; If aB < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'aA'
	add qword [rsp + 24], 1
	; Compare aA to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5524 ; If aA < bound, next iter
	mov qword [rsp + 24], 0 ; aA = 0
	add qword [rsp + 16], 1 ; az++
	; Compare az to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5524 ; If az < bound, next iter
	mov qword [rsp + 16], 0 ; az = 0
	add qword [rsp + 8], 1 ; ay++
	; Compare ay to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5524 ; If ay < bound, next iter
	mov qword [rsp + 8], 0 ; ay = 0
	add qword [rsp + 0], 1 ; ax++
	; Compare ax to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5524 ; If ax < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'aw'
	add qword [rsp + 0], 1
	; Compare aw to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5515 ; If aw < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 440 to rsp 
		mov r10, [r12 - 440 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5537
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5537:
	cmp rax, [rsp + 8]
	jl .jump5538
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5538:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	lea rdi, [rsp + 128]
	call _x
	add rsp, 40
	add rsp, 16
	add rsp, 32
	add rsp, 32
	add rsp, 8 ; Remove alignment
	jmp .jump5428
.jump5427:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump5539
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump5540
.jump5539:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump5540:
	pop rax
	cmp rax, 0
	je .jump5541
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5543
	sub rsp, 32
	; Moving 32 bytes from r12 - 392 to rsp 
		mov r10, [r12 - 392 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 392 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 392 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 392 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	jmp .jump5544
.jump5543:
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 48 to rsp + 48 
		mov r10, [rsp + 48 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
.jump5544:
	mov rax, [rel const659] ; 81.48
	push rax
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5545
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5545:
	cmp rax, [rsp + 8]
	jl .jump5546
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5546:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from r12 - 392 to rsp 
		mov r10, [r12 - 392 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 392 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 392 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 392 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ay'
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5547
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5547:
	; Computing bound for 'ax'
	sub rsp, 8
	; Moving 8 bytes from r12 - 424 to rsp 
		mov r10, [r12 - 424 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5548
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5548:
	; Computing bound for 'aw'
	sub rsp, 8
	; Moving 8 bytes from r12 - 456 to rsp 
		mov r10, [r12 - 456 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5549
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5549:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ay' to 0
	mov rax, 0
	push rax
	; Initialize 'ax' to 0
	mov rax, 0
	push rax
	; Initialize 'aw' to 0
	mov rax, 0
	push rax
.jump5550: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'ay'
	add qword [rsp + 16], 1
	; Compare ay to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5550 ; If ay < bound, next iter
	mov qword [rsp + 16], 0 ; ay = 0
	add qword [rsp + 8], 1 ; ax++
	; Compare ax to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5550 ; If ax < bound, next iter
	mov qword [rsp + 8], 0 ; ax = 0
	add qword [rsp + 0], 1 ; aw++
	; Compare aw to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5550 ; If aw < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump5551
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump5551:
	push rax
	pop rax
	cmp rax, 0
	je .jump5552
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump5553
.jump5552:
	sub rsp, 24
	; Moving 24 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 136 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 416 to rsp 
		mov r10, [r12 - 416 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 360 to rsp 
		mov r10, [r12 - 360 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5554
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5554:
	cmp rax, [rsp + 16]
	jl .jump5555
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5555:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5556
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5556:
	cmp rax, [rsp + 24]
	jl .jump5557
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5557:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5558
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'az'
	sub rsp, 8
	; Moving 8 bytes from r12 - 432 to rsp 
		mov r10, [r12 - 432 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5560
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5560:
	; Computing bound for 'ay'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5561
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5561:
	; Computing bound for 'ax'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5562
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5562:
	; Computing bound for 'aw'
	sub rsp, 8
	; Moving 8 bytes from r12 - 456 to rsp 
		mov r10, [r12 - 456 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5563
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5563:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by W 
	jno .jump5564
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5564:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump5565
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5565:
	imul rdi, [rsp + 0 + 16] ; multiply by s 
	jno .jump5566
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5566:
	imul rdi, [rsp + 0 + 24] ; multiply by R 
	jno .jump5567
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5567:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'az' to 0
	mov rax, 0
	push rax
	; Initialize 'ay' to 0
	mov rax, 0
	push rax
	; Initialize 'ax' to 0
	mov rax, 0
	push rax
	; Initialize 'aw' to 0
	mov rax, 0
	push rax
.jump5568: ; Begin body of loop
	; Compute loop body
	call _z
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'az'
	add qword [rsp + 24], 1
	; Compare az to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5568 ; If az < bound, next iter
	mov qword [rsp + 24], 0 ; az = 0
	add qword [rsp + 16], 1 ; ay++
	; Compare ay to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5568 ; If ay < bound, next iter
	mov qword [rsp + 16], 0 ; ay = 0
	add qword [rsp + 8], 1 ; ax++
	; Compare ax to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5568 ; If ax < bound, next iter
	mov qword [rsp + 8], 0 ; ax = 0
	add qword [rsp + 0], 1 ; aw++
	; Compare aw to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5568 ; If aw < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump5559
.jump5558:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'az'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5569
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5569:
	; Computing bound for 'ay'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5570
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5570:
	; Computing bound for 'ax'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5571
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5571:
	; Computing bound for 'aw'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5572
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5572:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by ao 
	jno .jump5573
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5573:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump5574
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5574:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump5575
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5575:
	imul rdi, [rsp + 0 + 24] ; multiply by am 
	jno .jump5576
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5576:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'az' to 0
	mov rax, 0
	push rax
	; Initialize 'ay' to 0
	mov rax, 0
	push rax
	; Initialize 'ax' to 0
	mov rax, 0
	push rax
	; Initialize 'aw' to 0
	mov rax, 0
	push rax
.jump5577: ; Begin body of loop
	; Compute loop body
	call _z
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'az'
	add qword [rsp + 24], 1
	; Compare az to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5577 ; If az < bound, next iter
	mov qword [rsp + 24], 0 ; az = 0
	add qword [rsp + 16], 1 ; ay++
	; Compare ay to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5577 ; If ay < bound, next iter
	mov qword [rsp + 16], 0 ; ay = 0
	add qword [rsp + 8], 1 ; ax++
	; Compare ax to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5577 ; If ax < bound, next iter
	mov qword [rsp + 8], 0 ; ax = 0
	add qword [rsp + 0], 1 ; aw++
	; Compare aw to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5577 ; If aw < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump5559:
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 424 to rsp 
		mov r10, [r12 - 424 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5578
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5578:
	cmp rax, [rsp + 32]
	jl .jump5579
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5579:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5580
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5580:
	cmp rax, [rsp + 40]
	jl .jump5581
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5581:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5582
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5582:
	cmp rax, [rsp + 48]
	jl .jump5583
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5583:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5584
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5584:
	cmp rax, [rsp + 56]
	jl .jump5585
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5585:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5553:
	jmp .jump5542
.jump5541:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ax'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5586
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5586:
	; Computing bound for 'aw'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5587
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5587:
	; Computing total size of heap memory to allocate
	mov rdi, 56 ; sizeof u 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump5588
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5588:
	imul rdi, [rsp + 0 + 8] ; multiply by F 
	jno .jump5589
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5589:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ax' to 0
	mov rax, 0
	push rax
	; Initialize 'aw' to 0
	mov rax, 0
	push rax
.jump5590: ; Begin body of loop
	; Compute loop body
	sub rsp, 56
	; Moving 56 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 48]
		mov [rsp + 48], r10
		mov r10, [rbp - -16 + 40]
		mov [rsp + 40], r10
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 56
	add rax, [rsp + 88]
	; Move body (56 bytes) to index
	; Moving 56 bytes from rsp to rax 
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 56
	; Increment 'ax'
	add qword [rsp + 8], 1
	; Compare ax to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5590 ; If ax < bound, next iter
	mov qword [rsp + 8], 0 ; ax = 0
	add qword [rsp + 0], 1 ; aw++
	; Compare aw to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5590 ; If aw < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5591
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5591:
	cmp rax, [rsp + 16]
	jl .jump5592
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5592:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5593
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5593:
	cmp rax, [rsp + 24]
	jl .jump5594
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5594:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 56
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 56
	; Moving 56 bytes from rax to rsp 
		mov r10, [rax + 48]
		mov [rsp + 48], r10
		mov r10, [rax + 40]
		mov [rsp + 40], r10
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5542:
.jump5428:
	; Moving 32 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 24]
		mov [rsp + 24 + 24], r10
		mov r10, [rsp + 16 + 16]
		mov [rsp + 24 + 16], r10
		mov r10, [rsp + 16 + 8]
		mov [rsp + 24 + 8], r10
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 200 ; Local variables
	pop rbp
	ret

Y:
_Y:
	push rbp
	mov rbp, rsp
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump5595
	mov rax, [rel const2] ; True
	push rax
	pop rax
.jump5595:
	push rax
	pop rax
	cmp rax, 0
	jne .jump5596
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const660] ; 'ai'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5596:
	sub rsp, 40
	; Moving 40 bytes from r12 - 328 to rsp 
		mov r10, [r12 - 328 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 328 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 328 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 328 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 328 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const661] ; 17
	push rax
	pop rax
	add rsp, 48 ; Local variables
	pop rbp
	ret
	sub rsp, 40
	; Moving 40 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	jne .jump5597
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const662] ; 'as'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5597:
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	pop rax
	add rsp, 88 ; Local variables
	pop rbp
	ret
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add rsp, 88 ; Local variables
	pop rbp
	ret
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add rsp, 88 ; Local variables
	pop rbp
	ret

jpl_main:
_jpl_main:
	push rbp
	mov rbp, rsp
	push r12
	mov r12, rbp ; end of jpl_main prelude
	mov rax, [rel const0] ; 12.03
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const1] ; 77.23
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3
	mov rax, [rel const3] ; 69
	push rax
	mov rax, [rel const4] ; 357
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	jmp .jump4
.jump3:
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump5
	mov rax, [rel const2] ; True
	push rax
	pop rax
.jump5:
	push rax
.jump4:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const6] ; 305
	push rax
	mov rax, [rel const7] ; 928
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump8
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump8:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump9:
	; Computing bound for 'b'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const10] ; 285
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump10:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump11: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; 436
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump11 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump12
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump12:
	; Computing bound for 'a'
	mov rax, [rel const12] ; 807
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump13
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump13:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump14: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump14 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump14 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump14 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump15
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump15:
	; Computing bound for 'c'
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump16
	mov rax, [rel const13] ; 736
	push rax
	jmp .jump17
.jump16:
	mov rax, [rel const14] ; 915
	push rax
.jump17:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump18
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump18:
	; Computing bound for 'b'
	mov rax, [rel const15] ; 976
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump19
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump19:
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const16] ; 331
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump20
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump20:
	; Computing bound for 'b'
	mov rax, [rel const17] ; 726
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump21
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump21:
	; Computing bound for 'a'
	mov rax, [rel const18] ; 238
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump22
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump22:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump23: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump23 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump23 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump23 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump24
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump24:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[a : 238, b : 726, c : (- 331)] c) 
	jno .jump25
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump25:
	imul rdi, [rsp + 0 + 8] ; multiply by 976 
	jno .jump26
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump26:
	imul rdi, [rsp + 0 + 16] ; multiply by (- (if false then 736 else 915)) 
	jno .jump27
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump27:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[a : 807, b : (sum[a : 285] 436), c : (928 / 305)] (- b)) 
	jno .jump28
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump28:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump29: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump30
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump30:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump31
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump31:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump32
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump32:
	; Computing bound for 'e'
	mov rax, [rel const20] ; 207
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump33
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump33:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 207 
	jno .jump34
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump34:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump35
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump35:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump36
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump36:
	imul rdi, [rsp + 0 + 24] ; multiply by d 
	jno .jump37
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump37:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump38: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const2] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump38 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump38 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump38 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump38 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump39
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump39:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump40: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump40 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump41
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump41:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump42
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump42:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump43
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump43:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump44: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump44 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump44 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump44 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump45
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump45:
	cmp rax, [rsp + 32]
	jl .jump46
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump46:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump47
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump47:
	cmp rax, [rsp + 40]
	jl .jump48
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump48:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump49
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump49:
	cmp rax, [rsp + 48]
	jl .jump50
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump50:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump51
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump51:
	cmp rax, [rsp + 56]
	jl .jump52
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump52:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump29 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump29 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump29 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump29 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump7
.jump6:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const23] ; 417
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump53
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump53:
	; Computing bound for 'c'
	mov rax, [rel const24] ; 411
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump54
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump54:
	; Computing bound for 'b'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const25] ; 453
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump55
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump55:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump56: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump56 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump57
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump57:
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const26] ; 296
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump58
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump58:
	; Computing bound for 'b'
	mov rax, [rel const27] ; 965
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump59
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump59:
	; Computing bound for 'a'
	mov rax, [rel const28] ; 279
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump60
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump60:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump61: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const29] ; 310
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump62
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump62:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump63
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump63:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump64
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump64:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump65
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump65:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump66: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump66 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump66 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump66 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump66 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump61 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump61 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump61 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump67
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump67:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[a : 279, b : (- 965), c : 296] (sum[d : c, e : a, f : b, g : 310] g)) 
	jno .jump68
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump68:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[a : 453] a) 
	jno .jump69
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump69:
	imul rdi, [rsp + 0 + 16] ; multiply by (- 411) 
	jno .jump70
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump70:
	imul rdi, [rsp + 0 + 24] ; multiply by 417 
	jno .jump71
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump71:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump72: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump73
	mov rax, [rel const5] ; False
	push rax
	pop rax
.jump73:
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump72 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump72 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump72 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump72 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump7:
	jmp .jump2
.jump1:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const30] ; 122
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump74
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump74:
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const31] ; 419
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump75
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump75:
	; Computing bound for 'c'
	mov rax, [rel const32] ; 360
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump76
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump76:
	; Computing bound for 'b'
	mov rax, [rel const33] ; 740
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump77
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump77:
	; Computing bound for 'a'
	mov rax, [rel const34] ; 938
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump78
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump78:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump79: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump79 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump79 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump79 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump79 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump80
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump80:
	; Computing bound for 'b'
	mov rax, [rel const35] ; 607
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump81
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump81:
	; Computing bound for 'a'
	mov rax, [rel const36] ; 960
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const37] ; 261
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump82
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump82:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (- (261 - (- 960))) 
	jno .jump83
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump83:
	imul rdi, [rsp + 0 + 8] ; multiply by 607 
	jno .jump84
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump84:
imul rdi, [rsp + 0 + 16] ; multiply by (- (sum[a : 938, b : 740, c : (- 360), d : 419] d)) 
	jno .jump85
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump85:
	imul rdi, [rsp + 0 + 24] ; multiply by 122 
	jno .jump86
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump86:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump87: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const23] ; 417
	push rax
	mov rax, [rel const38] ; 953
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump87 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump87 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump87 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump87 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump2:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const39] ; 62
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump88
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump88:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump89: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const40] ; 570
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump89 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const41] ; 609
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump90
	mov rax, [rel const42] ; 396
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump91
.jump90:
	mov rax, [rel const43] ; 858
	push rax
.jump91:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump92
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump92:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const45] ; 996
	push rax
	mov rax, [rel const46] ; 653
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump93
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump93:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump94: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump94 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump95
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump95:
	; Computing bound for 'b'
	mov rax, [rel const47] ; 289
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump96
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump96:
	; Computing bound for 'a'
	mov rax, [rel const48] ; 586
	push rax
	mov rax, [rel const26] ; 296
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump97
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump97:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump98
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump98:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump99: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump100
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump100:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump101
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump101:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump102
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump102:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump103
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump103:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump104: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump104 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump104 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump104 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump104 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump99 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump99 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump99 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const49] ; 55
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump105
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump105:
	; Computing bound for 'b'
	mov rax, [rel const50] ; 986
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump106
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump106:
	; Computing bound for 'a'
	mov rax, [rel const51] ; 126
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump107
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump107:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by 126 
	jno .jump108
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump108:
	imul rdi, [rsp + 0 + 8] ; multiply by 986 
	jno .jump109
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump109:
	imul rdi, [rsp + 0 + 16] ; multiply by 55 
	jno .jump110
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump110:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump111: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const52] ; 34.74
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump111 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump111 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump111 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump112
	mov rax, [rel const53] ; 715
	push rax
	jmp .jump113
.jump112:
	mov rax, [rel const54] ; 575
	push rax
.jump113:
	mov rax, [rel const55] ; 725
	push rax
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	mov rax, [rel const56] ; 298
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump114
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump114:
	cmp rax, [rsp + 8]
	jl .jump115
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump115:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump116
	mov rax, [rel const57] ; 781
	push rax
	jmp .jump117
.jump116:
	mov rax, [rel const58] ; 79
	push rax
.jump117:
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump118
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump118:
	cmp rax, [rsp + 24]
	jl .jump119
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump119:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump120
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump120:
	cmp rax, [rsp + 32]
	jl .jump121
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump121:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump122
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump122:
	cmp rax, [rsp + 40]
	jl .jump123
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump123:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const59] ; 392
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump124
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump124:
	; Computing bound for 'a'
	mov rax, [rel const60] ; 578
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump125
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump125:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump126: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const61] ; 44.29
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump126 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump126 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump127
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const62] ; 112
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump129
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump129:
	; Computing bound for 'c'
	mov rax, [rel const63] ; 591
	push rax
	mov rax, [rel const64] ; 159
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump130
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump130:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump131
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump131:
	; Computing bound for 'b'
	mov rax, [rel const65] ; 490
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump132
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump132:
	; Computing bound for 'a'
	mov rax, [rel const66] ; 656
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump133
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump133:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump134: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const67] ; 21
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump135
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump135:
	; Computing bound for 'f'
	mov rax, [rel const68] ; 35
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump136
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump136:
	; Computing bound for 'e'
	mov rax, [rel const69] ; 4
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump137
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump137:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 4 
	jno .jump138
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump138:
	imul rdi, [rsp + 0 + 8] ; multiply by 35 
	jno .jump139
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump139:
	imul rdi, [rsp + 0 + 16] ; multiply by 21 
	jno .jump140
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump140:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump141: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump141 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump141 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump141 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump142
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump142:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump143
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump143:
	cmp rax, [rsp + 24]
	jl .jump144
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump144:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump145
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump145:
	cmp rax, [rsp + 32]
	jl .jump146
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump146:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump147
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump147:
	cmp rax, [rsp + 40]
	jl .jump148
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump148:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump134 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump134 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump134 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump134 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	neg rax
	push rax
	jmp .jump128
.jump127:
	mov rax, [rel const66] ; 656
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const70] ; 125
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump149
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump149:
	; Computing bound for 'a'
	mov rax, [rel const71] ; 251
	push rax
	mov rax, [rel const72] ; 473
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump150
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump150:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump151: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump151 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump151 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump152
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump152:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump153: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const73] ; 98
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump153 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	sub rax, r10
	push rax
.jump128:
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump154
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const74] ; 73
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump156
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump156:
	; Computing bound for 'b'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const75] ; 761
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump157
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump157:
	; Computing bound for 'c'
	mov rax, [rel const76] ; 530
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump158
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump158:
	; Computing bound for 'b'
	mov rax, [rel const77] ; 969
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump159
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump159:
	; Computing bound for 'a'
	mov rax, [rel const78] ; 585
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump160
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump160:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump161: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump162
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	jmp .jump163
.jump162:
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
.jump163:
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump161 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump161 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump161 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump161 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump164
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump164:
	; Computing bound for 'a'
	mov rax, [rel const79] ; 430
	push rax
	mov rax, [rel const80] ; 721
	push rax
	mov rax, [rel const81] ; 170
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump165
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump165:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump166
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump166:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by ((170 - 721) % 430) 
	jno .jump167
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump167:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[a : 585, b : 969, c : (- 530), d : 761] (if true then c else d)) 
	jno .jump168
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump168:
	imul rdi, [rsp + 0 + 16] ; multiply by (- 73) 
	jno .jump169
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump169:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump170: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump170 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump170 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump170 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump155
.jump154:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const82] ; 982
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump171
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump171:
	; Computing bound for 'b'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const83] ; 625
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump172
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump172:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump173: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const84] ; 598
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump173 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump174
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump174:
	; Computing bound for 'a'
	mov rax, [rel const85] ; 931
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump175
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump175:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 931 
	jno .jump176
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump176:
imul rdi, [rsp + 0 + 8] ; multiply by (- (sum[a : 625] 598)) 
	jno .jump177
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump177:
	imul rdi, [rsp + 0 + 16] ; multiply by 982 
	jno .jump178
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump178:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump179: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump179 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump179 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump179 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump155:
	mov rax, [rel const86] ; 283
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const87] ; 723
	push rax
	mov rax, [rel const88] ; 180
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump180
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump180:
	cmp rax, [rsp + 24]
	jl .jump181
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump181:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump182
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump182:
	cmp rax, [rsp + 32]
	jl .jump183
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump183:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump184
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump184:
	cmp rax, [rsp + 40]
	jl .jump185
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump185:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const89] ; 23.17
	push rax
	mov rax, [rel const90] ; 36.13
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump186
	mov rax, [rel const91] ; 404
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump187
.jump186:
	mov rax, [rel const88] ; 180
	push rax
.jump187:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump188
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump188:
	cmp rax, [rsp + 32]
	jl .jump189
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump189:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump190
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump190:
	cmp rax, [rsp + 40]
	jl .jump191
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump191:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump192
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump192:
	cmp rax, [rsp + 48]
	jl .jump193
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump193:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump194
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump194:
	cmp rax, [rsp + 56]
	jl .jump195
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump195:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump196
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'a'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const92] ; 315
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump198
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump198:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump199: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const93] ; 987
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump199 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump200
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump200:
	; Computing bound for 'c'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const94] ; 391
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump201
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump201:
	; Computing bound for 'a'
	mov rax, [rel const95] ; 957
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump202
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump202:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 957 
	jno .jump203
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump203:
	imul rdi, [rsp + 0 + 8] ; multiply by 391 
	jno .jump204
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump204:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump205: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const96] ; 563
	push rax
	mov rax, [rel const97] ; 268
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump205 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump205 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const98] ; 482
	push rax
	mov rax, [rel const99] ; 579
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump206
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump206:
	cmp rax, [rsp + 16]
	jl .jump207
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump207:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump208
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump208:
	cmp rax, [rsp + 24]
	jl .jump209
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump209:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump210
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump210:
	; Computing bound for 'b'
	mov rax, [rel const42] ; 396
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump211
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump211:
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const100] ; 975
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump212
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump212:
	; Computing bound for 'b'
	mov rax, [rel const101] ; 189
	push rax
	mov rax, [rel const102] ; 177
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump213
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump213:
	; Computing bound for 'a'
	mov rax, [rel const103] ; 439
	push rax
	mov rax, [rel const104] ; 105
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump214
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump214:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump215
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump215:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump216: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump216 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump216 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump216 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump217
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump217:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[a : (105 / 439), b : ((- 177) + 189), c : 975] b) 
	jno .jump218
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump218:
	imul rdi, [rsp + 0 + 8] ; multiply by 396 
	jno .jump219
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump219:
imul rdi, [rsp + 0 + 16] ; multiply by (array[a : 957, b : 391] (268 - 563))[(- (- 579)), 482] 
	jno .jump220
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump220:
imul rdi, [rsp + 0 + 24] ; multiply by (- (sum[a : (- 315)] 987)) 
	jno .jump221
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump221:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump222: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump223
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump223:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump224
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump224:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump225: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump225 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump225 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump226
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump226:
	; Computing bound for 'g'
	mov rax, [rel const105] ; 51
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump227
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump227:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump228
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump228:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump229
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump229:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump230: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump230 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump230 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump230 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump230 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump222 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump222 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump222 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump222 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump231
	mov rax, [rel const2] ; True
	push rax
	mov rax, [rel const5] ; False
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
.jump231:
	push rax
	pop rax
	cmp rax, 0
	je .jump232
	mov rax, [rel const106] ; 751
	push rax
	jmp .jump233
.jump232:
	mov rax, [rel const107] ; 827
	push rax
	mov rax, [rel const45] ; 996
	push rax
	mov rax, [rel const108] ; 884
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump234
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
.jump234:
	cqo
	idiv r10
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
.jump233:
	mov rax, [rel const109] ; 116
	push rax
	mov rax, [rel const110] ; 27.53
	push rax
	mov rax, [rel const111] ; 22.09
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump235
	mov rax, [rel const5] ; False
	push rax
	pop rax
.jump235:
	push rax
	pop rax
	cmp rax, 0
	je .jump236
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const112] ; 133
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump238
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump238:
	; Computing bound for 'b'
	mov rax, [rel const59] ; 392
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const113] ; 46
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump239
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump239:
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const29] ; 310
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump240
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump240:
	; Computing bound for 'b'
	mov rax, [rel const114] ; 270
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump241
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump241:
	; Computing bound for 'a'
	mov rax, [rel const115] ; 523
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump242
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump242:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump243: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump243 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump243 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump243 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump244
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump244:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump245: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump245 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump245 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump245 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump237
.jump236:
	mov rax, [rel const116] ; 534
	push rax
	mov rax, [rel const117] ; 811
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
.jump237:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const118] ; 377
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump246
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump246:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump247: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump247 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const119] ; 119
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const120] ; 664
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump248
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump248:
	cmp rax, [rsp + 32]
	jl .jump249
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump249:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump250
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump250:
	cmp rax, [rsp + 40]
	jl .jump251
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump251:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump252
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump252:
	cmp rax, [rsp + 48]
	jl .jump253
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump253:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump254
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump254:
	cmp rax, [rsp + 56]
	jl .jump255
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump255:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump256
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump256:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
imul rdi, [rsp + 0 + 0] ; multiply by (array[a : (sum[a : (105 / 439), b : ((- 177) + 189), c : 975] b), b : 396, c : (array[a : 957, b : 391] (268 - 563))[(- (- 579)), 482], d : (- (sum[a : (- 315)] 987))] (- (sum[e : b, f : a, g : 51, h : (sum[e : d, f : c] a)] d)))[(664 - (119 + (sum[a : 377] a))), (if ((22.09 <= 27.53) || false) then (sum[a : (sum[a : 523, b : 270, c : 310] a), b : ((- 46) + (- 392)), c : (- 133)] b) else (- ((- 811) * 534))), 116, (if (false && (false != true)) then 751 else (- ((884 / 996) * 827)))] 
	jno .jump257
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump257:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump258: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const121] ; 891
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump259
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump259:
	; Computing bound for 'b'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const122] ; 256
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump260
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump260:
	; Computing bound for 'c'
	mov rax, [rel const123] ; 132
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump261
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump261:
	; Computing bound for 'b'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump262
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump262:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by a 
	jno .jump263
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump263:
	imul rdi, [rsp + 0 + 8] ; multiply by 132 
	jno .jump264
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump264:
	imul rdi, [rsp + 0 + 16] ; multiply by 256 
	jno .jump265
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump265:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump266: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const2] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 16], 1
	; Compare d to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump266 ; If d < bound, next iter
	mov qword [rsp + 16], 0 ; d = 0
	add qword [rsp + 8], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump266 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump266 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const124] ; 229
	push rax
	mov rax, [rel const125] ; 939
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const126] ; 525
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump267
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
.jump267:
	cqo
	idiv r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump268
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump268:
	cmp rax, [rsp + 24]
	jl .jump269
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump269:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump270
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump270:
	cmp rax, [rsp + 32]
	jl .jump271
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump271:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump272
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump272:
	cmp rax, [rsp + 40]
	jl .jump273
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump273:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump274
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const127] ; 68
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump276
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump276:
	; Computing bound for 'd'
	mov rax, [rel const128] ; 853
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump277
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump277:
	; Computing bound for 'c'
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump278
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump279
.jump278:
	mov rax, [rel const129] ; 70
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump280
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump280:
	cqo
	idiv r10
	push rax
.jump279:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump281
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump281:
	; Computing bound for 'b'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump282
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump282:
	; Computing bound for 'd'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const130] ; 25
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump283
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump283:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump284: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump284 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump285
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump285:
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump286
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump286:
	; Computing bound for 'b'
	mov rax, [rel const131] ; 716
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump287
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump287:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump288: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 24], 1
	; Compare e to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump288 ; If e < bound, next iter
	mov qword [rsp + 24], 0 ; e = 0
	add qword [rsp + 16], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump288 ; If d < bound, next iter
	mov qword [rsp + 16], 0 ; d = 0
	add qword [rsp + 8], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump288 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump288 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump289
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump289:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump290: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 24], 1
	; Compare e to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump290 ; If e < bound, next iter
	mov qword [rsp + 24], 0 ; e = 0
	add qword [rsp + 16], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump290 ; If d < bound, next iter
	mov qword [rsp + 16], 0 ; d = 0
	add qword [rsp + 8], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump290 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump290 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	jmp .jump275
.jump274:
	mov rax, [rel const132] ; 16.39
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const133] ; 28.0
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump291
	mov rax, [rel const64] ; 159
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump292
.jump291:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump292:
.jump275:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump293
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump293:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
imul rdi, [rsp + 0 + 0] ; multiply by (if (array[b : a, c : 132, d : 256] true)[((- a) / a), (- 525), (- (939 - 229))] then (sum[b : (sum[b : 716, c : (a + a), d : (sum[b : 25] b), e : (- a)] e), c : (if true then a else (a / 70)), d : (- 853), e : (68 - a)] (- b)) else (if ((- 28.0) < (- 16.39)) then (- 159) else a)) 
	jno .jump294
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump294:
	imul rdi, [rsp + 0 + 8] ; multiply by 891 
	jno .jump295
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump295:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump296: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const134] ; 29.35
	push rax
	mov rax, [rel const135] ; 7.85
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const136] ; 72.46
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump297
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump297:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump298
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump298:
	; Computing bound for 'e'
	mov rax, [rel const137] ; 917
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump299
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump299:
	; Computing bound for 'd'
	mov rax, [rel const11] ; 436
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump300
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump300:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump301: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const138] ; 42.51
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump301 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump301 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump301 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump301 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const139] ; 39.91
	push rax
	mov rax, [rel const140] ; 39.27
	push rax
	mov rax, [rel const141] ; 33.36
	push rax
	mov rax, [rel const142] ; 76.02
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const143] ; 71.66
	push rax
	mov rax, [rel const144] ; 25.14
	push rax
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump302
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump302:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump303
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump303:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump304
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump304:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump305: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump306
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump306:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump307: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const145] ; 62.94
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump307 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump305 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump305 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump305 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'c'
	add qword [rsp + 8], 1
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump296 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump296 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump258 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump197
.jump196:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump308
	mov rax, [rel const2] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump309
.jump308:
	mov rax, [rel const5] ; False
	push rax
.jump309:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump310
	mov rax, [rel const5] ; False
	push rax
	pop rax
.jump310:
	push rax
	pop rax
	cmp rax, 0
	je .jump311
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump313
	mov rax, [rel const146] ; 956
	push rax
	jmp .jump314
.jump313:
	mov rax, [rel const147] ; 674
	push rax
.jump314:
	jmp .jump312
.jump311:
	mov rax, [rel const148] ; 213
	push rax
.jump312:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump315
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump315:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if ((! (if false then (! true) else false)) || false) then (if false then 956 else 674) else 213) 
	jno .jump316
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump316:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump317: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump318
	mov rax, [rel const2] ; True
	push rax
	jmp .jump319
.jump318:
	mov rax, [rel const5] ; False
	push rax
.jump319:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump320
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const149] ; 689
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump322
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump322:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump323: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump323 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	jmp .jump321
.jump320:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump324
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
.jump324:
	cqo
	idiv r10
	mov rax, rdx
	push rax
.jump321:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump325
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump325:
	; Computing bound for 'c'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'b'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const95] ; 957
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump326
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump326:
	; Computing bound for 'b'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump327
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump327:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump328: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 8], 1
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump328 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump328 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump329
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump329:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[b : a, c : 957] c) 
	jno .jump330
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump330:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump331: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump331 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const150] ; 548
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump332
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump332:
	cmp rax, [rsp + 8]
	jl .jump333
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump333:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump334
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump334:
	; Computing bound for 'b'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const151] ; 814
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump335
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump335:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump336: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump337
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump337:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump338
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump338:
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump339
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump339:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump340: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const24] ; 411
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 16], 1
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump340 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump340 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump340 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump336 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump341
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump341:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump342: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 16], 1
	; Compare d to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump342 ; If d < bound, next iter
	mov qword [rsp + 16], 0 ; d = 0
	add qword [rsp + 8], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump342 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump342 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump343
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump343:
	; Computing bound for 'b'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const152] ; 83
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump344
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump344:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump345
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump345:
	; Computing bound for 'c'
	mov rax, [rel const153] ; 705
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump346
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump346:
	; Computing bound for 'b'
	mov rax, [rel const154] ; 215
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump347
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump347:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 215) 
	jno .jump348
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump348:
	imul rdi, [rsp + 0 + 8] ; multiply by 705 
	jno .jump349
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump349:
	imul rdi, [rsp + 0 + 16] ; multiply by a 
	jno .jump350
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump350:
	imul rdi, [rsp + 0 + 24] ; multiply by 83 
	jno .jump351
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump351:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump352: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 24], 1
	; Compare e to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump352 ; If e < bound, next iter
	mov qword [rsp + 24], 0 ; e = 0
	add qword [rsp + 16], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump352 ; If d < bound, next iter
	mov qword [rsp + 16], 0 ; d = 0
	add qword [rsp + 8], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump352 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump352 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const155] ; 153
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump353
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump353:
	cqo
	idiv r10
	push rax
	mov rax, [rel const156] ; 597
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const157] ; 924
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump354
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump354:
	cmp rax, [rsp + 32]
	jl .jump355
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump355:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump356
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump356:
	cmp rax, [rsp + 40]
	jl .jump357
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump357:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump358
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump358:
	cmp rax, [rsp + 48]
	jl .jump359
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump359:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump360
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump360:
	cmp rax, [rsp + 56]
	jl .jump361
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump361:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump362
	mov rax, [rel const2] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump364
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump365
.jump364:
	mov rax, [rel const95] ; 957
	push rax
	mov rax, [rel const158] ; 351
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const159] ; 23
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump366
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
.jump366:
	cqo
	idiv r10
	mov rax, rdx
	push rax
.jump365:
	jmp .jump363
.jump362:
	mov rax, [rel const160] ; 63.61
	push rax
	mov rax, [rel const161] ; 43.46
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump367
	mov rax, [rel const162] ; 489
	push rax
	jmp .jump368
.jump367:
	mov rax, [rel const163] ; 319
	push rax
	mov rax, [rel const164] ; 911
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
.jump368:
.jump363:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump369
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump369:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
imul rdi, [rsp + 0 + 0] ; multiply by (if (array[b : (- 215), c : 705, d : a, e : 83] (e != b))[a, 924, a, ((- 597) - (153 / a))] then (if (! true) then (- a) else (23 % (351 + 957))) else (if (! (43.46 <= 63.61)) then 489 else (911 + 319))) 
	jno .jump370
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump370:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[b : (- (sum[b : 814] (sum[c : a, d : b, e : b] 411))), c : (array[b : (sum[b : a, c : 957] c)] (- a))[548], d : (if (! (if true then true else false)) then (- (sum[b : 689] a)) else (a % a))] a) 
	jno .jump371
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump371:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump372: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const53] ; 715
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump373
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump373:
	; Computing bound for 'f'
	mov rax, [rel const165] ; 323
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump374
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump374:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump375
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump375:
	; Computing bound for 'd'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump376
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump376:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump377
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump377:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump378: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump378 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump378 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump379
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump379:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump380: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const166] ; 293
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump380 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump380 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump380 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump380 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump381
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump381:
	; Computing bound for 'f'
	mov rax, [rel const167] ; 873
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump382
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump382:
	; Computing bound for 'e'
	mov rax, [rel const168] ; 521
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump383
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump383:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump384
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump384:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump385: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const169] ; 451
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump386
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump386:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump387
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump387:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump388
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump388:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump389
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump389:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump390: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const170] ; 77.41
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump390 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump390 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump390 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump390 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump385 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump385 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump385 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump385 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump391
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump391:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump392
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump392:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump393
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump393:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump394: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const171] ; 342
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump394 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump394 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump394 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump395
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump395:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump396: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump397
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump397:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump398
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump398:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump399
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump399:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump400
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump400:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump401
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump401:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump402
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump402:
	imul rdi, [rsp + 0 + 16] ; multiply by a 
	jno .jump403
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump403:
	imul rdi, [rsp + 0 + 24] ; multiply by a 
	jno .jump404
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump404:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump405: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const170] ; 77.41
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump405 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump405 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump405 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump405 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const172] ; 661
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump406
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump406:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump407: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump407 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const156] ; 597
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump408
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump408:
	cmp rax, [rsp + 32]
	jl .jump409
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump409:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump410
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump410:
	cmp rax, [rsp + 40]
	jl .jump411
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump411:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump412
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump412:
	cmp rax, [rsp + 48]
	jl .jump413
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump413:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump414
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump414:
	cmp rax, [rsp + 56]
	jl .jump415
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump415:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump396 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const173] ; 75.89
	push rax
	mov rax, [rel const174] ; 26.71
	push rax
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const175] ; 12
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump416
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump416:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump417
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump417:
	; Computing bound for 'f'
	mov rax, [rel const3] ; 69
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump418
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump418:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump419
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump419:
	; Computing bound for 'd'
	mov rax, [rel const176] ; 985
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump420
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump420:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump421: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump421 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump421 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump421 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump421 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump422
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump422:
	; Computing bound for 'e'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump423
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump423:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump424
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump424:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump425
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump425:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump426: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const65] ; 490
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump426 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump426 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump426 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump427
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump427:
	; Computing bound for 'd'
	mov rax, [rel const177] ; 284
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump428
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump428:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump429: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump429 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump429 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump429 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump429 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump430
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump430:
	cmp rax, [rsp + 8]
	jl .jump431
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump431:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const178] ; 70.16
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'c'
	add qword [rsp + 8], 1
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump372 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump372 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump317 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump197:
	mov rax, [rel const24] ; 411
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const123] ; 132
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump432
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump432:
	; Computing bound for 'a'
	mov rax, [rel const179] ; 253
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump433
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump433:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump434: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump434 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump434 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump435
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump435:
	cmp rax, [rsp + 8]
	jl .jump436
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump436:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	lea rdi, [rel const180] ; 'a.png'
	call _write_image
	add rsp, 24
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump437
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump439
	mov rax, [rel const2] ; True
	push rax
	pop rax
.jump439:
	push rax
	pop rax
	cmp rax, 0
	je .jump440
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const181] ; 992
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump442
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump442:
	; Computing bound for 'b'
	mov rax, [rel const182] ; 847
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump443
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump443:
	; Computing bound for 'a'
	mov rax, [rel const183] ; 805
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump444
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump444:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 805 
	jno .jump445
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump445:
	imul rdi, [rsp + 0 + 8] ; multiply by 847 
	jno .jump446
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump446:
	imul rdi, [rsp + 0 + 16] ; multiply by 992 
	jno .jump447
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump447:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump448: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump449
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump449:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump450
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump450:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump451
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump451:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump452
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump452:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by a 
	jno .jump453
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump453:
	imul rdi, [rsp + 0 + 8] ; multiply by a 
	jno .jump454
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump454:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump455
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump455:
	imul rdi, [rsp + 0 + 24] ; multiply by a 
	jno .jump456
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump456:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump457: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump457 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump457 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump457 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump457 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump448 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump448 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump448 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump441
.jump440:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const184] ; 442
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump458
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump458:
	; Computing bound for 'b'
	mov rax, [rel const185] ; 232
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump459
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump459:
	; Computing bound for 'a'
	mov rax, [rel const186] ; 907
	push rax
	mov rax, [rel const187] ; 620
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump460
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump460:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump461
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump461:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (620 % 907) 
	jno .jump462
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump462:
	imul rdi, [rsp + 0 + 8] ; multiply by 232 
	jno .jump463
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump463:
	imul rdi, [rsp + 0 + 16] ; multiply by 442 
	jno .jump464
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump464:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump465: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump466
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump466:
	; Computing bound for 'f'
	mov rax, [rel const188] ; 201
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump467
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump467:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump468
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump468:
	; Computing bound for 'd'
	mov rax, [rel const189] ; 158
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump469
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump469:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 158 
	jno .jump470
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump470:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump471
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump471:
	imul rdi, [rsp + 0 + 16] ; multiply by 201 
	jno .jump472
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump472:
	imul rdi, [rsp + 0 + 24] ; multiply by c 
	jno .jump473
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump473:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump474: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump474 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump474 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump474 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump474 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump465 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump465 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump465 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump441:
	mov rax, [rel const115] ; 523
	push rax
	mov rax, [rel const190] ; 309
	push rax
	mov rax, [rel const191] ; 681
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rel const192] ; 65
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const164] ; 911
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump475
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump475:
	cmp rax, [rsp + 24]
	jl .jump476
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump476:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump477
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump477:
	cmp rax, [rsp + 32]
	jl .jump478
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump478:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump479
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump479:
	cmp rax, [rsp + 40]
	jl .jump480
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump480:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump438
.jump437:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const193] ; 777
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump481
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump481:
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const194] ; 299
	push rax
	mov rax, [rel const195] ; 147
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump482
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump482:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump483
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump483:
	; Computing bound for 'b'
	mov rax, [rel const196] ; 322
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump484
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump484:
	; Computing bound for 'a'
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump485
	mov rax, [rel const5] ; False
	push rax
	jmp .jump486
.jump485:
	mov rax, [rel const2] ; True
	push rax
.jump486:
	pop rax
	cmp rax, 0
	je .jump487
	mov rax, [rel const197] ; 630
	push rax
	mov rax, [rel const198] ; 970
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump489
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump489:
	cqo
	idiv r10
	push rax
	jmp .jump488
.jump487:
	mov rax, [rel const199] ; 34
	push rax
	pop rax
	neg rax
	push rax
.jump488:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump490
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump490:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump491: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const200] ; 166
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump491 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump491 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump491 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump492
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump492:
	; Computing bound for 'b'
	mov rax, [rel const201] ; 909
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump493
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump493:
	; Computing bound for 'a'
	mov rax, [rel const167] ; 873
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const67] ; 21
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump494
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
.jump494:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump495
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump495:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (21 % (- 873)) 
	jno .jump496
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump496:
	imul rdi, [rsp + 0 + 8] ; multiply by 909 
	jno .jump497
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump497:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[a : (if (if false then false else true) then (970 / 630) else (- 34)), b : (- (- 322)), c : ((- 147) % 299)] 166) 
	jno .jump498
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump498:
	imul rdi, [rsp + 0 + 24] ; multiply by (- (- 777)) 
	jno .jump499
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump499:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump500: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump501
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump501:
	; Computing bound for 'f'
	mov rax, [rel const202] ; 815
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump502
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump502:
	; Computing bound for 'g'
	mov rax, [rel const24] ; 411
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump503
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump503:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump504
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump504:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump505
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump505:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump506: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump506 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump506 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump506 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump506 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump507
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump507:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump508
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump508:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const203] ; 654
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump509
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
.jump509:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump510
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump510:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump511: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump511 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump511 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump511 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump500 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump500 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump500 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump500 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump438:
	mov rax, [rel const204] ; 665
	push rax
	mov rax, [rel const205] ; 161
	push rax
	mov rax, [rel const206] ; 878
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump512
	mov rax, [rel const207] ; 583
	push rax
	jmp .jump513
.jump512:
	mov rax, [rel const208] ; 53.47
	push rax
	mov rax, [rel const209] ; 74.75
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump514
	mov rax, [rel const210] ; 785
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump515
.jump514:
	mov rax, [rel const211] ; 222
	push rax
	pop rax
	neg rax
	push rax
.jump515:
.jump513:
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump516
	mov rax, [rel const212] ; 318
	push rax
	jmp .jump517
.jump516:
	mov rax, [rel const213] ; 128
	push rax
.jump517:
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump518
	mov rax, [rel const214] ; 503
	push rax
	jmp .jump519
.jump518:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const215] ; 398
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump520
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump520:
	; Computing bound for 'a'
	mov rax, [rel const216] ; 136
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump521
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump521:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump522: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const217] ; 679
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump522 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump522 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump519:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump523
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump523:
	; Computing bound for 'b'
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump524
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump526
	mov rax, [rel const218] ; 241
	push rax
	jmp .jump527
.jump526:
	mov rax, [rel const219] ; 445
	push rax
.jump527:
	jmp .jump525
.jump524:
	mov rax, [rel const220] ; 198
	push rax
	pop rax
	neg rax
	push rax
.jump525:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump528
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump528:
	; Computing bound for 'a'
	mov rax, [rel const221] ; 914
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const222] ; 576
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump529
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump529:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump530: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump530 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump530 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump530 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump531
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump531:
	; Computing bound for 'c'
	mov rax, [rel const223] ; 93
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const2] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump532
	mov rax, [rel const224] ; 64
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump533
.jump532:
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump534
	mov rax, [rel const65] ; 490
	push rax
	jmp .jump535
.jump534:
	mov rax, [rel const225] ; 686
	push rax
.jump535:
.jump533:
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump536
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump536:
	; Computing bound for 'b'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const226] ; 226
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump537
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump537:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump538: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const227] ; 892
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump538 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump539
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump539:
	; Computing bound for 'a'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const228] ; 96
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump540
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump540:
	; Computing bound for 'b'
	mov rax, [rel const229] ; 472
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump541
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump541:
	; Computing bound for 'a'
	mov rax, [rel const230] ; 468
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump542
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump542:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 468 
	jno .jump543
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump543:
	imul rdi, [rsp + 0 + 8] ; multiply by 472 
	jno .jump544
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump544:
	imul rdi, [rsp + 0 + 16] ; multiply by 96 
	jno .jump545
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump545:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump546: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump546 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump546 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump546 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const231] ; 593
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const232] ; 409
	push rax
	mov rax, [rel const233] ; 308
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump547
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump547:
	; Computing bound for 'a'
	mov rax, [rel const234] ; 317
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump548
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump548:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump549: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump549 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump549 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const235] ; 353
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump550
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump550:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump551: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const236] ; 967
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump551 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const237] ; 511
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump552
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump552:
	cmp rax, [rsp + 24]
	jl .jump553
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump553:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump554
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump554:
	cmp rax, [rsp + 32]
	jl .jump555
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump555:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump556
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump556:
	cmp rax, [rsp + 40]
	jl .jump557
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump557:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump558
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump558:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (array[a : 468, b : 472, c : 96] c)[(511 + (sum[a : 353] 967)), (sum[a : 317, b : (308 - 409)] b), (- 593)] 
	jno .jump559
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump559:
imul rdi, [rsp + 0 + 8] ; multiply by (- (- (sum[a : 226] 892))) 
	jno .jump560
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump560:
	imul rdi, [rsp + 0 + 16] ; multiply by ((if (! true) then (- 64) else (if true then 490 else 686)) - (- (- 93))) 
	jno .jump561
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump561:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[a : (576 * (- 914)), b : (if true then (if true then 241 else 445) else (- 198)), c : (if false then 503 else (sum[a : 136, b : 398] 679))] b) 
	jno .jump562
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump562:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump563: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump563 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump563 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump563 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump563 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const238] ; 918
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const239] ; 845
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump564
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump564:
	; Computing bound for 'b'
	mov rax, [rel const240] ; 36
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump565
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump565:
	; Computing bound for 'a'
	mov rax, [rel const241] ; 983
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump566
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump566:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump567: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump567 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump567 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump567 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump568
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump568:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump569: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump570
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump570:
	; Computing bound for 'c'
	mov rax, [rel const242] ; 29
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump571
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump571:
	; Computing bound for 'b'
	mov rax, [rel const243] ; 649
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump572
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump572:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 649 
	jno .jump573
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump573:
	imul rdi, [rsp + 0 + 8] ; multiply by 29 
	jno .jump574
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump574:
	imul rdi, [rsp + 0 + 16] ; multiply by a 
	jno .jump575
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump575:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump576: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 16], 1
	; Compare d to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump576 ; If d < bound, next iter
	mov qword [rsp + 16], 0 ; d = 0
	add qword [rsp + 8], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump576 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump576 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const244] ; 603
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump577
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump577:
	cmp rax, [rsp + 24]
	jl .jump578
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump578:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump579
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump579:
	cmp rax, [rsp + 32]
	jl .jump580
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump580:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump581
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump581:
	cmp rax, [rsp + 40]
	jl .jump582
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump582:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump583
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump583:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump584: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const5] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump585
	mov rax, [rel const245] ; 698
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump586
.jump585:
	mov rax, [rel const246] ; 948
	push rax
.jump586:
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump584 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump569 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const247] ; 767
	push rax
	mov rax, [rel const248] ; 227
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump587
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump587:
	; Computing bound for 'c'
	mov rax, [rel const163] ; 319
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump588
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump588:
	; Computing bound for 'b'
	mov rax, [rel const249] ; 692
	push rax
	mov rax, [rel const222] ; 576
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump589
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
.jump589:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump590
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump590:
	; Computing bound for 'a'
	mov rax, [rel const250] ; 706
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump591
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump591:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 706) 
	jno .jump592
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump592:
	imul rdi, [rsp + 0 + 8] ; multiply by (576 / 692) 
	jno .jump593
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump593:
	imul rdi, [rsp + 0 + 16] ; multiply by (- 319) 
	jno .jump594
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump594:
	imul rdi, [rsp + 0 + 24] ; multiply by (- (227 + 767)) 
	jno .jump595
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump595:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump596: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump596 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump596 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump596 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump596 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const251] ; 691
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const252] ; 832
	push rax
	mov rax, [rel const253] ; 405
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump597
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
.jump597:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rel const106] ; 751
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump598
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump598:
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const196] ; 322
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump599
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump599:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump600: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump600 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump601
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump601:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump602: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump603
	mov rax, [rel const254] ; 881
	push rax
	jmp .jump604
.jump603:
	mov rax, [rel const255] ; 816
	push rax
.jump604:
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump602 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump602 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const256] ; 600
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const62] ; 112
	push rax
	mov rax, [rel const81] ; 170
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump605
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
.jump605:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump606
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump606:
	; Computing bound for 'a'
	mov rax, [rel const257] ; 280
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump607
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump607:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump608: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump609
	mov rax, [rel const258] ; 554
	push rax
	jmp .jump610
.jump609:
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
.jump610:
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump611
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
.jump611:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump608 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump608 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump612
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump612:
	cmp rax, [rsp + 32]
	jl .jump613
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump613:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump614
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump614:
	cmp rax, [rsp + 40]
	jl .jump615
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump615:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump616
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump616:
	cmp rax, [rsp + 48]
	jl .jump617
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump617:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump618
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump618:
	cmp rax, [rsp + 56]
	jl .jump619
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump619:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const259] ; 754
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump620
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump620:
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const118] ; 377
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump621
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump621:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump622: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const179] ; 253
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump622 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump623
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump623:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump624: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const226] ; 226
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump625
	mov rax, [rel const260] ; 514
	push rax
	jmp .jump626
.jump625:
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
.jump626:
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump624 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump624 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump627
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump627:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump628: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump629
	mov rax, [rel const196] ; 322
	push rax
	jmp .jump630
.jump629:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump631
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump631:
	; Computing bound for 'b'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump632
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump632:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by a 
	jno .jump633
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump633:
	imul rdi, [rsp + 0 + 8] ; multiply by a 
	jno .jump634
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump634:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump635: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'c'
	add qword [rsp + 8], 1
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump635 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump635 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump636
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump636:
	cmp rax, [rsp + 16]
	jl .jump637
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump637:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump638
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump638:
	cmp rax, [rsp + 24]
	jl .jump639
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump639:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump630:
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump628 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const261] ; 851
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump640
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump640:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump641: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump641 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump642
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump642:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump643: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const262] ; 520
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump643 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump644
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump644:
	cmp rax, [rsp + 32]
	jl .jump645
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump645:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump646
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump646:
	cmp rax, [rsp + 40]
	jl .jump647
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump647:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump648
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump648:
	cmp rax, [rsp + 48]
	jl .jump649
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump649:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump650
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump650:
	cmp rax, [rsp + 56]
	jl .jump651
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump651:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const190] ; 309
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump652
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump652:
	cmp rax, [rsp + 32]
	jl .jump653
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump653:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump654
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump654:
	cmp rax, [rsp + 40]
	jl .jump655
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump655:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump656
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump656:
	cmp rax, [rsp + 48]
	jl .jump657
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump657:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump658
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump658:
	cmp rax, [rsp + 56]
	jl .jump659
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump659:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump660
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump660:
	; Computing bound for 'b'
	mov rax, [rel const225] ; 686
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump661
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump661:
	; Computing bound for 'a'
	mov rax, [rel const263] ; 581
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump662
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump662:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 581 
	jno .jump663
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump663:
	imul rdi, [rsp + 0 + 8] ; multiply by (- (- 686)) 
	jno .jump664
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump664:
imul rdi, [rsp + 0 + 16] ; multiply by (- (if true then (if (true || true) then (array[a : 805, b : 847, c : 992] (array[d : a, e : a, f : b, g : a] a)) else (array[a : (620 % 907), b : 232, c : 442] (array[d : 158, e : b, f : 201, g : c] d)))[911, ((- 65) + ((- 681) * 309)), 523] else (array[a : (21 % (- 873)), b : 909, c : (sum[a : (if (if false then false else true) then (970 / 630) else (- 34)), b : (- (- 322)), c : ((- 147) % 299)] 166), d : (- (- 777))] (sum[e : (- (654 % b)), f : ((sum[e : b, f : b, g : 411, h : c] b) % 815), g : a] c)))[309, (array[a : (array[a : 468, b : 472, c : 96] c)[(511 + (sum[a : 353] 967)), (sum[a : 317, b : (308 - 409)] b), (- 593)], b : (- (- (sum[a : 226] 892))), c : ((if (! true) then (- 64) else (if true then 490 else 686)) - (- (- 93))), d : (sum[a : (576 * (- 914)), b : (if true then (if true then 241 else 445) else (- 198)), c : (if false then 503 else (sum[a : 136, b : 398] 679))] b)] c)[(- (sum[a : (sum[a : (- 851)] a)] 520)), (sum[a : (sum[a : (sum[a : 377] (- 253)), b : 754] (if (226 > a) then 514 else (a * a)))] (if true then 322 else (array[b : a, c : a] c)[a, (- a)])), (array[a : (- 706), b : (576 / 692), c : (- 319), d : (- (227 + 767))] d)[(sum[a : 280, b : (170 % 112)] (b % (if false then 554 else a))), (- 600), (sum[a : (sum[a : 322] (- a)), b : (751 + (405 % 832))] (if false then 881 else 816)), 691], (sum[a : ((sum[a : 983, b : 36, c : (- 845)] (- a)) + 918)] (sum[b : (array[b : 649, c : 29, d : a] d)[(- a), a, 603]] (if (! false) then (- 698) else 948)))], (- ((if true then 318 else 128) + (if (878 > 161) then 583 else (if (74.75 < 53.47) then (- 785) else (- 222))))), 665]) 
	jno .jump665
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump665:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump666: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump667
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump667:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump668
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump668:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump669
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump669:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump670: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump670 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump670 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump671
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump671:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump672
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump672:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump673
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump673:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump674
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump674:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump675
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump675:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[d : b, e : b] a) 
	jno .jump676
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump676:
	imul rdi, [rsp + 0 + 24] ; multiply by b 
	jno .jump677
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump677:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump678: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump678 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump678 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump678 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump678 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump679
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump679:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump680
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump680:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump681: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump681 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump681 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const264] ; 302
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump682
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump682:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump683
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump683:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump684: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump684 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump684 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump685
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump685:
	cmp rax, [rsp + 32]
	jl .jump686
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump686:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump687
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump687:
	cmp rax, [rsp + 40]
	jl .jump688
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump688:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump689
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump689:
	cmp rax, [rsp + 48]
	jl .jump690
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump690:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump691
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump691:
	cmp rax, [rsp + 56]
	jl .jump692
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump692:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump693
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump693:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump694
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump694:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump695
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump695:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump696
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump696:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by a 
	jno .jump697
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump697:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump698
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump698:
	imul rdi, [rsp + 0 + 16] ; multiply by (- a) 
	jno .jump699
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump699:
imul rdi, [rsp + 0 + 24] ; multiply by (array[d : c, e : c, f : (sum[d : b, e : b] a), g : b] d)[c, (sum[d : b, e : 302] a), c, (sum[d : c, e : c] (- e))] 
	jno .jump700
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump700:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump701: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump702
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump702:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump703
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump703:
	; Computing bound for 'i'
	mov rax, [rel const265] ; 998
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump704
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump704:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump705
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump705:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump706: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const266] ; 16.65
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump706 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump706 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump706 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump706 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump707
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump707:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump708
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump708:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump709
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump709:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump710
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump710:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump711: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const267] ; 46.45
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump711 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump711 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump711 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump711 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump712
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	jmp .jump713
.jump712:
	mov rax, [rel const5] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
.jump713:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump701 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump701 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump701 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump701 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const268] ; 743
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rel const269] ; 234
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const270] ; 629
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump714
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump714:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump715
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump715:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump716: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const271] ; 438
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump716 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump716 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump717
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump717:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const272] ; 40
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump718
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump718:
	cmp rax, [rsp + 32]
	jl .jump719
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump719:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump720
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump720:
	cmp rax, [rsp + 40]
	jl .jump721
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump721:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump722
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump722:
	cmp rax, [rsp + 48]
	jl .jump723
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump723:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump724
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump724:
	cmp rax, [rsp + 56]
	jl .jump725
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump725:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump726
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump728
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump728:
	; Computing bound for 'e'
	mov rax, [rel const273] ; 988
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump729
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump729:
	; Computing bound for 'd'
	mov rax, [rel const274] ; 559
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump730
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump730:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 559 
	jno .jump731
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump731:
	imul rdi, [rsp + 0 + 8] ; multiply by 988 
	jno .jump732
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump732:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump733
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump733:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump734: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const2] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump734 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump734 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump734 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const16] ; 331
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump735
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump735:
	; Computing bound for 'd'
	mov rax, [rel const275] ; 286
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump736
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump736:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump737: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump737 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump737 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump738
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump738:
	cmp rax, [rsp + 24]
	jl .jump739
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump739:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump740
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump740:
	cmp rax, [rsp + 32]
	jl .jump741
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump741:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump742
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump742:
	cmp rax, [rsp + 40]
	jl .jump743
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump743:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump744
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump745
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump745:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump746: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump746 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump747
	mov rax, [rel const5] ; False
	push rax
	pop rax
.jump747:
	push rax
	pop rax
	cmp rax, 0
	je .jump748
	mov rax, [rel const5] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump749
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump750
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump750:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump751
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump751:
	; Computing bound for 'd'
	mov rax, [rel const276] ; 263
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump752
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump752:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump753: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump753 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump753 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump753 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
.jump749:
	push rax
	pop rax
.jump748:
	push rax
	pop rax
.jump744:
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump727
.jump726:
	mov rax, [rel const5] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump754
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump754:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump755: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump755 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	mov rax, [rel const5] ; False
	push rax
	mov rax, [rel const5] ; False
	push rax
	mov rax, [rel const277] ; 88.03
	push rax
	mov rax, [rel const278] ; 26.25
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump756
	mov rax, [rel const5] ; False
	push rax
	jmp .jump757
.jump756:
	mov rax, [rel const5] ; False
	push rax
.jump757:
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump758
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump758:
	cmp rax, [rsp + 8]
	jl .jump759
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump759:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
.jump727:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump666 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump666 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump666 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 32
	; Moving 32 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _get_time
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1225
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1226
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1226:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1227
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1227:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1228
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1228:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump1229
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1229:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump1230
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1230:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump1231
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1231:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1232: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1232 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1232 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1232 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const319] ; 541
	push rax
	mov rax, [rel const225] ; 686
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const320] ; 459
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1233
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1233:
	cmp rax, [rsp + 24]
	jl .jump1234
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1234:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1235
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1235:
	cmp rax, [rsp + 32]
	jl .jump1236
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1236:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1237
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1237:
	cmp rax, [rsp + 40]
	jl .jump1238
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1238:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const321] ; 935
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
.jump1225:
	push rax
	pop rax
	cmp rax, 0
	je .jump1239
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1241
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1241:
	; Computing bound for 'h'
	mov rax, [rel const70] ; 125
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1242
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1242:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1243
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1243:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- d) 
	jno .jump1244
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1244:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 125) 
	jno .jump1245
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1245:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump1246
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1246:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1247: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1248
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1248:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1249
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1249:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump1250
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1250:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump1251
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1251:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1252: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1252 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1252 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1247 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1247 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1247 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const322] ; 487
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1253
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1253:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1254: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1254 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1255
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1255:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1256
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1256:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1257
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1257:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1258
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1258:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1259: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1259 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1259 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1259 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1259 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1260
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1260:
	cmp rax, [rsp + 24]
	jl .jump1261
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1261:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1262
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1262:
	cmp rax, [rsp + 32]
	jl .jump1263
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1263:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1264
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1264:
	cmp rax, [rsp + 40]
	jl .jump1265
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1265:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump1266
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump1267
.jump1266:
	mov rax, [rel const214] ; 503
	push rax
.jump1267:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1268
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1268:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if f() then d else 503) 
	jno .jump1269
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1269:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1270: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const323] ; 846
	push rax
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1270 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1271
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1271:
	cmp rax, [rsp + 8]
	jl .jump1272
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1272:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const324] ; 185
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1273
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1273:
	cmp rax, [rsp + 16]
	jl .jump1274
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1274:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1275
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1275:
	cmp rax, [rsp + 24]
	jl .jump1276
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1276:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1277
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1277:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1278
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1278:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1279
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1279:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1280
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1280:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump1281
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1281:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump1282
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1282:
	imul rdi, [rsp + 0 + 16] ; multiply by c 
	jno .jump1283
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1283:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1284: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const325] ; 739
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1284 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1284 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1284 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const326] ; 272
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1285
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
.jump1285:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1286
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1286:
	cqo
	idiv r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1287
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1287:
	cmp rax, [rsp + 24]
	jl .jump1288
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1288:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1289
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1289:
	cmp rax, [rsp + 32]
	jl .jump1290
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1290:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1291
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1291:
	cmp rax, [rsp + 40]
	jl .jump1292
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1292:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1293
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1293:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1294
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1294:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1295: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump1296
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	jmp .jump1297
.jump1296:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump1297:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1298
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1298:
	; Computing bound for 'k'
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1299
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump1300
.jump1299:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump1300:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1301
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1301:
	; Computing bound for 'j'
	mov rax, [rel const327] ; 817
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1302
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1302:
	; Computing bound for 'i'
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1303
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	jmp .jump1304
.jump1303:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump1304:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1305
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1305:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1306: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1306 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1306 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1306 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1306 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1295 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1295 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1307
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1307:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[g : d, h : (array[g : d, h : d, i : c] 739)[((c % b) / d), (- 272), b]] (- (sum[i : (if false then g else c), j : 817, k : (if true then d else b), l : (if f() then h else c)] i))) 
	jno .jump1308
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1308:
imul rdi, [rsp + 0 + 8] ; multiply by (array[g : (- d), h : (- 125), i : b] (array[j : g, k : b] c))[b, (sum[g : (b - c), h : b, i : c, j : b] h), (sum[g : 487] b)][185, (array[g : (if f() then d else 503)] (- 846))[(- (- b))]] 
	jno .jump1309
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1309:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1310: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const328] ; 769
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1311
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1311:
	cmp rax, [rsp + 24]
	jl .jump1312
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1312:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1313
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1313:
	cmp rax, [rsp + 32]
	jl .jump1314
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1314:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1315
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1315:
	cmp rax, [rsp + 40]
	jl .jump1316
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1316:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1317
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1319
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
.jump1319:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1320
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1320:
	; Computing bound for 'j'
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1321
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump1322
.jump1321:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump1322:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1323
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1323:
	; Computing bound for 'i'
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1324
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	jmp .jump1325
.jump1324:
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
.jump1325:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1326
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1326:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if false then g else h) 
	jno .jump1327
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1327:
	imul rdi, [rsp + 0 + 8] ; multiply by (if true then d else d) 
	jno .jump1328
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1328:
	imul rdi, [rsp + 0 + 16] ; multiply by (c / g) 
	jno .jump1329
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1329:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1330: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1331
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1331:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1332
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1332:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump1333
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1333:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump1334
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1334:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1335: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1335 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1335 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1330 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1330 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1330 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1336
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1336:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const329] ; 572
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1337
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1337:
	cmp rax, [rsp + 24]
	jl .jump1338
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1338:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1339
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1339:
	cmp rax, [rsp + 32]
	jl .jump1340
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1340:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1341
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1341:
	cmp rax, [rsp + 40]
	jl .jump1342
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1342:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1318
.jump1317:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1343
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1343:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1344
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1344:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1345
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1345:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1346: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1346 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1346 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1346 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump1347
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump1348
.jump1347:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump1348:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1349
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
.jump1349:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1350
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1350:
	; Computing bound for 'i'
	mov rax, [rel const330] ; 337
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1351
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1351:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1352: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1352 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1353
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1353:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by ((sum[i : c] d) - 337) 
	jno .jump1354
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1354:
imul rdi, [rsp + 0 + 8] ; multiply by ((if f() then c else b) / (sum[i : d, j : b, k : b] d)) 
	jno .jump1355
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1355:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1356: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1356 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1356 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump1318:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1310 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1310 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump1240
.jump1239:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1357
	mov rax, [rel const5] ; False
	push rax
	jmp .jump1358
.jump1357:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump1358:
	pop rax
	cmp rax, 0
	je .jump1359
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump1360
.jump1359:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const331] ; 103
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1361
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1361:
	cqo
	idiv r10
	push rax
.jump1360:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1362
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1362:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1363
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1363:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1364
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1364:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1365
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1365:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1366
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1366:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1367
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1367:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1368
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1368:
	; Computing bound for 'h'
	mov rax, [rel const259] ; 754
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1369
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1369:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1370
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1370:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1371: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump1372
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump1373
.jump1372:
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
.jump1373:
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1371 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1371 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1371 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1371 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1374
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1374:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1375: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1375 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1375 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1375 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1375 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1376
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1376:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1377
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1377:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,][,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- d) 
	jno .jump1378
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1378:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[g : (sum[g : d, h : 754, i : (- c), j : c] (if f() then b else g)), h : ((d * b) / c), i : (b - d), j : (- c)] h) 
	jno .jump1379
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1379:
	imul rdi, [rsp + 0 + 16] ; multiply by (if (if false then false else f()) then b else (103 / b)) 
	jno .jump1380
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1380:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1381: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1382
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1382:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1383
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1383:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump1384
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1384:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump1385
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1385:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1386: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1387
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1387:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1388
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1388:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump1389
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1389:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump1390
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1390:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1391: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1391 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1391 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1386 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1386 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1381 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1381 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1381 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump1392
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1394
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1394:
	; Computing bound for 'i'
	mov rax, [rel const332] ; 457
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1395
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1395:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1396
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1396:
	; Computing bound for 'g'
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1397
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump1398
.jump1397:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump1398:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1399
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1399:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if false then c else c) 
	jno .jump1400
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1400:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump1401
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1401:
	imul rdi, [rsp + 0 + 16] ; multiply by 457 
	jno .jump1402
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1402:
	imul rdi, [rsp + 0 + 24] ; multiply by d 
	jno .jump1403
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1403:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1404: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const333] ; 74
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1404 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1404 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1404 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1404 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump1393
.jump1392:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1405
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1405:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1406
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1406:
	; Computing bound for 'h'
	mov rax, [rel const334] ; 139
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1407
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1407:
	; Computing bound for 'g'
	mov rax, [rel const335] ; 265
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1408
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1408:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 265 
	jno .jump1409
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1409:
	imul rdi, [rsp + 0 + 8] ; multiply by 139 
	jno .jump1410
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1410:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump1411
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1411:
	imul rdi, [rsp + 0 + 24] ; multiply by b 
	jno .jump1412
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1412:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1413: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1413 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1413 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1413 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1413 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump1393:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const336] ; 449
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1414
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
.jump1414:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1415
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1415:
	cmp rax, [rsp + 24]
	jl .jump1416
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1416:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1417
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1417:
	cmp rax, [rsp + 32]
	jl .jump1418
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1418:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1419
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1419:
	cmp rax, [rsp + 40]
	jl .jump1420
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1420:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1421
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump1423
	call _f
	push rax
	pop rax
.jump1423:
	push rax
	jmp .jump1422
.jump1421:
	mov rax, [rel const2] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
.jump1422:
	pop rax
	cmp rax, 0
	je .jump1424
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump1425
.jump1424:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1426
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1426:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump1427
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1427:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1428: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1428 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1429
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1429:
	cmp rax, [rsp + 8]
	jl .jump1430
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1430:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump1425:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1431
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1431:
	cmp rax, [rsp + 32]
	jl .jump1432
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1432:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1433
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1433:
	cmp rax, [rsp + 40]
	jl .jump1434
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1434:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1435
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1435:
	cmp rax, [rsp + 48]
	jl .jump1436
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1436:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1437
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1437:
	cmp rax, [rsp + 56]
	jl .jump1438
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1438:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1439
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1439:
	cmp rax, [rsp + 24]
	jl .jump1440
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1440:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1441
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1441:
	cmp rax, [rsp + 32]
	jl .jump1442
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1442:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1443
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1443:
	cmp rax, [rsp + 40]
	jl .jump1444
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1444:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump1240:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1445
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1445:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1446
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1446:
	; Computing bound for 'g'
	mov rax, [rel const96] ; 563
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1447
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1447:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1448: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1448 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1448 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1448 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const337] ; 826
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1449
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1449:
	cmp rax, [rsp + 16]
	jl .jump1450
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1450:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1451
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1451:
	cmp rax, [rsp + 24]
	jl .jump1452
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1452:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _get_time
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp + 24]
	subsd xmm0, xmm1
	sub rsp, 8 ; Add alignment
	call _print_time
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1453
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1453:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1454: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1454 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1455
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const338] ; 616
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1457
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1457:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1458
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1458:
	; Computing bound for 'k'
	mov rax, [rel const60] ; 578
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1459
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1459:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1460
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1460:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump1461
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1461:
	imul rdi, [rsp + 0 + 8] ; multiply by (- (- 578)) 
	jno .jump1462
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1462:
	imul rdi, [rsp + 0 + 16] ; multiply by c 
	jno .jump1463
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1463:
	imul rdi, [rsp + 0 + 24] ; multiply by 616 
	jno .jump1464
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1464:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1465: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1466
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1468
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1468:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump1469
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1469:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump1470: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 0], 1
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1470 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump1467
.jump1466:
	mov rax, [rel const2] ; True
	push rax
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
.jump1467:
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1471
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1471:
	cmp rax, [rsp + 8]
	jl .jump1472
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1472:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1465 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1465 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1465 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1465 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const339] ; 622
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1473
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1473:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1474
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1474:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump1475
	mov rax, [rel const340] ; 123
	push rax
	jmp .jump1476
.jump1475:
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
.jump1476:
	mov rax, [rel const341] ; 379
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1477
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1477:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1478: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1479
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1479:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1480
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1480:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1481
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1481:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1482
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1482:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1483: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1483 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1483 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1483 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1483 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1478 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1478 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1478 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1484
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1484:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1485
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1485:
	cmp rax, [rsp + 32]
	jl .jump1486
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1486:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1487
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1487:
	cmp rax, [rsp + 40]
	jl .jump1488
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1488:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1489
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1489:
	cmp rax, [rsp + 48]
	jl .jump1490
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1490:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1491
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1491:
	cmp rax, [rsp + 56]
	jl .jump1492
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1492:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1493
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1495
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump1497
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
.jump1497:
	push rax
	pop rax
	cmp rax, 0
	je .jump1498
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1500
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump1502
	mov rax, [rel const342] ; 450
	push rax
	jmp .jump1503
.jump1502:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump1503:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1504
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1504:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const162] ; 489
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1505
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1505:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (489 * h) 
	jno .jump1506
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1506:
	imul rdi, [rsp + 0 + 8] ; multiply by (if f() then 450 else c) 
	jno .jump1507
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1507:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1508: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1509
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1509:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1510
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1510:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1511
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1511:
	; Computing bound for 'l'
	mov rax, [rel const343] ; 486
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1512
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1512:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 486 
	jno .jump1513
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1513:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump1514
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1514:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump1515
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1515:
	imul rdi, [rsp + 0 + 24] ; multiply by j 
	jno .jump1516
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1516:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1517: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1517 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1517 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1517 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1517 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1508 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1508 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump1501
.jump1500:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1518
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1518:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1519
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1519:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (c + b) 
	jno .jump1520
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1520:
	imul rdi, [rsp + 0 + 8] ; multiply by (- d) 
	jno .jump1521
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1521:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1522: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1523
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1523:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1524
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1524:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1525
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1525:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1526
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1526:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump1527
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1527:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump1528
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1528:
	imul rdi, [rsp + 0 + 16] ; multiply by j 
	jno .jump1529
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1529:
	imul rdi, [rsp + 0 + 24] ; multiply by c 
	jno .jump1530
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1530:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1531: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1531 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1531 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1531 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1531 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1522 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1522 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump1501:
	jmp .jump1499
.jump1498:
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1532
	mov rax, [rel const344] ; 56.43
	push rax
	mov rax, [rel const345] ; 88.71
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	jmp .jump1533
.jump1532:
	mov rax, [rel const2] ; True
	push rax
.jump1533:
	pop rax
	cmp rax, 0
	je .jump1534
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1536
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1536:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1537
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1537:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump1538
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1538:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump1539
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1539:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1540: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1541
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1541:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1542
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1542:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1543
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1543:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1544
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1544:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by j 
	jno .jump1545
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1545:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump1546
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1546:
	imul rdi, [rsp + 0 + 16] ; multiply by d 
	jno .jump1547
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1547:
	imul rdi, [rsp + 0 + 24] ; multiply by k 
	jno .jump1548
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1548:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1549: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1549 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1549 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1549 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1549 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1540 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1540 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump1535
.jump1534:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1550
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1550:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1551
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1551:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump1552
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1552:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump1553
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1553:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1554: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1555
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1555:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1556
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1556:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1557
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1557:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1558
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1558:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump1559
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1559:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump1560
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1560:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump1561
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1561:
	imul rdi, [rsp + 0 + 24] ; multiply by j 
	jno .jump1562
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1562:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1563: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1563 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1563 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1563 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1563 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1554 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1554 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump1535:
.jump1499:
	jmp .jump1496
.jump1495:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const346] ; 565
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1564
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1564:
	; Computing bound for 'j'
	sub rsp, 24
	; Moving 24 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const347] ; 368
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1565
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1565:
	cmp rax, [rsp + 16]
	jl .jump1566
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1566:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1567
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1567:
	cmp rax, [rsp + 24]
	jl .jump1568
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1568:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1569
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1571
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1571:
	; Computing bound for 'k'
	mov rax, [rel const348] ; 336
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1572
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1572:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1573
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1573:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1574: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1574 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1574 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1574 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1575
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1575:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1576
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1576:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1577
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
.jump1577:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1578
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1578:
	; Computing bound for 'j'
	mov rax, [rel const349] ; 195
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1579
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1579:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1580: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1581
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1581:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1582
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1582:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump1583: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1583 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1583 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1580 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1580 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1580 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1580 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	jmp .jump1570
.jump1569:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump1570:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1584
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1584:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,][,,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (if (! g[d, 368]) then (sum[j : 195, k : (i % d), l : c, m : (sum[j : h, k : 336, l : c] k)] (sum[n : d, o : h] j)) else (- c)) 
	jno .jump1585
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1585:
	imul rdi, [rsp + 0 + 8] ; multiply by 565 
	jno .jump1586
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1586:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1587: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	mov rax, [rel const2] ; True
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1588
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const350] ; 604
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1590
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1590:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1591
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1591:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1592
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1592:
	; Computing bound for 'l'
	mov rax, [rel const121] ; 891
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1593
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1593:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 891) 
	jno .jump1594
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1594:
	imul rdi, [rsp + 0 + 8] ; multiply by (- k) 
	jno .jump1595
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1595:
	imul rdi, [rsp + 0 + 16] ; multiply by d 
	jno .jump1596
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1596:
	imul rdi, [rsp + 0 + 24] ; multiply by 604 
	jno .jump1597
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1597:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1598: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1599
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1599:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1600
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1600:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump1601
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1601:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump1602
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1602:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump1603: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 8], 1
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1603 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1603 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1598 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1598 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1598 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1598 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump1589
.jump1588:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1604
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1604:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1605
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1605:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1606
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1606:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1607
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1607:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1608
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1608:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump1609
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1609:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump1610
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1610:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump1611
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1611:
	imul rdi, [rsp + 0 + 24] ; multiply by (i % d) 
	jno .jump1612
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1612:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1613: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1613 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1613 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1613 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1613 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump1589:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1587 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1587 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump1496:
	jmp .jump1494
.jump1493:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1614
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1614:
	; Computing bound for 'j'
	mov rax, [rel const351] ; 770
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1615
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1615:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 770 
	jno .jump1616
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1616:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump1617
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1617:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1618: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1619
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1619:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1620
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1620:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1621
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1621:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1622
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1622:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump1623
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1623:
	imul rdi, [rsp + 0 + 8] ; multiply by (- h) 
	jno .jump1624
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1624:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump1625
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1625:
	imul rdi, [rsp + 0 + 24] ; multiply by d 
	jno .jump1626
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1626:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1627: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1627 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1627 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1627 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1627 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1618 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1618 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump1494:
	jmp .jump1456
.jump1455:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump1628
	mov rax, [rel const352] ; 29.08
	push rax
	jmp .jump1629
.jump1628:
	mov rax, [rel const353] ; 20.5
	push rax
.jump1629:
	mov rax, [rel const354] ; 12.78
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const355] ; 90.79
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const356] ; 38.48
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1630
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1632
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1634
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1634:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1635
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1635:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1636
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1636:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1637
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1637:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump1638
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1638:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump1639
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1639:
	imul rdi, [rsp + 0 + 16] ; multiply by d 
	jno .jump1640
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1640:
	imul rdi, [rsp + 0 + 24] ; multiply by h 
	jno .jump1641
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1641:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1642: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1642 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1642 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1642 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1642 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump1633
.jump1632:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const148] ; 213
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1643
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1643:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1644
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1644:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1645
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1645:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1646
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1646:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump1647
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1647:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump1648
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1648:
	imul rdi, [rsp + 0 + 16] ; multiply by d 
	jno .jump1649
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1649:
	imul rdi, [rsp + 0 + 24] ; multiply by 213 
	jno .jump1650
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1650:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1651: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1651 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1651 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1651 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1651 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump1633:
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1652
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1652:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1653: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1653 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1654
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1654:
	cmp rax, [rsp + 32]
	jl .jump1655
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1655:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1656
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1656:
	cmp rax, [rsp + 40]
	jl .jump1657
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1657:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1658
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1658:
	cmp rax, [rsp + 48]
	jl .jump1659
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1659:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1660
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1660:
	cmp rax, [rsp + 56]
	jl .jump1661
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1661:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1662
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1662:
	; Computing bound for 'j'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const357] ; 250
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1663
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1663:
	; Computing bound for 'l'
	mov rax, [rel const358] ; 389
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1664
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1664:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1665
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1665:
	; Computing bound for 'j'
	mov rax, [rel const359] ; 748
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1666
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1666:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 748 
	jno .jump1667
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1667:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump1668
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1668:
	imul rdi, [rsp + 0 + 16] ; multiply by 389 
	jno .jump1669
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1669:
	imul rdi, [rsp + 0 + 24] ; multiply by (i * 250) 
	jno .jump1670
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1670:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1671: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const360] ; 244
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1671 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1671 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1671 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1671 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1672
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1672:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1673
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1673:
	; Computing bound for 'j'
	mov rax, [rel const361] ; 882
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1674
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1674:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1675: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1675 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1675 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1675 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1676
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
.jump1676:
	cqo
	idiv r10
	push rax
	mov rax, [rel const362] ; 385
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1677
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1677:
	cmp rax, [rsp + 32]
	jl .jump1678
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1678:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1679
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1679:
	cmp rax, [rsp + 40]
	jl .jump1680
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1680:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1681
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1681:
	cmp rax, [rsp + 48]
	jl .jump1682
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1682:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1683
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1683:
	cmp rax, [rsp + 56]
	jl .jump1684
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1684:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1685
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1685:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,][,,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (array[j : 748, k : d, l : 389, m : (i * 250)] 244)[h, d, 385, ((sum[j : 882, k : h, l : (- h)] h) / h)] 
	jno .jump1686
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1686:
imul rdi, [rsp + 0 + 8] ; multiply by (b * (if true then (array[j : d, k : i, l : d, m : h] c) else (array[j : d, k : b, l : d, m : 213] b))[b, h, ((sum[j : c] i) * c), i]) 
	jno .jump1687
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1687:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1688: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1689
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const363] ; 414
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1690
	mov rax, [rel const5] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump1691
.jump1690:
	call _f
	push rax
	pop rax
	cmp rax, 0
	jne .jump1692
	call _f
	push rax
	pop rax
.jump1692:
	push rax
.jump1691:
	pop rax
.jump1689:
	push rax
	pop rax
	cmp rax, 0
	je .jump1693
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1695
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1695:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1696
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	jmp .jump1697
.jump1696:
	mov rax, [rel const364] ; 242
	push rax
.jump1697:
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1698
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1698:
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1699
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1699:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1700: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1700 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1701
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1701:
	; Computing bound for 'l'
	mov rax, [rel const365] ; 671
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1702
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1702:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 671 
	jno .jump1703
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1703:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[l : i] b) 
	jno .jump1704
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1704:
	imul rdi, [rsp + 0 + 16] ; multiply by ((if true then j else 242) * b) 
	jno .jump1705
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1705:
	imul rdi, [rsp + 0 + 24] ; multiply by k 
	jno .jump1706
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1706:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1707: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1707 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1707 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1707 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1707 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump1694
.jump1693:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const366] ; 804
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1708
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1708:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1709
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1709:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1710
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1710:
	; Computing bound for 'l'
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1711
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	jmp .jump1712
.jump1711:
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
.jump1712:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1713
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1713:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if false then h else j) 
	jno .jump1714
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1714:
	imul rdi, [rsp + 0 + 8] ; multiply by j 
	jno .jump1715
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1715:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump1716
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1716:
	imul rdi, [rsp + 0 + 24] ; multiply by 804 
	jno .jump1717
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1717:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1718: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump1719
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
.jump1719:
	push rax
	pop rax
	cmp rax, 0
	je .jump1720
	sub rsp, 24
	; Moving 24 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	jmp .jump1721
.jump1720:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1722
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1722:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1723
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1723:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump1724
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1724:
	imul rdi, [rsp + 0 + 8] ; multiply by j 
	jno .jump1725
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1725:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump1726: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 8], 1
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1726 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1726 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump1721:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1718 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1718 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1718 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1718 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump1694:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1688 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1688 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump1631
.jump1630:
	sub rsp, 32
	; Moving 32 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const206] ; 878
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1727
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1727:
	; Computing bound for 'l'
	mov rax, [rel const213] ; 128
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1728
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1728:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1729
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1729:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1730
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1730:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1731: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1731 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1731 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1731 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1731 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1732
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1732:
	cmp rax, [rsp + 24]
	jl .jump1733
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1733:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1734
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1734:
	cmp rax, [rsp + 32]
	jl .jump1735
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1735:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1736
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1736:
	cmp rax, [rsp + 40]
	jl .jump1737
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1737:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1738
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1740
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1740:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump1741
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1741:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1742: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1742 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1743
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1743:
	cmp rax, [rsp + 8]
	jl .jump1744
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1744:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1739
.jump1738:
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1745
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump1746
.jump1745:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump1746:
.jump1739:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1747
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1749
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1749:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1750
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1750:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump1751
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1751:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump1752
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1752:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1753: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1754
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1754:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump1755
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1755:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1756: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1757
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1757:
	; Computing bound for 'o'
	mov rax, [rel const367] ; 718
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1758
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1758:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1759
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1759:
	; Computing bound for 'm'
	mov rax, [rel const171] ; 342
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1760
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1760:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 342 
	jno .jump1761
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1761:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump1762
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1762:
	imul rdi, [rsp + 0 + 16] ; multiply by 718 
	jno .jump1763
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1763:
	imul rdi, [rsp + 0 + 24] ; multiply by k 
	jno .jump1764
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1764:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1765: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1765 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1765 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1765 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1765 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1756 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1766
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1766:
	cmp rax, [rsp + 8]
	jl .jump1767
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1767:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1753 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1753 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump1748
.jump1747:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump1768
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1770
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1770:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1771
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1771:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1772: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1772 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1772 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1773
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1773:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1774
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1774:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump1775
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1775:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[j : (- h), k : b] b) 
	jno .jump1776
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1776:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1777: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1778
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1778:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1779
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1779:
	; Computing bound for 'm'
	mov rax, [rel const368] ; 728
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1780
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1780:
	; Computing bound for 'l'
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump1781
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump1782
.jump1781:
	mov rax, [rel const369] ; 220
	push rax
.jump1782:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1783
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1783:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if f() then d else 220) 
	jno .jump1784
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1784:
	imul rdi, [rsp + 0 + 8] ; multiply by 728 
	jno .jump1785
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1785:
	imul rdi, [rsp + 0 + 16] ; multiply by (- k) 
	jno .jump1786
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1786:
	imul rdi, [rsp + 0 + 24] ; multiply by j 
	jno .jump1787
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1787:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1788: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump1789
	sub rsp, 24
	; Moving 24 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	jmp .jump1790
.jump1789:
	sub rsp, 24
	; Moving 24 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
.jump1790:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1788 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1788 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1788 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1788 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1777 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1777 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump1769
.jump1768:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1791
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1791:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump1792
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1792:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1793: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1793 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1794
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1794:
	cmp rax, [rsp + 8]
	jl .jump1795
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1795:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1796
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1796:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1797
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1797:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump1798
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1798:
imul rdi, [rsp + 0 + 8] ; multiply by (array[j : h] c)[(b + b)] 
	jno .jump1799
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1799:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1800: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1801
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1801:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1802
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1802:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1803
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1803:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1804
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1804:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof bool[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump1805
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1805:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump1806
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1806:
	imul rdi, [rsp + 0 + 16] ; multiply by d 
	jno .jump1807
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1807:
	imul rdi, [rsp + 0 + 24] ; multiply by k 
	jno .jump1808
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1808:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1809: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1809 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1809 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1809 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1809 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1800 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1800 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump1769:
.jump1748:
.jump1631:
.jump1456:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1810
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1812
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1812:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump1813
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1813:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1814: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1814 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1815
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1815:
	cmp rax, [rsp + 8]
	jl .jump1816
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1816:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1817
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump1818
.jump1817:
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const370] ; 859
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
.jump1818:
	jmp .jump1811
.jump1810:
	mov rax, [rel const371] ; 83.54
	push rax
	mov rax, [rel const372] ; 95.41
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1819
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1819:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1820
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1820:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1821
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1821:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1822: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const373] ; 37.88
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1822 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1822 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1822 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const374] ; 70.91
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
.jump1811:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1823
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1825
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1826
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1826:
	; Computing bound for 'l'
	mov rax, [rel const375] ; 424
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1827
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1827:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1828
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1828:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1829
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1829:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump1830
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1830:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump1831
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1831:
	imul rdi, [rsp + 0 + 16] ; multiply by 424 
	jno .jump1832
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1832:
	imul rdi, [rsp + 0 + 24] ; multiply by c 
	jno .jump1833
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1833:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1834: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const5] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1834 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1834 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1834 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1834 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1835
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump1836
.jump1835:
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
.jump1836:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1837
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1837:
	cmp rax, [rsp + 32]
	jl .jump1838
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1838:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1839
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1839:
	cmp rax, [rsp + 40]
	jl .jump1840
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1840:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1841
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1841:
	cmp rax, [rsp + 48]
	jl .jump1842
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1842:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1843
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1843:
	cmp rax, [rsp + 56]
	jl .jump1844
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1844:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
.jump1825:
	push rax
	pop rax
	cmp rax, 0
	je .jump1845
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1847
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1847:
	; Computing bound for 'l'
	mov rax, [rel const376] ; 955
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1848
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1848:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1849
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1849:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1850
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1850:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump1851
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1851:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump1852
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1852:
	imul rdi, [rsp + 0 + 16] ; multiply by 955 
	jno .jump1853
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1853:
	imul rdi, [rsp + 0 + 24] ; multiply by c 
	jno .jump1854
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1854:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1855: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const5] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1855 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1855 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1855 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1855 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1856
	mov rax, [rel const206] ; 878
	push rax
	jmp .jump1857
.jump1856:
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
.jump1857:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1858
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1858:
	cmp rax, [rsp + 32]
	jl .jump1859
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1859:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1860
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1860:
	cmp rax, [rsp + 40]
	jl .jump1861
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1861:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1862
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1862:
	cmp rax, [rsp + 48]
	jl .jump1863
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1863:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1864
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1864:
	cmp rax, [rsp + 56]
	jl .jump1865
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1865:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1866
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1868
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1868:
	; Computing bound for 'k'
	mov rax, [rel const377] ; 645
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1869
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1869:
	; Computing bound for 'j'
	mov rax, [rel const271] ; 438
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1870
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1870:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 438 
	jno .jump1871
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1871:
	imul rdi, [rsp + 0 + 8] ; multiply by 645 
	jno .jump1872
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1872:
	imul rdi, [rsp + 0 + 16] ; multiply by c 
	jno .jump1873
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1873:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1874: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1874 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1874 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1874 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1875
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1875:
	cmp rax, [rsp + 24]
	jl .jump1876
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1876:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1877
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1877:
	cmp rax, [rsp + 32]
	jl .jump1878
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1878:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1879
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1879:
	cmp rax, [rsp + 40]
	jl .jump1880
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1880:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1867
.jump1866:
	call _f
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1881
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump1882
.jump1881:
	mov rax, [rel const202] ; 815
	push rax
.jump1882:
.jump1867:
	jmp .jump1846
.jump1845:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump1846:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1883
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1883:
	; Computing bound for 'j'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump1884
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1886
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1888
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1888:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1889
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1889:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1890
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1890:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1891: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1891 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1891 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1891 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump1887
.jump1886:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const378] ; 101
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1892
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1892:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1893
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1893:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1894
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1894:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1895
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1895:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump1896
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1896:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump1897
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1897:
	imul rdi, [rsp + 0 + 16] ; multiply by c 
	jno .jump1898
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1898:
	imul rdi, [rsp + 0 + 24] ; multiply by 101 
	jno .jump1899
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1899:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1900: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1900 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1900 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1900 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1900 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const379] ; 574
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1901
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1901:
	cmp rax, [rsp + 32]
	jl .jump1902
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1902:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1903
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1903:
	cmp rax, [rsp + 40]
	jl .jump1904
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1904:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1905
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1905:
	cmp rax, [rsp + 48]
	jl .jump1906
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1906:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1907
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1907:
	cmp rax, [rsp + 56]
	jl .jump1908
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1908:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump1887:
	jmp .jump1885
.jump1884:
	mov rax, [rel const380] ; 527
	push rax
.jump1885:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1909
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1909:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (if f() then (if (h > (- b)) then (sum[j : h, k : c, l : d] i) else (array[j : h, k : i, l : c, m : 101] j)[i, d, b, 574]) else 527) 
	jno .jump1910
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1910:
imul rdi, [rsp + 0 + 8] ; multiply by (if (false && (array[j : c, k : b, l : 424, m : c] false)[i, (b * c), d, (if true then c else i)]) then (if (array[j : d, k : b, l : 955, m : c] false)[(if false then 878 else i), i, h, b] then (array[j : 438, k : 645, l : c] h)[h, (- d), b] else (if (! f()) then (- d) else 815)) else (- b)) 
	jno .jump1911
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1911:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1912: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1912 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1912 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump1824
.jump1823:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1913
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1913:
	; Computing bound for 'k'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1914
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1914:
	; Computing bound for 'k'
	mov rax, [rel const286] ; 47
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1915
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1915:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1916
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
.jump1916:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1917
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1917:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1918: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1918 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1918 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1918 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1919
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1919:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1920
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1920:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump1921
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1921:
imul rdi, [rsp + 0 + 8] ; multiply by (- (sum[j : (h / b), k : 47, l : d] k)) 
	jno .jump1922
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1922:
	imul rdi, [rsp + 0 + 16] ; multiply by (i - d) 
	jno .jump1923
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1923:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1924: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1925
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1925:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1926
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1926:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump1927
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1927:
	imul rdi, [rsp + 0 + 8] ; multiply by (b * j) 
	jno .jump1928
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1928:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1929: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1929 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1929 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1924 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1924 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1924 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1930
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1930:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump1931
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1931:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1932: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1933
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1933:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1934
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1934:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1935
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1935:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1936
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1936:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump1937
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1937:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump1938
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1938:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump1939
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1939:
	imul rdi, [rsp + 0 + 24] ; multiply by h 
	jno .jump1940
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1940:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1941: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 24], 1
	; Compare n to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1941 ; If n < bound, next iter
	mov qword [rsp + 24], 0 ; n = 0
	add qword [rsp + 16], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1941 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1941 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1941 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1932 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1942
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1942:
	cmp rax, [rsp + 8]
	jl .jump1943
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1943:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1944
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump1945
.jump1944:
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1946
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
.jump1946:
	cqo
	idiv r10
	push rax
.jump1945:
	mov rax, [rel const381] ; 175
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const69] ; 4
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1947
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1947:
	cmp rax, [rsp + 32]
	jl .jump1948
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1948:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1949
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1949:
	cmp rax, [rsp + 40]
	jl .jump1950
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1950:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1951
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1951:
	cmp rax, [rsp + 48]
	jl .jump1952
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1952:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1953
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1953:
	cmp rax, [rsp + 56]
	jl .jump1954
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1954:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const382] ; 99.98
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1955
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1955:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1956
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1956:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1957
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1957:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1958
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1958:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1959: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const383] ; 50.92
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1959 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1959 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1959 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1959 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1960
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	jmp .jump1961
.jump1960:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump1961:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1962
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1962:
	cmp rax, [rsp + 24]
	jl .jump1963
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1963:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1964
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1964:
	cmp rax, [rsp + 32]
	jl .jump1965
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1965:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1966
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1966:
	cmp rax, [rsp + 40]
	jl .jump1967
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1967:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump1824:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const384] ; 399
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1968
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1968:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1969
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1969:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1970
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1970:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump1971
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1971:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump1972
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1972:
	imul rdi, [rsp + 0 + 16] ; multiply by 399 
	jno .jump1973
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1973:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1974: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1974 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1974 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1974 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1975
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1975:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1976
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump1976:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- d) 
	jno .jump1977
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1977:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump1978
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump1978:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1979: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1979 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1979 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1980
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1980:
	cmp rax, [rsp + 16]
	jl .jump1981
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1981:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1982
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1982:
	cmp rax, [rsp + 24]
	jl .jump1983
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1983:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1984
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1984:
	cmp rax, [rsp + 24]
	jl .jump1985
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1985:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1986
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1986:
	cmp rax, [rsp + 32]
	jl .jump1987
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1987:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1988
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1988:
	cmp rax, [rsp + 40]
	jl .jump1989
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1989:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1990
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1990:
	cmp rax, [rsp + 16]
	jl .jump1991
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1991:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1992
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1992:
	cmp rax, [rsp + 24]
	jl .jump1993
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1993:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1994
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1994:
	cmp rax, [rsp + 16]
	jl .jump1995
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1995:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1996
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump1996:
	cmp rax, [rsp + 24]
	jl .jump1997
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump1997:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 40
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _get_time
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump1998
	sub rsp, 8 ; Add alignment
	mov rax, [rel const385] ; 94.34
	push rax
	mov rax, [rel const386] ; 41.94
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const387] ; 64.99
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const388] ; 30.08
	push rax
	mov rax, [rel const389] ; 1.82
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1999
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1999:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2000
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2000:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2001
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2001:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump2002: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2003
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2003:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2004
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2004:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2005
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2005:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2006
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2006:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2007: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const390] ; 39.97
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'u'
	add qword [rsp + 24], 1
	; Compare u to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2007 ; If u < bound, next iter
	mov qword [rsp + 24], 0 ; u = 0
	add qword [rsp + 16], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2007 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2007 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2007 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2002 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2002 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2002 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const391] ; 22.07
	push rax
	mov rax, [rel const392] ; 73.89
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const393] ; 33.52
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
.jump1998:
	push rax
	pop rax
	cmp rax, 0
	je .jump2008
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2010
	mov rax, [rel const394] ; 36.05
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump2011
.jump2010:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	mov rax, [rel const395] ; 71
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2012
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2012:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2013
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2013:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2014
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2014:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump2015: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const396] ; 64.98
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2015 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2015 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2015 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump2011:
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2016
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2016:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump2017: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 's'
	mov rax, [rel const312] ; 366
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2018
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2018:
	; Computing bound for 'r'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2019
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2019:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2020
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2020:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2021
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2021:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2022
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2022:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump2023: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 's'
	add qword [rsp + 24], 1
	; Compare s to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2023 ; If s < bound, next iter
	mov qword [rsp + 24], 0 ; s = 0
	add qword [rsp + 16], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2023 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2023 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2023 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2024
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2024:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2025
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
.jump2025:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2026
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2026:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2027
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2027:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump2028: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const397] ; 38.56
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 's'
	add qword [rsp + 24], 1
	; Compare s to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2028 ; If s < bound, next iter
	mov qword [rsp + 24], 0 ; s = 0
	add qword [rsp + 16], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2028 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2028 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2028 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2017 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2029
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	mov rax, [rel const211] ; 222
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2031
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
.jump2031:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2032
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2032:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2033
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2033:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2034
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2034:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump2035
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2035:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump2036
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2036:
	imul rdi, [rsp + 0 + 16] ; multiply by (c % 222) 
	jno .jump2037
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2037:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump2038: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const398] ; 942
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2038 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2038 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2038 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump2030
.jump2029:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2039
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2039:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2040
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2040:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2041
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2041:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump2042
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2042:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump2043
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2043:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump2044
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2044:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump2045: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2046
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2046:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2047
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2047:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2048
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2048:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2049
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2049:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump2050
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2050:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump2051
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2051:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump2052
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2052:
	imul rdi, [rsp + 0 + 24] ; multiply by (- c) 
	jno .jump2053
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2053:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2054: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2055
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2055:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2056
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2056:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2057
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2057:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump2058
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2058:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump2059
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2059:
	imul rdi, [rsp + 0 + 16] ; multiply by d 
	jno .jump2060
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2060:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump2061: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 336 to rsp 
		mov r10, [rbp - 336 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'x'
	add qword [rsp + 16], 1
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2061 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2061 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2061 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'u'
	add qword [rsp + 24], 1
	; Compare u to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2054 ; If u < bound, next iter
	mov qword [rsp + 24], 0 ; u = 0
	add qword [rsp + 16], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2054 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2054 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2054 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2045 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2045 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2045 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2062
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2062:
	cmp rax, [rsp + 24]
	jl .jump2063
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2063:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2064
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2064:
	cmp rax, [rsp + 32]
	jl .jump2065
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2065:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2066
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2066:
	cmp rax, [rsp + 40]
	jl .jump2067
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2067:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const399] ; 33
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2068
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
.jump2068:
	cqo
	idiv r10
	push rax
	sub rsp, 24
	; Moving 24 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2069
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2069:
	cmp rax, [rsp + 16]
	jl .jump2070
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2070:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2071
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2071:
	cmp rax, [rsp + 24]
	jl .jump2072
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2072:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2073
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump2074
.jump2073:
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
.jump2074:
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2075
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
.jump2075:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2076
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2076:
	cmp rax, [rsp + 32]
	jl .jump2077
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2077:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2078
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2078:
	cmp rax, [rsp + 40]
	jl .jump2079
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2079:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2080
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2080:
	cmp rax, [rsp + 48]
	jl .jump2081
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2081:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2082
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2082:
	cmp rax, [rsp + 56]
	jl .jump2083
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2083:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2030:
	jmp .jump2009
.jump2008:
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2084
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	jne .jump2086
	mov rax, [rel const5] ; False
	push rax
	pop rax
.jump2086:
	push rax
	pop rax
	cmp rax, 0
	je .jump2087
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
.jump2087:
	push rax
	pop rax
	cmp rax, 0
	je .jump2088
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2090
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2090:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2091
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2091:
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2092
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2092:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump2093: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const400] ; 91
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2093 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2094
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2094:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[o : h] 91) 
	jno .jump2095
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2095:
	imul rdi, [rsp + 0 + 8] ; multiply by (- m) 
	jno .jump2096
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2096:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump2097
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2097:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump2098: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2099
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2099:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2100
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2100:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2101
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2101:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump2102
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2102:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump2103
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2103:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump2104
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2104:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2105: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 't'
	add qword [rsp + 16], 1
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2105 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2105 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2105 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2098 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2098 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2098 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump2089
.jump2088:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	call _f
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2106
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump2107
.jump2106:
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
.jump2107:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2108
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2108:
	; Computing bound for 'p'
	mov rax, [rel const49] ; 55
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2109
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2109:
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2110
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2110:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2111
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2111:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2112
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2112:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2113
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2113:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump2114: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2114 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2114 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2114 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2115
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2115:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[o : (d % k), p : l, q : i] h) 
	jno .jump2116
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2116:
	imul rdi, [rsp + 0 + 8] ; multiply by 55 
	jno .jump2117
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2117:
	imul rdi, [rsp + 0 + 16] ; multiply by (if (! f()) then (- k) else h) 
	jno .jump2118
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2118:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump2119: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump2120
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2122
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2122:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2123
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2123:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2124
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2124:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump2125
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2125:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump2126
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2126:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump2127
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2127:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2128: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 't'
	add qword [rsp + 16], 1
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2128 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2128 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2128 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump2121
.jump2120:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2129
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2129:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2130
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2130:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2131
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2131:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump2132
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2132:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump2133
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2133:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump2134
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2134:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2135: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 't'
	add qword [rsp + 16], 1
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2135 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2135 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2135 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump2121:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2119 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2119 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2119 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump2089:
	jmp .jump2085
.jump2084:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	mov rax, [rel const12] ; 807
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2136
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2136:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2137
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2137:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2138
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2138:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump2139
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2139:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump2140
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2140:
	imul rdi, [rsp + 0 + 16] ; multiply by 807 
	jno .jump2141
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2141:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump2142: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2143
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2143:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2144
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2144:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2145
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2145:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- n) 
	jno .jump2146
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2146:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump2147
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2147:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump2148
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2148:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump2149: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 't'
	add qword [rsp + 16], 1
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2149 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2149 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2149 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2142 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2142 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2142 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump2085:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const206] ; 878
	push rax
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump2150
	mov rax, [rel const347] ; 368
	push rax
	jmp .jump2151
.jump2150:
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
.jump2151:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2152
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2152:
	cmp rax, [rsp + 24]
	jl .jump2153
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2153:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2154
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2154:
	cmp rax, [rsp + 32]
	jl .jump2155
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2155:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2156
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2156:
	cmp rax, [rsp + 40]
	jl .jump2157
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2157:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2009:
	sub rsp, 8 ; Add alignment
	call _get_time
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp + 32]
	subsd xmm0, xmm1
	sub rsp, 8 ; Add alignment
	call _print_time
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	lea rdi, [rsp]
	sub rsp, 8 ; Add alignment
	lea rsi, [rel const401] ; 't.png'
	call _read_image
	add rsp, 8 ; Remove alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2158
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2158:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2159
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2159:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2160
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2160:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump2161
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2161:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump2162
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2162:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump2163
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2163:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump2164: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'x'
	add qword [rsp + 16], 1
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2164 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2164 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2164 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const5] ; False
	push rax
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2165
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	jmp .jump2166
.jump2165:
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
.jump2166:
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2167
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2167:
	cmp rax, [rsp + 24]
	jl .jump2168
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2168:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2169
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2169:
	cmp rax, [rsp + 32]
	jl .jump2170
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2170:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2171
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2171:
	cmp rax, [rsp + 40]
	jl .jump2172
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2172:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2173
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	jmp .jump2174
.jump2173:
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
.jump2174:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2175
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2175:
	cmp rax, [rsp + 24]
	jl .jump2176
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2176:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2177
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2177:
	cmp rax, [rsp + 32]
	jl .jump2178
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2178:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2179
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2179:
	cmp rax, [rsp + 40]
	jl .jump2180
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2180:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _get_time
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2181
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2181:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2182
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2182:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump2183: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const402] ; 13.94
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'y'
	add qword [rsp + 8], 1
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2183 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2183 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const403] ; 7.51
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const2] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2184
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'x'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2186
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2186:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2187
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2187:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump2188
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2188:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump2189
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2189:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump2190: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'y'
	add qword [rsp + 8], 1
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2190 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2190 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const404] ; 471
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2191
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2191:
	cmp rax, [rsp + 16]
	jl .jump2192
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2192:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2193
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2193:
	cmp rax, [rsp + 24]
	jl .jump2194
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2194:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2195
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2195:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump2196: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const405] ; 71.04
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'x'
	add qword [rsp + 0], 1
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2196 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump2185
.jump2184:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2197
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2197:
	; Computing bound for 'x'
	mov rax, [rel const406] ; 553
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2198
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2198:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump2199: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const407] ; 18.81
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'y'
	add qword [rsp + 8], 1
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2199 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2199 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump2185:
	sub rsp, 32
	; Moving 32 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const408] ; 663
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2200
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2200:
	cmp rax, [rsp + 24]
	jl .jump2201
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2201:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2202
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2202:
	cmp rax, [rsp + 32]
	jl .jump2203
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2203:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2204
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2204:
	cmp rax, [rsp + 40]
	jl .jump2205
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2205:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2206
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2208
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2208:
	; Computing bound for 'y'
	mov rax, [rel const409] ; 791
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2209
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2209:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2210
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2210:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump2211
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2211:
	imul rdi, [rsp + 0 + 8] ; multiply by 791 
	jno .jump2212
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2212:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump2213
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2213:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump2214: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const410] ; 71.6
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'z'
	add qword [rsp + 16], 1
	; Compare z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2214 ; If z < bound, next iter
	mov qword [rsp + 16], 0 ; z = 0
	add qword [rsp + 8], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2214 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2214 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump2207
.jump2206:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2215
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2215:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2216
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2216:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2217
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2217:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump2218
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2218:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump2219
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2219:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump2220
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2220:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump2221: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const411] ; 5.59
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'z'
	add qword [rsp + 16], 1
	; Compare z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2221 ; If z < bound, next iter
	mov qword [rsp + 16], 0 ; z = 0
	add qword [rsp + 8], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2221 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2221 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump2207:
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2222
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2222:
	cmp rax, [rsp + 24]
	jl .jump2223
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2223:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2224
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2224:
	cmp rax, [rsp + 32]
	jl .jump2225
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2225:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2226
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2226:
	cmp rax, [rsp + 40]
	jl .jump2227
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2227:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const412] ; 46.74
	push rax
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2228
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2228:
	; Computing bound for 'x'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2229
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2229:
	; Computing bound for 'x'
	sub rsp, 16
	; Moving 16 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2230
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2230:
	cmp rax, [rsp + 8]
	jl .jump2231
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2231:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2232
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2232:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump2233: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'y'
	add qword [rsp + 8], 1
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2233 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2233 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2234
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2234:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump2235: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump2236
	mov rax, [rel const413] ; 18.46
	push rax
	jmp .jump2237
.jump2236:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2238
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2238:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2239
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2239:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2240
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2240:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2241
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2241:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump2242: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const414] ; 17.54
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'C'
	add qword [rsp + 24], 1
	; Compare C to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2242 ; If C < bound, next iter
	mov qword [rsp + 24], 0 ; C = 0
	add qword [rsp + 16], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2242 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2242 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2242 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
.jump2237:
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'y'
	add qword [rsp + 8], 1
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2235 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2235 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2243
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2243:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2244
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2244:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump2245: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2246
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2246:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2247
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2247:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2248
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2248:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 296 to rsp 
		mov r10, [rbp - 296 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2249
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2249:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump2250: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'C'
	add qword [rsp + 24], 1
	; Compare C to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2250 ; If C < bound, next iter
	mov qword [rsp + 24], 0 ; C = 0
	add qword [rsp + 16], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2250 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2250 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2250 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2251
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2251:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 296 to rsp 
		mov r10, [rbp - 296 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2252
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2252:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2253
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2253:
	; Computing bound for 'z'
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2254
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	jmp .jump2255
.jump2254:
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
.jump2255:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2256
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2256:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump2257: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const415] ; 37.82
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'C'
	add qword [rsp + 24], 1
	; Compare C to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2257 ; If C < bound, next iter
	mov qword [rsp + 24], 0 ; C = 0
	add qword [rsp + 16], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2257 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2257 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2257 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'y'
	add qword [rsp + 8], 1
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2245 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2245 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const416] ; 94.23
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 32
	; Moving 32 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 184 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 184 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const417] ; 431
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2258
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2258:
	cmp rax, [rsp + 24]
	jl .jump2259
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2259:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2260
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2260:
	cmp rax, [rsp + 32]
	jl .jump2261
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2261:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2262
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump2262:
	cmp rax, [rsp + 40]
	jl .jump2263
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump2263:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2264
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2264:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof float[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by o[431, d, w] 
	jno .jump2265
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2265:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump2266: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2267
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2267:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2268
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2268:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump2269
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2269:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump2270
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump2270:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump2271: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const418] ; 16.51
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'z'
	add qword [rsp + 8], 1
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2271 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2271 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'x'
	add qword [rsp + 0], 1
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2266 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const419] ; 221
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2272
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2272:
	cmp rax, [rsp + 8]
	jl .jump2273
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2273:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump2274
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2276
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2276:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2277
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2277:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2278
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2278:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2279
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2279:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump2280
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2280:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump2281
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2281:
	imul rdi, [rsp + 0 + 16] ; multiply by s 
	jno .jump2282
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2282:
	imul rdi, [rsp + 0 + 24] ; multiply by c 
	jno .jump2283
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2283:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump2284: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'A'
	add qword [rsp + 24], 1
	; Compare A to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2284 ; If A < bound, next iter
	mov qword [rsp + 24], 0 ; A = 0
	add qword [rsp + 16], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2284 ; If z < bound, next iter
	mov qword [rsp + 16], 0 ; z = 0
	add qword [rsp + 8], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2284 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2284 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2285
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2285:
	cmp rax, [rsp + 32]
	jl .jump2286
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2286:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2287
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2287:
	cmp rax, [rsp + 40]
	jl .jump2288
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2288:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2289
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2289:
	cmp rax, [rsp + 48]
	jl .jump2290
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2290:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2291
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2291:
	cmp rax, [rsp + 56]
	jl .jump2292
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2292:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump2275
.jump2274:
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
.jump2275:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2293
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2293:
	cmp rax, [rsp + 16]
	jl .jump2294
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2294:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2295
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2295:
	cmp rax, [rsp + 24]
	jl .jump2296
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2296:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	call _f
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2297
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2299
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2299:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2300
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2300:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2301
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2301:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2302
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2302:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump2303
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2303:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump2304
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2304:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump2305
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2305:
	imul rdi, [rsp + 0 + 24] ; multiply by i 
	jno .jump2306
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2306:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump2307: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'A'
	add qword [rsp + 24], 1
	; Compare A to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2307 ; If A < bound, next iter
	mov qword [rsp + 24], 0 ; A = 0
	add qword [rsp + 16], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2307 ; If z < bound, next iter
	mov qword [rsp + 16], 0 ; z = 0
	add qword [rsp + 8], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2307 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2307 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump2298
.jump2297:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2308
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2308:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2309
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2309:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2310
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2310:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2311
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2311:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump2312
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2312:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump2313
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2313:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump2314
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2314:
	imul rdi, [rsp + 0 + 24] ; multiply by b 
	jno .jump2315
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2315:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump2316: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const5] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'A'
	add qword [rsp + 24], 1
	; Compare A to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2316 ; If A < bound, next iter
	mov qword [rsp + 24], 0 ; A = 0
	add qword [rsp + 16], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2316 ; If z < bound, next iter
	mov qword [rsp + 16], 0 ; z = 0
	add qword [rsp + 8], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2316 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2316 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump2298:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2317
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2317:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2318
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2318:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump2319: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'y'
	add qword [rsp + 8], 1
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2319 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2319 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2320
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	jmp .jump2321
.jump2320:
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
.jump2321:
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2322
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2322:
	cmp rax, [rsp + 32]
	jl .jump2323
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2323:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2324
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2324:
	cmp rax, [rsp + 40]
	jl .jump2325
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2325:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2326
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2326:
	cmp rax, [rsp + 48]
	jl .jump2327
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2327:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2328
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2328:
	cmp rax, [rsp + 56]
	jl .jump2329
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2329:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2330
	mov rax, [rel const420] ; 947
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2332
	mov rax, [rel const421] ; 57.59
	push rax
	jmp .jump2333
.jump2332:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2334
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2334:
	; Computing bound for 'x'
	mov rax, [rel const422] ; 837
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2335
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2335:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump2336: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const423] ; 10.39
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'y'
	add qword [rsp + 8], 1
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2336 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2336 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump2333:
	jmp .jump2331
.jump2330:
	mov rax, [rel const424] ; 15.52
	push rax
.jump2331:
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2337
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2337:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump2338: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2339
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2339:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2340
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2340:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump2341: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump2342
	mov rax, [rel const425] ; 62.57
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump2343
.jump2342:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump2344
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 328 to rsp 
		mov r10, [rbp - 328 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2346
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2346:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2347
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2347:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump2348: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const426] ; 29.45
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2348 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2348 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2349
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2349:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump2350: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const427] ; 9.98
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'A'
	add qword [rsp + 0], 1
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2350 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump2345
.jump2344:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2351
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2351:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2352
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump2352:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump2353: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const428] ; 8.58
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2353 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2353 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump2345:
.jump2343:
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'z'
	add qword [rsp + 8], 1
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2341 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2341 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'x'
	add qword [rsp + 0], 1
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2338 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	lea rdi, [rel const429] ; '(TupleType (FloatType) (FloatType) (FloatType) (FloatType))'
	lea rsi, [rsp]
	call _show
	add rsp, 32
	call _get_time
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp + 0]
	subsd xmm0, xmm1
	call _print_time
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3400
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3400:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump3401
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3401:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3402: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'A'
	add qword [rsp + 0], 1
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3402 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3403
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3403:
	cmp rax, [rsp + 8]
	jl .jump3404
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3404:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3405
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3407
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3409
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
.jump3409:
	push rax
	jmp .jump3408
.jump3407:
	mov rax, [rel const5] ; False
	push rax
.jump3408:
	jmp .jump3406
.jump3405:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
.jump3406:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3410
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'D'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3412
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3412:
	; Computing bound for 'B'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3413
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3413:
	; Computing bound for 'A'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3414
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3414:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3415
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3415:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3416: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3416 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3416 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3417
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3417:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3418: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3418 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3418 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3419
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3419:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3420
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3420:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3421: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3421 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3421 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3421 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3422
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3422:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3423
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3423:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3424
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3424:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3425
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3425:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3426: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3426 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3426 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3426 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3426 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3427
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3427:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3428
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3428:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3429
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3429:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3430
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3430:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump3431
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3431:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump3432
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3432:
	imul rdi, [rsp + 0 + 16] ; multiply by s 
	jno .jump3433
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3433:
	imul rdi, [rsp + 0 + 24] ; multiply by r 
	jno .jump3434
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3434:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3435: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3435 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3435 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3435 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3435 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	mov rax, [rel const501] ; 690
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3436
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3436:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3437
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3437:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3438
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3438:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3439
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3439:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump3440
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3440:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump3441
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3441:
	imul rdi, [rsp + 0 + 16] ; multiply by r 
	jno .jump3442
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3442:
	imul rdi, [rsp + 0 + 24] ; multiply by 690 
	jno .jump3443
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3443:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3444: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3444 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3444 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3444 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3444 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rdi, 80
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 80 bytes from rsp to rax 
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 80
	push rax
	mov rax, 2
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3445
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3445:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump3446
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3446:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3447: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'A'
	add qword [rsp + 0], 1
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3447 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3448
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3448:
	cmp rax, [rsp + 8]
	jl .jump3449
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3449:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3450
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3450:
	cmp rax, [rsp + 8]
	jl .jump3451
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3451:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3452
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3452:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3453
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3453:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3454
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3454:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3455
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3455:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3456: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3456 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3456 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3456 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3456 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3457
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3457:
	cmp rax, [rsp + 32]
	jl .jump3458
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3458:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3459
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3459:
	cmp rax, [rsp + 40]
	jl .jump3460
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3460:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3461
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3461:
	cmp rax, [rsp + 48]
	jl .jump3462
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3462:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3463
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3463:
	cmp rax, [rsp + 56]
	jl .jump3464
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3464:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3465
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3465:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3466
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3466:
	; Computing bound for 'A'
	mov rax, [rel const502] ; 498
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3467
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3467:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 498 
	jno .jump3468
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3468:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump3469
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3469:
imul rdi, [rsp + 0 + 16] ; multiply by ([(array[A : k, B : n, C : r, D : 690] p), (array[A : r, B : l, C : s, D : r] b)][(array[A : m] b)[b]][r, l, (sum[A : p, B : l, C : i, D : b] w), r] * (sum[A : d, B : h, C : w, D : (sum[A : c, B : (sum[A : (sum[A : p, B : b] l), B : w] s), C : h] i)] k)) 
	jno .jump3470
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3470:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3471: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3472
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3472:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3473
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3473:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by C 
	jno .jump3474
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3474:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump3475
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3475:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump3476: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const503] ; 47.1
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3477
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3477:
	; Computing bound for 'H'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3478
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3478:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 304 to rsp 
		mov r10, [rbp - 304 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3479
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3479:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3480
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3480:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3481
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3481:
	; Computing bound for 'F'
	mov rax, [rel const189] ; 158
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3482
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3482:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump3483: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'I'
	add qword [rsp + 24], 1
	; Compare I to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3483 ; If I < bound, next iter
	mov qword [rsp + 24], 0 ; I = 0
	add qword [rsp + 16], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3483 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3483 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3483 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3484
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3484:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 344 to rsp 
		mov r10, [rbp - 344 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3485
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3485:
	; Computing bound for 'F'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 344 to rsp 
		mov r10, [rbp - 344 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3486
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3486:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3487
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3487:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3488
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3488:
	; Computing bound for 'F'
	mov rax, [rel const504] ; 236
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3489
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3489:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 236 
	jno .jump3490
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3490:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump3491
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3491:
	imul rdi, [rsp + 0 + 16] ; multiply by w 
	jno .jump3492
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3492:
	imul rdi, [rsp + 0 + 24] ; multiply by D 
	jno .jump3493
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3493:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump3494: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'I'
	add qword [rsp + 24], 1
	; Compare I to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3494 ; If I < bound, next iter
	mov qword [rsp + 24], 0 ; I = 0
	add qword [rsp + 16], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3494 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3494 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3494 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 336 to rsp 
		mov r10, [rbp - 336 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 304 to rsp 
		mov r10, [rbp - 304 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3495
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3495:
	cmp rax, [rsp + 32]
	jl .jump3496
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3496:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3497
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3497:
	cmp rax, [rsp + 40]
	jl .jump3498
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3498:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3499
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3499:
	cmp rax, [rsp + 48]
	jl .jump3500
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3500:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3501
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3501:
	cmp rax, [rsp + 56]
	jl .jump3502
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3502:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3503
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3503:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump3504: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'L'
	mov rax, [rel const505] ; 300
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3505
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3505:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3506
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3506:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 408 to rsp 
		mov r10, [rbp - 408 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3507
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3507:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump3508: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const442] ; 40.99
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3508 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3508 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3508 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const506] ; 48.24
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'I'
	add qword [rsp + 24], 1
	; Compare I to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3504 ; If I < bound, next iter
	mov qword [rsp + 24], 0 ; I = 0
	add qword [rsp + 16], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3504 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3504 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3504 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump3509
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3511
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3511:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump3512
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3512:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump3513: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const507] ; 23.99
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'F'
	add qword [rsp + 0], 1
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3513 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump3510
.jump3509:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3514
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3514:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by C 
	jno .jump3515
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3515:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump3516: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const508] ; 74.73
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'F'
	add qword [rsp + 0], 1
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3516 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump3510:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3517
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3517:
	cmp rax, [rsp + 8]
	jl .jump3518
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3518:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3519
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3519:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3520
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3520:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3521
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3521:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump3522
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3522:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump3523
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3523:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump3524
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3524:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump3525: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const509] ; 19.24
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'H'
	add qword [rsp + 16], 1
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3525 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3525 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3525 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 32
	; Moving 32 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 184 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 184 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 304 to rsp 
		mov r10, [rbp - 304 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3526
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3526:
	cmp rax, [rsp + 24]
	jl .jump3527
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3527:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3528
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3528:
	cmp rax, [rsp + 32]
	jl .jump3529
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3529:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3530
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3530:
	cmp rax, [rsp + 40]
	jl .jump3531
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3531:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 296 to rsp 
		mov r10, [rbp - 296 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3532
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3532:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3533
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3533:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump3534: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'G'
	add qword [rsp + 8], 1
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3534 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3534 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3535
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3535:
	cmp rax, [rsp + 24]
	jl .jump3536
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3536:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3537
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3537:
	cmp rax, [rsp + 32]
	jl .jump3538
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3538:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3539
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3539:
	cmp rax, [rsp + 40]
	jl .jump3540
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3540:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'E'
	add qword [rsp + 8], 1
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3476 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3476 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3471 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3471 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3471 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump3411
.jump3410:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump3541
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3543
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3543:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3544
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3544:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3545
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3545:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3546
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3546:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba[,][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump3547
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3547:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump3548
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3548:
	imul rdi, [rsp + 0 + 16] ; multiply by (- q) 
	jno .jump3549
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3549:
	imul rdi, [rsp + 0 + 24] ; multiply by q 
	jno .jump3550
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3550:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3551: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3552
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3552:
	; Computing bound for 'F'
	mov rax, [rel const219] ; 445
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3553
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3553:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3554
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3554:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3555: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const510] ; 731
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'E'
	add qword [rsp + 0], 1
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3555 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3556
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3556:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
imul rdi, [rsp + 0 + 0] ; multiply by ((sum[E : r] 731) * m) 
	jno .jump3557
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3557:
	imul rdi, [rsp + 0 + 8] ; multiply by 445 
	jno .jump3558
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3558:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump3559
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3559:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3560: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 216 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'G'
	add qword [rsp + 16], 1
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3560 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3560 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3560 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3551 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3551 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3551 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3551 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump3542
.jump3541:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3561
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3561:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3562
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3562:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3563
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3563:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3564
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3564:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,][,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump3565
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3565:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump3566
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3566:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump3567
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3567:
	imul rdi, [rsp + 0 + 24] ; multiply by w 
	jno .jump3568
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3568:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3569: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump3570
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	jmp .jump3571
.jump3570:
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
.jump3571:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3572
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3572:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3573
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3573:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3574
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3574:
	; Computing bound for 'E'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'E'
	mov rax, [rel const511] ; 58
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3575
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3575:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3576: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'E'
	add qword [rsp + 0], 1
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3576 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3577
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3577:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba[,][,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[E : 58] b) 
	jno .jump3578
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3578:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump3579
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3579:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump3580
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3580:
	imul rdi, [rsp + 0 + 24] ; multiply by (if f() then q else s) 
	jno .jump3581
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3581:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump3582: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3583
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3583:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3584
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3584:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3585
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3585:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump3586
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3586:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump3587
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3587:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump3588
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3588:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump3589: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 216 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'K'
	add qword [rsp + 16], 1
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3589 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3589 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3589 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'H'
	add qword [rsp + 24], 1
	; Compare H to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3582 ; If H < bound, next iter
	mov qword [rsp + 24], 0 ; H = 0
	add qword [rsp + 16], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3582 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3582 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3582 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3569 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3569 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3569 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3569 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3590
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3590:
	cmp rax, [rsp + 32]
	jl .jump3591
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3591:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3592
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3592:
	cmp rax, [rsp + 40]
	jl .jump3593
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3593:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3594
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3594:
	cmp rax, [rsp + 48]
	jl .jump3595
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3595:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3596
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3596:
	cmp rax, [rsp + 56]
	jl .jump3597
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3597:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump3542:
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'D'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'D'
	mov rax, [rel const512] ; 703
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3598
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3598:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3599
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3599:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3600
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3600:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3601
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3601:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3602: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 376 to rsp 
		mov r10, [rbp - 376 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3602 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3602 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3602 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3602 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3603
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3603:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3604
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3604:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3605
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3605:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3606
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3606:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3607: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3607 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3607 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3607 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3607 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3608
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3608:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3609
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3609:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3610: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3610 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3610 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3611
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3613
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3613:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3614
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3614:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3615
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3615:
	; Computing bound for 'A'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3616
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3616:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3617
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3617:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3618
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3618:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3619: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3619 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3619 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3619 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3620
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3620:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[A : w, B : p, C : s] r) 
	jno .jump3621
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3621:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump3622
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3622:
	imul rdi, [rsp + 0 + 16] ; multiply by l 
	jno .jump3623
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3623:
	imul rdi, [rsp + 0 + 24] ; multiply by h 
	jno .jump3624
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3624:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3625: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const513] ; 369
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3625 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3625 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3625 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3625 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump3612
.jump3611:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3626
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3626:
	; Computing bound for 'C'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	mov rax, [rel const514] ; 904
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3627
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3627:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3628
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3628:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3629
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3629:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3630: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3630 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3630 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3630 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3631
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3631:
	; Computing bound for 'B'
	mov rax, [rel const515] ; 359
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3632
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3632:
	; Computing bound for 'A'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3633
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3633:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3634
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3634:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump3635
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3635:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump3636
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3636:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3637: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3637 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3637 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3638
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3638:
	cmp rax, [rsp + 16]
	jl .jump3639
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3639:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3640
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3640:
	cmp rax, [rsp + 24]
	jl .jump3641
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3641:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3642
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3642:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (array[A : k, B : w] p)[i, r] 
	jno .jump3643
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3643:
	imul rdi, [rsp + 0 + 8] ; multiply by 359 
	jno .jump3644
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3644:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[A : l, B : q, C : 904] h) 
	jno .jump3645
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3645:
	imul rdi, [rsp + 0 + 24] ; multiply by c 
	jno .jump3646
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump3646:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3647: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3647 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3647 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3647 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3647 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump3612:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3648
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3648:
	cmp rax, [rsp + 32]
	jl .jump3649
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3649:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3650
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3650:
	cmp rax, [rsp + 40]
	jl .jump3651
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3651:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3652
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3652:
	cmp rax, [rsp + 48]
	jl .jump3653
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3653:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3654
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3654:
	cmp rax, [rsp + 56]
	jl .jump3655
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3655:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3656
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	jmp .jump3657
.jump3656:
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
.jump3657:
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3658
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3658:
	cmp rax, [rsp + 32]
	jl .jump3659
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3659:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3660
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3660:
	cmp rax, [rsp + 40]
	jl .jump3661
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3661:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3662
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3662:
	cmp rax, [rsp + 48]
	jl .jump3663
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3663:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3664
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3664:
	cmp rax, [rsp + 56]
	jl .jump3665
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3665:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump3411:
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3666
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3666:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3667
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3667:
	; Computing bound for 'B'
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3668
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3670
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3672
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3672:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3673
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3673:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump3674
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3674:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump3675
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3675:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3676: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const516] ; 78.19
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3676 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3676 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump3671
.jump3670:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3677
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3677:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3678
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3678:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump3679
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3679:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump3680
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3680:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3681: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const517] ; 12.39
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3681 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3681 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump3671:
	jmp .jump3669
.jump3668:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3682
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3682:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3683
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3683:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump3684
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3684:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump3685
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3685:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3686: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const518] ; 77.68
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3686 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3686 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump3669:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3687
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3687:
	cmp rax, [rsp + 16]
	jl .jump3688
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3688:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3689
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3689:
	cmp rax, [rsp + 24]
	jl .jump3690
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3690:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump3691
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
.jump3691:
	push rax
	pop rax
	cmp rax, 0
	je .jump3692
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3694
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3694:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3695
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3695:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3696
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3696:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3697: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const519] ; 28.97
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3697 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3697 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3697 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump3693
.jump3692:
	mov rax, [rel const520] ; 29.37
	push rax
.jump3693:
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3698
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3700
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3700:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3701
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3701:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3702: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const521] ; 352
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3702 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3702 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3703
	lea rdi, [rel const8] ; 'divide by zero'
	call _fail_assertion
.jump3703:
	cqo
	idiv r10
	push rax
	jmp .jump3699
.jump3698:
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
.jump3699:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3704
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3704:
	; Computing bound for 'A'
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump3705
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	jmp .jump3706
.jump3705:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3707
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3707:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3708
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3708:
	cmp rax, [rsp + 8]
	jl .jump3709
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3709:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3710
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3710:
	; Computing bound for 'A'
	mov rax, [rel const522] ; 870
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3711
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3711:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3712: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 384 to rsp 
		mov r10, [rbp - 384 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3712 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3712 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3712 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump3706:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3713
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump3713:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3714: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 368 to rsp 
		mov r10, [rbp - 368 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3714 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3714 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3714 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3714 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3715
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3715:
	cmp rax, [rsp + 24]
	jl .jump3716
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3716:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3717
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3717:
	cmp rax, [rsp + 32]
	jl .jump3718
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3718:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3719
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump3719:
	cmp rax, [rsp + 40]
	jl .jump3720
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump3720:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	lea rdi, [rel const523] ; 'A.png'
	call _write_image
	add rsp, 24
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	push rax
	lea rdi, [rel const560] ; '(VoidType)'
	lea rsi, [rsp]
	call _show
	add rsp, 8
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4211
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4211:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4212
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4212:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4213
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4213:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump4214
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4214:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump4215
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4215:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump4216
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4216:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump4217: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	mov rax, [rel const561] ; 76.54
	push rax
	mov rax, [rel const562] ; 22.81
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const0] ; 12.03
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4218
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4218:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 304 to rsp 
		mov r10, [rbp - 304 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4219
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4219:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 312 to rsp 
		mov r10, [rbp - 312 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4220
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4220:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump4221: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const563] ; 23.71
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'H'
	add qword [rsp + 16], 1
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4221 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4221 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4221 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4222
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4222:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4223
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4223:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4224
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4224:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4225
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4225:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump4226: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const564] ; 3.19
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'I'
	add qword [rsp + 24], 1
	; Compare I to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4226 ; If I < bound, next iter
	mov qword [rsp + 24], 0 ; I = 0
	add qword [rsp + 16], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4226 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4226 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4226 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4227
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4227:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4228
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4228:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4229
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4229:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump4230
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4230:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump4231
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4231:
	imul rdi, [rsp + 0 + 16] ; multiply by A 
	jno .jump4232
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4232:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump4233: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const565] ; 8.17
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'H'
	add qword [rsp + 16], 1
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4233 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4233 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4233 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 312 to rsp 
		mov r10, [rbp - 312 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 296 to rsp 
		mov r10, [rbp - 296 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4234
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4234:
	cmp rax, [rsp + 24]
	jl .jump4235
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4235:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4236
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4236:
	cmp rax, [rsp + 32]
	jl .jump4237
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4237:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4238
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4238:
	cmp rax, [rsp + 40]
	jl .jump4239
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4239:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'E'
	add qword [rsp + 16], 1
	; Compare E to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4217 ; If E < bound, next iter
	mov qword [rsp + 16], 0 ; E = 0
	add qword [rsp + 8], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4217 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4217 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4240
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4240:
	cmp rax, [rsp + 24]
	jl .jump4241
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4241:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4242
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4242:
	cmp rax, [rsp + 32]
	jl .jump4243
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4243:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4244
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4244:
	cmp rax, [rsp + 40]
	jl .jump4245
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4245:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4246
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4246:
	; Computing bound for 'D'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4247
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4247:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4248
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4248:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4249
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4249:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump4250: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'E'
	add qword [rsp + 16], 1
	; Compare E to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4250 ; If E < bound, next iter
	mov qword [rsp + 16], 0 ; E = 0
	add qword [rsp + 8], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4250 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4250 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4251
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4251:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump4252: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'C'
	add qword [rsp + 0], 1
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4252 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4253
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4253:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4254
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4254:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump4255
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4255:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[C : (sum[C : A, D : s, E : d] c)] n) 
	jno .jump4256
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4256:
	imul rdi, [rsp + 0 + 16] ; multiply by d 
	jno .jump4257
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4257:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump4258: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 216 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'E'
	add qword [rsp + 16], 1
	; Compare E to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4258 ; If E < bound, next iter
	mov qword [rsp + 16], 0 ; E = 0
	add qword [rsp + 8], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4258 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4258 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4259
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4259:
	cmp rax, [rsp + 24]
	jl .jump4260
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4260:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4261
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4261:
	cmp rax, [rsp + 32]
	jl .jump4262
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4262:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4263
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4263:
	cmp rax, [rsp + 40]
	jl .jump4264
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4264:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4265
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4265:
	cmp rax, [rsp + 16]
	jl .jump4266
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4266:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4267
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4267:
	cmp rax, [rsp + 24]
	jl .jump4268
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4268:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	pop rdi
	pop rsi
	call _B
	add rsp, 32
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4269
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4269:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4270
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4270:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4271
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4271:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4272
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4272:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump4273
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4273:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump4274
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4274:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump4275
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4275:
imul rdi, [rsp + 0 + 24] ; multiply by B((array[C : c, D : h, E : b] rgba {(array[F : c, G : n, H : A] 8.17)[m, E, C], (sum[F : b, G : w, H : c, I : c] 3.19), ((sum[F : C, G : D, H : l] 23.71) / 12.03), (22.81 % 76.54)})[A, A, r], (array[C : q, D : (sum[C : (sum[C : A, D : s, E : d] c)] n), E : d] t)[k, n, p][q, n].g, i, d) 
	jno .jump4276
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4276:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump4277: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'F'
	add qword [rsp + 24], 1
	; Compare F to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4277 ; If F < bound, next iter
	mov qword [rsp + 24], 0 ; F = 0
	add qword [rsp + 16], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4277 ; If E < bound, next iter
	mov qword [rsp + 16], 0 ; E = 0
	add qword [rsp + 8], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4277 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4277 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8 ; Add alignment
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4491
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4491:
	; Computing bound for 'K'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4492
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4492:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4493
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4493:
	; Computing bound for 'I'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4494
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4494:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4495
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4495:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4496: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'J'
	add qword [rsp + 8], 1
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4496 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4496 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4497
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4497:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4498: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'K'
	add qword [rsp + 16], 1
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4498 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4498 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4498 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4499
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4499:
	; Computing bound for 'J'
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4500
	mov rax, [rel const584] ; 258
	push rax
	jmp .jump4501
.jump4500:
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
.jump4501:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4502
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4502:
	; Computing bound for 'I'
	mov rax, [rel const548] ; 281
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4503
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4503:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by 281 
	jno .jump4504
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4504:
	imul rdi, [rsp + 0 + 8] ; multiply by (if true then 258 else D) 
	jno .jump4505
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4505:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[I : (sum[I : d, J : n] w), J : d, K : k] F) 
	jno .jump4506
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4506:
	imul rdi, [rsp + 0 + 24] ; multiply by G 
	jno .jump4507
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4507:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4508: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	mov rax, [rel const2] ; True
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4509
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump4510
.jump4509:
	mov rax, [rel const585] ; 7.49
	push rax
.jump4510:
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 24], 1
	; Compare L to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4508 ; If L < bound, next iter
	mov qword [rsp + 24], 0 ; L = 0
	add qword [rsp + 16], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4508 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4508 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4508 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const586] ; 855
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4511
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4511:
	cmp rax, [rsp + 32]
	jl .jump4512
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4512:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4513
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4513:
	cmp rax, [rsp + 40]
	jl .jump4514
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4514:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4515
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4515:
	cmp rax, [rsp + 48]
	jl .jump4516
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4516:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4517
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4517:
	cmp rax, [rsp + 56]
	jl .jump4518
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4518:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const587] ; 19.27
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4519
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4519:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4520: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4521
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump4523
	mov rax, [rel const588] ; 84.92
	push rax
	jmp .jump4524
.jump4523:
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
.jump4524:
	jmp .jump4522
.jump4521:
	mov rax, [rel const589] ; 35.54
	push rax
.jump4522:
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'I'
	add qword [rsp + 0], 1
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4520 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const590] ; 75.68
	push rax
	mov rax, [rel const591] ; 65.89
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	pop rdi
	pop rsi
	call _B
	add rsp, 32
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4525
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4525:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4526
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4526:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4527
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4527:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4528
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4528:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump4529
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4529:
	imul rdi, [rsp + 0 + 8] ; multiply by G 
	jno .jump4530
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4530:
	imul rdi, [rsp + 0 + 16] ; multiply by G 
	jno .jump4531
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4531:
imul rdi, [rsp + 0 + 24] ; multiply by B(rgba {(H() - (sum[I : i] ((H() * H()) - (if false then (if f() then 84.92 else H()) else 35.54)))), 19.27, (array[I : 281, J : (if true then 258 else D), K : (sum[I : (sum[I : d, J : n] w), J : d, K : k] F), L : G] (- (if (true != f()) then (H() - H()) else 7.49)))[D, q, h, 855], H()}, (65.89 - 75.68), m, E) 
	jno .jump4532
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4532:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4533: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 24], 1
	; Compare L to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4533 ; If L < bound, next iter
	mov qword [rsp + 24], 0 ; L = 0
	add qword [rsp + 16], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4533 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4533 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4533 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 32
	; Moving 32 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 184 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 184 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4734
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4734:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4735
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4735:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4736
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4736:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump4737
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4737:
	imul rdi, [rsp + 0 + 8] ; multiply by D 
	jno .jump4738
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4738:
	imul rdi, [rsp + 0 + 16] ; multiply by q 
	jno .jump4739
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4739:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump4740: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 416 to rsp 
		mov r10, [rbp - 416 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'M'
	add qword [rsp + 16], 1
	; Compare M to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4740 ; If M < bound, next iter
	mov qword [rsp + 16], 0 ; M = 0
	add qword [rsp + 8], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4740 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4740 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4741
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump4742
.jump4741:
	mov rax, [rel const5] ; False
	push rax
.jump4742:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4743
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4745
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4745:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by D 
	jno .jump4746
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4746:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump4747: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4748
	sub rsp, 32
	; Moving 32 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 184 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 184 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	jmp .jump4749
.jump4748:
	sub rsp, 32
	; Moving 32 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 184 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 184 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
.jump4749:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'K'
	add qword [rsp + 0], 1
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4747 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4750
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4750:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4751
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4751:
	; Computing bound for 'L'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4752
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4752:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4753
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4753:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4754
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4754:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump4755: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 472 to rsp 
		mov r10, [rbp - 472 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'M'
	add qword [rsp + 16], 1
	; Compare M to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4755 ; If M < bound, next iter
	mov qword [rsp + 16], 0 ; M = 0
	add qword [rsp + 8], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4755 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4755 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4756
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4756:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4757
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4757:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump4758: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'N'
	add qword [rsp + 24], 1
	; Compare N to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4758 ; If N < bound, next iter
	mov qword [rsp + 24], 0 ; N = 0
	add qword [rsp + 16], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4758 ; If M < bound, next iter
	mov qword [rsp + 16], 0 ; M = 0
	add qword [rsp + 8], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4758 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4758 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4759
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4759:
	cmp rax, [rsp + 8]
	jl .jump4760
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4760:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4744
.jump4743:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4761
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4761:
	; Computing bound for 'M'
	mov rax, [rel const603] ; 339
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4762
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4762:
	; Computing bound for 'L'
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4763
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	jmp .jump4764
.jump4763:
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
.jump4764:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4765
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4765:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4766
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4766:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump4767
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4767:
	imul rdi, [rsp + 0 + 8] ; multiply by (if true then s else G) 
	jno .jump4768
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4768:
	imul rdi, [rsp + 0 + 16] ; multiply by 339 
	jno .jump4769
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4769:
	imul rdi, [rsp + 0 + 24] ; multiply by E 
	jno .jump4770
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4770:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump4771: ; Begin body of loop
	; Compute loop body
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump4772
	sub rsp, 32
	; Moving 32 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 184 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 184 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	jmp .jump4773
.jump4772:
	sub rsp, 32
	; Moving 32 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 184 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 184 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
.jump4773:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'N'
	add qword [rsp + 24], 1
	; Compare N to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4771 ; If N < bound, next iter
	mov qword [rsp + 24], 0 ; N = 0
	add qword [rsp + 16], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4771 ; If M < bound, next iter
	mov qword [rsp + 16], 0 ; M = 0
	add qword [rsp + 8], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4771 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4771 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4774
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4774:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by D 
	jno .jump4775
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4775:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump4776: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const262] ; 520
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 0], 1
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4776 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4777
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4777:
	cmp rax, [rsp + 8]
	jl .jump4778
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4778:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4779
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4779:
	cmp rax, [rsp + 32]
	jl .jump4780
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4780:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4781
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4781:
	cmp rax, [rsp + 40]
	jl .jump4782
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4782:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4783
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4783:
	cmp rax, [rsp + 48]
	jl .jump4784
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4784:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4785
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4785:
	cmp rax, [rsp + 56]
	jl .jump4786
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4786:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4744:
	mov rdi, 96
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 96 bytes from rsp to rax 
		mov r10, [rsp + 88]
		mov [rax + 88], r10
		mov r10, [rsp + 80]
		mov [rax + 80], r10
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 96
	push rax
	mov rax, 3
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const2] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4787
	mov rax, [rel const5] ; False
	push rax
	pop rax
.jump4787:
	push rax
	pop rax
	cmp rax, 0
	je .jump4788
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	jmp .jump4789
.jump4788:
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
.jump4789:
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4790
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4790:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by ((if ((! true) && false) then k else q) + h) 
	jno .jump4791
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4791:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump4792: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 184 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 184 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'K'
	add qword [rsp + 0], 1
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4792 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 2
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4793
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4793:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4794
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4794:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump4795
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4795:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump4796
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4796:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump4797: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 8], 1
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4797 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4797 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4798
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4798:
	cmp rax, [rsp + 16]
	jl .jump4799
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4799:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4800
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4800:
	cmp rax, [rsp + 24]
	jl .jump4801
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4801:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4802
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4802:
	cmp rax, [rsp + 8]
	jl .jump4803
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4803:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4804
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4804:
	cmp rax, [rsp + 8]
	jl .jump4805
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4805:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4806
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4806:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4807
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4807:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4808
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4808:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4809
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4809:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4810: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4811
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4811:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump4812: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const604] ; 96.37
	push rax
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4813
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4813:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4814
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4814:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 432 to rsp 
		mov r10, [rbp - 432 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4815
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4815:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump4816: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'V'
	add qword [rsp + 16], 1
	; Compare V to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4816 ; If V < bound, next iter
	mov qword [rsp + 16], 0 ; V = 0
	add qword [rsp + 8], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4816 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4816 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4817
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4817:
	cmp rax, [rsp + 8]
	jl .jump4818
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4818:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'S'
	add qword [rsp + 0], 1
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4812 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'R'
	add qword [rsp + 24], 1
	; Compare R to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4810 ; If R < bound, next iter
	mov qword [rsp + 24], 0 ; R = 0
	add qword [rsp + 16], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4810 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4810 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4810 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 352 to rsp 
		mov r10, [rbp - 352 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4819
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4819:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4820
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4820:
	; Computing bound for 'P'
	sub rsp, 16
	; Moving 16 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4821
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4821:
	cmp rax, [rsp + 8]
	jl .jump4822
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4822:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4823
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4823:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4824
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4824:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump4825
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4825:
	imul rdi, [rsp + 0 + 8] ; multiply by v[s] 
	jno .jump4826
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4826:
	imul rdi, [rsp + 0 + 16] ; multiply by (E - w) 
	jno .jump4827
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4827:
	imul rdi, [rsp + 0 + 24] ; multiply by M 
	jno .jump4828
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4828:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4829: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4830
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4830:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 416 to rsp 
		mov r10, [rbp - 416 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4831
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4831:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4832
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4832:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump4833: ; Begin body of loop
	; Compute loop body
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'U'
	add qword [rsp + 16], 1
	; Compare U to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4833 ; If U < bound, next iter
	mov qword [rsp + 16], 0 ; U = 0
	add qword [rsp + 8], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4833 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4833 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'R'
	add qword [rsp + 24], 1
	; Compare R to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4829 ; If R < bound, next iter
	mov qword [rsp + 24], 0 ; R = 0
	add qword [rsp + 16], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4829 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4829 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4829 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4834
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4834:
	cmp rax, [rsp + 32]
	jl .jump4835
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4835:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4836
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4836:
	cmp rax, [rsp + 40]
	jl .jump4837
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4837:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4838
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4838:
	cmp rax, [rsp + 48]
	jl .jump4839
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4839:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4840
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4840:
	cmp rax, [rsp + 56]
	jl .jump4841
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4841:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const605] ; 7.22
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 352 to rsp 
		mov r10, [rbp - 352 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4842
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4842:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4843: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'O'
	add qword [rsp + 0], 1
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4843 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const606] ; 27.66
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const607] ; 88.91
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const5] ; False
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 360 to rsp 
		mov r10, [rbp - 360 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4844
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4844:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4845
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4845:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4846
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4846:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4847
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4847:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof void[] 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump4848
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4848:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump4849
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4849:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump4850
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4850:
	imul rdi, [rsp + 0 + 24] ; multiply by L 
	jno .jump4851
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4851:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4852: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	push rax
	call _z
	push rax
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	push rax
	call _z
	push rax
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'R'
	add qword [rsp + 24], 1
	; Compare R to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4852 ; If R < bound, next iter
	mov qword [rsp + 24], 0 ; R = 0
	add qword [rsp + 16], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4852 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4852 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4852 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4853
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4853:
	cmp rax, [rsp + 32]
	jl .jump4854
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4854:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4855
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4855:
	cmp rax, [rsp + 40]
	jl .jump4856
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4856:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4857
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4857:
	cmp rax, [rsp + 48]
	jl .jump4858
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4858:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4859
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4859:
	cmp rax, [rsp + 56]
	jl .jump4860
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4860:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4861
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4861:
	cmp rax, [rsp + 8]
	jl .jump4862
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4862:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 32 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 24]
		mov [rsp + 24 + 24], r10
		mov r10, [rsp + 16 + 16]
		mov [rsp + 24 + 16], r10
		mov r10, [rsp + 16 + 8]
		mov [rsp + 24 + 8], r10
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4863
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4863:
	; Computing bound for 'P'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4864
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4864:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4865
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4865:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4866
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4866:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by G 
	jno .jump4867
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4867:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump4868
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4868:
	imul rdi, [rsp + 0 + 16] ; multiply by q 
	jno .jump4869
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4869:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4870: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const2] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4870 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4870 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4870 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4871
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4871:
	cmp rax, [rsp + 24]
	jl .jump4872
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4872:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4873
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4873:
	cmp rax, [rsp + 32]
	jl .jump4874
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4874:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4875
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4875:
	cmp rax, [rsp + 40]
	jl .jump4876
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4876:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump4877
	mov rax, [rel const5] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4878
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
.jump4878:
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump4877:
	push rax
	pop rax
	cmp rax, 0
	je .jump4879
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 344 to rsp 
		mov r10, [rbp - 344 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4881
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4881:
	; Computing bound for 'O'
	mov rax, [rel const514] ; 904
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4882
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4882:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 904 
	jno .jump4883
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4883:
	imul rdi, [rsp + 0 + 8] ; multiply by N 
	jno .jump4884
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4884:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4885: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'P'
	add qword [rsp + 8], 1
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4885 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4885 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump4880
.jump4879:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4886
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4886:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4887
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4887:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4888
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4888:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4889
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4889:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump4890
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4890:
	imul rdi, [rsp + 0 + 8] ; multiply by G 
	jno .jump4891
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4891:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump4892
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4892:
	imul rdi, [rsp + 0 + 24] ; multiply by c 
	jno .jump4893
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4893:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4894: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4895
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4895:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4896
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4896:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump4897
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4897:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump4898
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4898:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump4899: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'T'
	add qword [rsp + 8], 1
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4899 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4899 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'R'
	add qword [rsp + 24], 1
	; Compare R to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4894 ; If R < bound, next iter
	mov qword [rsp + 24], 0 ; R = 0
	add qword [rsp + 16], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4894 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4894 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4894 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4900
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4900:
	cmp rax, [rsp + 32]
	jl .jump4901
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4901:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4902
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4902:
	cmp rax, [rsp + 40]
	jl .jump4903
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4903:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4904
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4904:
	cmp rax, [rsp + 48]
	jl .jump4905
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4905:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4906
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4906:
	cmp rax, [rsp + 56]
	jl .jump4907
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4907:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4880:
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4908
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4908:
	cmp rax, [rsp + 16]
	jl .jump4909
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4909:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4910
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4910:
	cmp rax, [rsp + 24]
	jl .jump4911
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4911:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4912
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4912:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 344 to rsp 
		mov r10, [rbp - 344 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4913
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4913:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4914: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const608] ; 19.68
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4914 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4914 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4914 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4915
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4915:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4916
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4916:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4917: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4918
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4918:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4919
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4919:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4920
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4920:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4921
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4921:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump4922: ; Begin body of loop
	; Compute loop body
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'T'
	add qword [rsp + 24], 1
	; Compare T to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4922 ; If T < bound, next iter
	mov qword [rsp + 24], 0 ; T = 0
	add qword [rsp + 16], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4922 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4922 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4922 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'P'
	add qword [rsp + 8], 1
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4917 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4917 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4923
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4923:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4924: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4925
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4925:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump4926: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const609] ; 2.12
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'P'
	add qword [rsp + 0], 1
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4926 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'O'
	add qword [rsp + 0], 1
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4924 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump4927
	mov rax, [rel const2] ; True
	push rax
	pop rax
.jump4927:
	push rax
	pop rax
	xor rax, 1
	push rax
	call _z
	push rax
	; Moving 8 bytes from rsp + 8 to rsp + 48 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	pop rax
	cmp rax, 0
	je .jump4928
	mov rax, [rel const610] ; 35.44
	push rax
	sub rsp, 24
	; Moving 24 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 216 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4930
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump4931
.jump4930:
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
.jump4931:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4932
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4932:
	cmp rax, [rsp + 16]
	jl .jump4933
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4933:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4934
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4934:
	cmp rax, [rsp + 24]
	jl .jump4935
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4935:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4936
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const5] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4938
	mov rax, [rel const611] ; 33.58
	push rax
	jmp .jump4939
.jump4938:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 352 to rsp 
		mov r10, [rbp - 352 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4940
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4940:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4941
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4941:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4942
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4942:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4943
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4943:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4944: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const612] ; 76.03
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'R'
	add qword [rsp + 24], 1
	; Compare R to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4944 ; If R < bound, next iter
	mov qword [rsp + 24], 0 ; R = 0
	add qword [rsp + 16], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4944 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4944 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4944 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
.jump4939:
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const613] ; 87.8
	push rax
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4945
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4945:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 352 to rsp 
		mov r10, [rbp - 352 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4946
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4946:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by M 
	jno .jump4947
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4947:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump4948
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4948:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4949: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const2] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'P'
	add qword [rsp + 8], 1
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4949 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4949 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 360 to rsp 
		mov r10, [rbp - 360 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4950
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4950:
	cmp rax, [rsp + 16]
	jl .jump4951
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4951:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4952
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4952:
	cmp rax, [rsp + 24]
	jl .jump4953
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4953:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4954
	mov rax, [rel const2] ; True
	push rax
	pop rax
.jump4954:
	push rax
	pop rax
	cmp rax, 0
	je .jump4955
	mov rax, [rel const5] ; False
	push rax
	jmp .jump4956
.jump4955:
	call _f
	push rax
.jump4956:
	pop rax
	cmp rax, 0
	je .jump4957
	call _z
	push rax
	jmp .jump4958
.jump4957:
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump4959
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4961
	call _z
	push rax
	jmp .jump4962
.jump4961:
	call _z
	push rax
.jump4962:
	jmp .jump4960
.jump4959:
	call _z
	push rax
.jump4960:
.jump4958:
	jmp .jump4937
.jump4936:
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4963
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4965
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4965:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4966: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const614] ; 22.67
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'O'
	add qword [rsp + 0], 1
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4966 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const615] ; 2.76
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 352 to rsp 
		mov r10, [rbp - 352 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4967
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4967:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4968
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4968:
	; Computing bound for 'P'
	mov rax, [rel const616] ; 117
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4969
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4969:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4970
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4970:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4971: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'R'
	add qword [rsp + 24], 1
	; Compare R to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4971 ; If R < bound, next iter
	mov qword [rsp + 24], 0 ; R = 0
	add qword [rsp + 16], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4971 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4971 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4971 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const5] ; False
	push rax
	call _f
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4972
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4972:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4973
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4973:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 352 to rsp 
		mov r10, [rbp - 352 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4974
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4974:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by M 
	jno .jump4975
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4975:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump4976
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4976:
	imul rdi, [rsp + 0 + 16] ; multiply by D 
	jno .jump4977
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump4977:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4978: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4978 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4978 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4978 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4979
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4979:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4980
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4980:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4981
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4981:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4982: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4982 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4982 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4982 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4983
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4983:
	cmp rax, [rsp + 24]
	jl .jump4984
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4984:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4985
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4985:
	cmp rax, [rsp + 32]
	jl .jump4986
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4986:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4987
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4987:
	cmp rax, [rsp + 40]
	jl .jump4988
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4988:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4964
.jump4963:
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const617] ; 1.6
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4989
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4989:
	; Computing bound for 'P'
	mov rax, [rel const35] ; 607
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4990
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4990:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4991
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump4991:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4992: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const618] ; 92.02
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4992 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4992 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4992 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const619] ; 52.92
	push rax
	mov rax, [rel const620] ; 70.79
	push rax
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4993
	sub rsp, 32
	; Moving 32 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 352 to rsp 
		mov r10, [rbp - 352 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4995
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4995:
	cmp rax, [rsp + 24]
	jl .jump4996
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4996:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4997
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4997:
	cmp rax, [rsp + 32]
	jl .jump4998
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump4998:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4999
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump4999:
	cmp rax, [rsp + 40]
	jl .jump5000
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5000:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4994
.jump4993:
	mov rax, [rel const2] ; True
	push rax
.jump4994:
	call _z
	push rax
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	push rax
	call _z
	push rax
	sub rsp, 8 ; Add alignment
	call _z
	add rsp, 8 ; Remove alignment
	push rax
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5001
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5001:
	cmp rax, [rsp + 8]
	jl .jump5002
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5002:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4964:
.jump4937:
	jmp .jump4929
.jump4928:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'P'
	mov rax, [rel const2] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5003
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	jmp .jump5004
.jump5003:
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
.jump5004:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5005
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5005:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5006
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5006:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump5007: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5008
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5008:
	cmp rax, [rsp + 16]
	jl .jump5009
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5009:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5010
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5010:
	cmp rax, [rsp + 24]
	jl .jump5011
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5011:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5012
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump5013
.jump5012:
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
.jump5013:
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'P'
	add qword [rsp + 8], 1
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5007 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5007 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5014
	mov rax, [rel const621] ; 84.53
	push rax
	jmp .jump5015
.jump5014:
	mov rax, [rel const622] ; 41.32
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump5015:
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 352 to rsp 
		mov r10, [rbp - 352 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5016
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5016:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump5017: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const623] ; 63.18
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'O'
	add qword [rsp + 0], 1
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5017 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump5018
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump5019
.jump5018:
	mov rax, [rel const624] ; 70.71
	push rax
.jump5019:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const625] ; 20.78
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5020
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5020:
	; Computing bound for 'O'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5021
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5021:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5022
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5022:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5023
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5023:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5024
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5024:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump5025: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'R'
	add qword [rsp + 24], 1
	; Compare R to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5025 ; If R < bound, next iter
	mov qword [rsp + 24], 0 ; R = 0
	add qword [rsp + 16], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5025 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5025 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5025 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5026
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5026:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump5027: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const626] ; 11.72
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'P'
	add qword [rsp + 8], 1
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5027 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5027 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5028
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5028:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5029
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5029:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5030
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5030:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5031
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5031:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump5032
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5032:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump5033
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5033:
	imul rdi, [rsp + 0 + 16] ; multiply by c 
	jno .jump5034
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5034:
	imul rdi, [rsp + 0 + 24] ; multiply by d 
	jno .jump5035
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5035:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump5036: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'R'
	add qword [rsp + 24], 1
	; Compare R to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5036 ; If R < bound, next iter
	mov qword [rsp + 24], 0 ; R = 0
	add qword [rsp + 16], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5036 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5036 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5036 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 360 to rsp 
		mov r10, [rbp - 360 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 344 to rsp 
		mov r10, [rbp - 344 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5037
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5037:
	cmp rax, [rsp + 32]
	jl .jump5038
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5038:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5039
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5039:
	cmp rax, [rsp + 40]
	jl .jump5040
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5040:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5041
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5041:
	cmp rax, [rsp + 48]
	jl .jump5042
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5042:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5043
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5043:
	cmp rax, [rsp + 56]
	jl .jump5044
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5044:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const2] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5045
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5045:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5046
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5046:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5047
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5047:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (- h) 
	jno .jump5048
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5048:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump5049
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5049:
	imul rdi, [rsp + 0 + 16] ; multiply by G 
	jno .jump5050
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5050:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump5051: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5051 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5051 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5051 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 360 to rsp 
		mov r10, [rbp - 360 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 352 to rsp 
		mov r10, [rbp - 352 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5052
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5052:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5053
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5053:
	cmp rax, [rsp + 24]
	jl .jump5054
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5054:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5055
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5055:
	cmp rax, [rsp + 32]
	jl .jump5056
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5056:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5057
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5057:
	cmp rax, [rsp + 40]
	jl .jump5058
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5058:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5059
	call _z
	push rax
	jmp .jump5060
.jump5059:
	call _z
	push rax
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 352 to rsp 
		mov r10, [rbp - 352 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5061
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5061:
	cmp rax, [rsp + 8]
	jl .jump5062
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5062:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5060:
.jump4929:
	; Moving 8 bytes from rsp + 48 to rsp + 48 
		mov r10, [rsp + 48 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	sub rsp, 8 ; Add alignment
	call _get_time
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	call _f
	push rax
	pop rax
	cmp rax, 0
	jne .jump5063
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
.jump5063:
	push rax
	pop rax
	cmp rax, 0
	je .jump5064
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	jmp .jump5065
.jump5064:
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
.jump5065:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5066
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5066:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5067
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5067:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,][][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by A 
	jno .jump5068
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5068:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (f() || (d == c)) then G else G) 
	jno .jump5069
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5069:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5070: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5071
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5071:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5072
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5072:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5073
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5073:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5074
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5074:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof rgba[,][] 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump5075
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5075:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump5076
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5076:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump5077
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5077:
	imul rdi, [rsp + 0 + 24] ; multiply by r 
	jno .jump5078
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5078:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump5079: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - 440 to rsp 
		mov r10, [rbp - 440 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5080
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5080:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by Q 
	jno .jump5081
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5081:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump5082: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 216 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'V'
	add qword [rsp + 0], 1
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5082 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'U'
	add qword [rsp + 24], 1
	; Compare U to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5079 ; If U < bound, next iter
	mov qword [rsp + 24], 0 ; U = 0
	add qword [rsp + 16], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5079 ; If T < bound, next iter
	mov qword [rsp + 16], 0 ; T = 0
	add qword [rsp + 8], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5079 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5079 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'Q'
	add qword [rsp + 8], 1
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5070 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5070 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5083
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5083:
	cmp rax, [rsp + 16]
	jl .jump5084
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5084:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5085
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5085:
	cmp rax, [rsp + 24]
	jl .jump5086
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5086:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 40
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'R'
	mov rax, [rel const259] ; 754
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5087
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5087:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5088
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5088:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5089
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5089:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5090: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'R'
	add qword [rsp + 16], 1
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5090 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5090 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5090 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5091
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5091:
	cmp rax, [rsp + 32]
	jl .jump5092
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5092:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5093
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5093:
	cmp rax, [rsp + 40]
	jl .jump5094
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5094:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5095
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5095:
	cmp rax, [rsp + 48]
	jl .jump5096
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5096:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5097
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5097:
	cmp rax, [rsp + 56]
	jl .jump5098
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5098:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5099
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5099:
	cmp rax, [rsp + 8]
	jl .jump5100
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5100:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	lea rdi, [rel const627] ; 'P.png'
	call _write_image
	add rsp, 24
	add rsp, 8 ; Remove alignment
	call _get_time
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp + 0]
	subsd xmm0, xmm1
	call _print_time
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8 ; Add alignment
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump5101
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5103
	sub rsp, 32
	; Moving 32 bytes from rbp - 392 to rsp 
		mov r10, [rbp - 392 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 392 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 392 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 392 + 0]
		mov [rsp + 0], r10
	jmp .jump5104
.jump5103:
	mov rax, [rel const628] ; 71.97
	push rax
	sub rsp, 32
	; Moving 32 bytes from rbp - 392 to rsp 
		mov r10, [rbp - 392 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 392 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 392 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 392 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const2] ; True
	push rax
	call _z
	push rax
	; Moving 32 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 24]
		mov [rsp + 24 + 24], r10
		mov r10, [rsp + 16 + 16]
		mov [rsp + 24 + 16], r10
		mov r10, [rsp + 16 + 8]
		mov [rsp + 24 + 8], r10
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
.jump5104:
	jmp .jump5102
.jump5101:
	sub rsp, 32
	; Moving 32 bytes from rbp - 392 to rsp 
		mov r10, [rbp - 392 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 392 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 392 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 392 + 0]
		mov [rsp + 0], r10
.jump5102:
	sub rsp, 8
	; Moving 8 bytes from rbp - 344 to rsp 
		mov r10, [rbp - 344 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const629] ; 14.45
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	pop rdi
	pop rsi
	call _B
	add rsp, 32
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5105
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5105:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by B((if f() then (if (H() < H()) then O else u {z(), true, O, 71.97}.c) else O), 14.45, G, N) 
	jno .jump5106
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5106:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5107: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 352 to rsp 
		mov r10, [rbp - 352 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'P'
	add qword [rsp + 0], 1
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5107 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5108
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5108:
	cmp rax, [rsp + 8]
	jl .jump5109
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5109:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5110
	sub rsp, 40
	; Moving 40 bytes from rbp - 328 to rsp 
		mov r10, [rbp - 328 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 328 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 328 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 328 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 328 + 0]
		mov [rsp + 0], r10
	jmp .jump5111
.jump5110:
	sub rsp, 40
	; Moving 40 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 288 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 288 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 288 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
.jump5111:
	sub rsp, 24
	; Moving 24 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 216 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Z'
	sub rsp, 8 ; Add alignment
	mov rax, [rel const663] ; 86.92
	push rax
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const5] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5598
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from rbp - 432 to rsp 
		mov r10, [rbp - 432 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5600
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5600:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5601
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5601:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump5602: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'aa'
	add qword [rsp + 8], 1
	; Compare aa to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5602 ; If aa < bound, next iter
	mov qword [rsp + 8], 0 ; aa = 0
	add qword [rsp + 0], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5602 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 32
	; Moving 32 bytes from rbp - 392 to rsp 
		mov r10, [rbp - 392 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 392 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 392 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 392 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 32
	; Moving 32 bytes from rbp - 392 to rsp 
		mov r10, [rbp - 392 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 392 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 392 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 392 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 360 to rsp 
		mov r10, [rbp - 360 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	call _z
	push rax
	jmp .jump5599
.jump5598:
	sub rsp, 24
	; Moving 24 bytes from rbp - 464 to rsp 
		mov r10, [rbp - 464 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 464 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 464 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 424 to rsp 
		mov r10, [rbp - 424 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5603
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5603:
	cmp rax, [rsp + 16]
	jl .jump5604
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5604:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5605
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5605:
	cmp rax, [rsp + 24]
	jl .jump5606
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5606:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 32
	; Moving 32 bytes from rbp - 392 to rsp 
		mov r10, [rbp - 392 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 392 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 392 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 392 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const664] ; 61.05
	push rax
	call _H
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5607
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 432 to rsp 
		mov r10, [rbp - 432 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5609
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5609:
	cmp rax, [rsp + 24]
	jl .jump5610
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5610:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5611
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5611:
	cmp rax, [rsp + 32]
	jl .jump5612
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5612:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5613
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
.jump5613:
	cmp rax, [rsp + 40]
	jl .jump5614
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
.jump5614:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5608
.jump5607:
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5615
	mov rax, [rel const2] ; True
	push rax
	pop rax
.jump5615:
	push rax
.jump5608:
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5616
	call _f
	push rax
	pop rax
	cmp rax, 0
	je .jump5618
	call _z
	push rax
	jmp .jump5619
.jump5618:
	call _z
	push rax
.jump5619:
	jmp .jump5617
.jump5616:
	call _z
	push rax
.jump5617:
.jump5599:
	; Moving 8 bytes from rsp + 48 to rsp + 48 
		mov r10, [rsp + 48 + 0]
		mov [rsp + 48 + 0], r10
	add rsp, 48
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5620
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5620:
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5621
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5621:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5622
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5622:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump5623: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ad'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 344 to rsp 
		mov r10, [rbp - 344 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5624
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5624:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5625
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5625:
	; Computing bound for 'ac'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ac'
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5626
	sub rsp, 8
	; Moving 8 bytes from rbp - 560 to rsp 
		mov r10, [rbp - 560 + 0]
		mov [rsp + 0], r10
	jmp .jump5627
.jump5626:
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
.jump5627:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5628
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5628:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if true then Z else G) 
	jno .jump5629
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5629:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
.jump5630: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ac'
	add qword [rsp + 0], 1
	; Compare ac to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5630 ; If ac < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5631
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5631:
	cmp rax, [rsp + 8]
	jl .jump5632
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5632:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5633
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5633:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ad' to 0
	mov rax, 0
	push rax
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
.jump5634: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const5] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5635
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump5636
.jump5635:
	sub rsp, 8 ; Add alignment
	call _f
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	jne .jump5637
	mov rax, [rel const5] ; False
	push rax
	pop rax
.jump5637:
	push rax
.jump5636:
	pop rax
	cmp rax, 0
	je .jump5638
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump5639
.jump5638:
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
.jump5639:
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'ad'
	add qword [rsp + 8], 1
	; Compare ad to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5634 ; If ad < bound, next iter
	mov qword [rsp + 8], 0 ; ad = 0
	add qword [rsp + 0], 1 ; ac++
	; Compare ac to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5634 ; If ac < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'ab'
	add qword [rsp + 16], 1
	; Compare ab to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5623 ; If ab < bound, next iter
	mov qword [rsp + 16], 0 ; ab = 0
	add qword [rsp + 8], 1 ; aa++
	; Compare aa to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5623 ; If aa < bound, next iter
	mov qword [rsp + 8], 0 ; aa = 0
	add qword [rsp + 0], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5623 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 352 to rsp 
		mov r10, [rbp - 352 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const665] ; 72.01
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from rbp - 440 to rsp 
		mov r10, [rbp - 440 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5640
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5640:
	; Computing bound for 'aa'
	mov rax, [rel const2] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5641
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	jmp .jump5642
.jump5641:
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
.jump5642:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5643
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5643:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5644
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5644:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump5645: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const666] ; 27.43
	push rax
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5646
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ad'
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5648
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const44] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5648:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5649
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5649:
	; Computing bound for 'ac'
	sub rsp, 8
	; Moving 8 bytes from rbp - 416 to rsp 
		mov r10, [rbp - 416 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5650
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5650:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by T 
	jno .jump5651
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5651:
	imul rdi, [rsp + 0 + 8] ; multiply by (E % D) 
	jno .jump5652
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5652:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ad' to 0
	mov rax, 0
	push rax
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
.jump5653: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ad'
	add qword [rsp + 8], 1
	; Compare ad to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5653 ; If ad < bound, next iter
	mov qword [rsp + 8], 0 ; ad = 0
	add qword [rsp + 0], 1 ; ac++
	; Compare ac to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5653 ; If ac < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump5647
.jump5646:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ad'
	sub rsp, 8
	; Moving 8 bytes from rbp - 456 to rsp 
		mov r10, [rbp - 456 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5654
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5654:
	; Computing bound for 'ac'
	sub rsp, 8
	; Moving 8 bytes from rbp - 440 to rsp 
		mov r10, [rbp - 440 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5655
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5655:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by Q 
	jno .jump5656
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5656:
	imul rdi, [rsp + 0 + 8] ; multiply by W 
	jno .jump5657
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5657:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ad' to 0
	mov rax, 0
	push rax
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
.jump5658: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _H
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ad'
	add qword [rsp + 8], 1
	; Compare ad to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5658 ; If ad < bound, next iter
	mov qword [rsp + 8], 0 ; ad = 0
	add qword [rsp + 0], 1 ; ac++
	; Compare ac to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5658 ; If ac < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump5647:
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 416 to rsp 
		mov r10, [rbp - 416 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5659
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5659:
	cmp rax, [rsp + 16]
	jl .jump5660
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5660:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5661
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const21] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5661:
	cmp rax, [rsp + 24]
	jl .jump5662
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const22] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5662:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'ab'
	add qword [rsp + 16], 1
	; Compare ab to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5645 ; If ab < bound, next iter
	mov qword [rsp + 16], 0 ; ab = 0
	add qword [rsp + 8], 1 ; aa++
	; Compare aa to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5645 ; If aa < bound, next iter
	mov qword [rsp + 8], 0 ; aa = 0
	add qword [rsp + 0], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5645 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	pop rdi
	pop rsi
	call _B
	add rsp, 32
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5663
	lea rdi, [rel const9] ; 'non-positive loop bound'
	call _fail_assertion
.jump5663:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,][,,,] 
imul rdi, [rsp + 0 + 0] ; multiply by B(rgba {(sum[Z : E, aa : i, ab : r] (sum[ac : (array[ac : (if true then Z else G)] w)[(- h)], ad : (N % k)] (if (if false then f() else (f() || false)) then H() else H()))), (if (! false) then u {z(), (h <= L), O, (O.a / (sum[Z : F, aa : R] H()))} else u {(if true then (if f() then z() else z()) else z()), (if (! f()) then e[R, c, p] else (false && true)), rgba {(- H()), 61.05, O.r, H()}, U[S, p].a}).d, (- H()), 86.92}, ((sum[Z : D, aa : (if true then F else A), ab : Q] (if (! (H() >= 27.43)) then (array[ac : T, ad : (E % D)] H()) else (array[ac : Q, ad : W] H()))[T, G]) * 72.01), M, w) 
	jno .jump5664
	lea rdi, [rel const19] ; 'overflow computing array size'
	call _fail_assertion
.jump5664:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump5665: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'Z'
	add qword [rsp + 0], 1
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5665 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	lea rdi, [rel const667] ; '(ArrayType (ArrayType (ArrayType (BoolType) 2) 4) 1)'
	lea rsi, [rsp]
	call _show
	add rsp, 16
	add rsp, 456 ; Local variables
	pop r12 ; begin jpl_main postlude
	pop rbp
	ret

