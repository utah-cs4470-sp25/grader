global jpl_main
global _jpl_main
extern _fail_assertion
extern _jpl_alloc
extern _get_time
extern _show
extern _print
extern _print_time
extern _read_image
extern _write_image
extern _fmod
extern _sqrt
extern _exp
extern _sin
extern _cos
extern _tan
extern _asin
extern _acos
extern _atan
extern _log
extern _pow
extern _atan2
extern _to_int
extern _to_float

section .data
const0: dq 224
const1: dq 556
const2: dq 816
const3: db `non-positive loop bound`, 0
const4: dq 418
const5: dq 18
const6: dq 452
const7: dq 620
const8: dq 1
const9: dq 374
const10: dq 787
const11: dq 340
const12: db `mod by zero`, 0
const13: dq 303
const14: dq 536
const15: dq 870
const16: dq 225
const17: dq 252
const18: dq 293
const19: dq 50.32
const20: dq 5.83
const21: dq 500
const22: dq 668
const23: dq 341
const24: dq 822
const25: dq 50
const26: dq 312
const27: db `overflow computing array size`, 0
const28: dq 329
const29: dq 467
const30: dq 688
const31: dq 750
const32: dq 103
const33: dq 219
const34: dq 112
const35: db `divide by zero`, 0
const36: dq 869
const37: dq 2
const38: dq 612
const39: dq 26
const40: dq 163
const41: dq 663
const42: dq 846
const43: dq 619
const44: dq 665
const45: dq 384
const46: dq 277
const47: dq 650
const48: dq 695
const49: db `negative array index`, 0
const50: db `index too large`, 0
const51: dq 585
const52: dq 104
const53: dq 524
const54: dq 430
const55: dq 703
const56: dq 732
const57: dq 9
const58: dq 179
const59: dq 851
const60: dq 319
const61: dq 920
const62: dq 365
const63: dq 220
const64: dq 54
const65: dq 774
const66: dq 552
const67: dq 936
const68: dq 580
const69: dq 691
const70: dq 34
const71: dq 216
const72: dq 333
const73: dq 539
const74: dq 565
const75: dq 466
const76: dq 596
const77: dq 537
const78: dq 820
const79: dq 358
const80: dq 164
const81: dq 660
const82: dq 270
const83: dq 146
const84: dq 299
const85: dq 178
const86: dq 575
const87: dq 259
const88: dq 474
const89: dq 337
const90: dq 373
const91: dq 696
const92: dq 240
const93: dq 707
const94: dq 0
const95: dq 513
const96: dq 471
const97: dq 280
const98: dq 710
const99: dq 601
const100: dq 469
const101: dq 445
const102: dq 25.63
const103: dq 28.62
const104: dq 725
const105: dq 221
const106: dq 543
const107: dq 168
const108: dq 508
const109: dq 669
const110: dq 635
const111: dq 296
const112: dq 550
const113: dq 161
const114: dq 371
const115: dq 261
const116: dq 273
const117: dq 265
const118: dq 455
const119: dq 73.46
const120: dq 78.18
const121: dq 30.27
const122: dq 154
const123: dq 533
const124: dq 641
const125: dq 504
const126: dq 28
const127: dq 654
const128: dq 438
const129: dq 922
const130: dq 297
const131: dq 206
const132: dq 693
const133: dq 262
const134: dq 366
const135: dq 468
const136: dq 462
const137: dq 70.43
const138: dq 22.24
const139: dq 23.53
const140: dq 871
const141: dq 398
const142: dq 72
const143: dq 172
const144: dq 646
const145: dq 835
const146: dq 92
const147: dq 574
const148: dq 349
const149: dq 268
const150: dq 301
const151: dq 766
const152: dq 64.25
const153: dq 36.98
const154: dq 741
const155: dq 336
const156: dq 21.68
const157: dq 151
const158: dq 907
const159: dq 248
const160: dq 889
const161: dq 123
const162: dq 986
const163: dq 839
const164: dq 83
const165: dq 811
const166: dq 735
const167: dq 608
const168: dq 71.09
const169: dq 910
const170: dq 21.76
const171: dq 376
const172: dq 578
const173: dq 655
const174: dq 849
const175: dq 175
const176: dq 403
const177: dq 573
const178: dq 614
const179: dq 895
const180: dq 485
const181: dq 929
const182: dq 719
const183: dq 600
const184: dq 147
const185: dq 227
const186: dq 714
const187: dq 389
const188: dq 535
const189: dq 742
const190: dq 448
const191: dq 283
const192: dq 642
const193: dq 446
const194: dq 51
const195: dq 122
const196: dq 963
const197: dq 548
const198: dq 783
const199: dq 82
const200: dq 363
const201: dq 727
const202: dq 724
const203: dq 863
const204: dq 439
const205: dq 479
const206: dq 411
const207: dq 845
const208: dq 324
const209: dq 530
const210: dq 498
const211: dq 271
const212: dq 105
const213: dq 763
const214: dq 330
const215: dq 582
const216: dq 318
const217: dq 830
const218: dq 425
const219: dq 56.77
const220: dq 77.66
const221: dq 30.23
const222: dq 291
const223: dq 184
const224: dq 305
const225: dq 294
const226: dq 38
const227: dq 645
const228: dq 812
const229: dq 549
const230: dq 991
const231: dq 649
const232: dq 209
const233: dq 711
const234: dq 972
const235: dq 24.45
const236: dq 4.64
const237: dq 58.4
const238: dq 674
const239: dq 391
const240: dq 417
const241: dq 9.97
const242: dq 12.1
const243: dq 708
const244: dq 189
const245: dq 825
const246: dq 231
const247: dq 850
const248: dq 867
const249: dq 50.5
const250: dq 96.3
const251: dq 35.77
const252: dq 659
const253: dq 440
const254: dq 962
const255: dq 364
const256: dq 276
const257: dq 362
const258: dq 453
const259: dq 281
const260: dq 91.82
const261: dq 966
const262: dq 47
const263: dq 344
const264: dq 634
const265: dq 30.02
const266: dq 594
const267: dq 561
const268: dq 952
const269: dq 472
const270: dq 821
const271: dq 840
const272: dq 177
const273: dq 286
const274: dq 737
const275: dq 553
const276: dq 576
const277: dq 436
const278: dq 68
const279: dq 378
const280: dq 326
const281: dq 6
const282: dq 61
const283: dq 174
const284: dq 46
const285: dq 57.24
const286: dq 74.32
const287: dq 81.57
const288: dq 44.57
const289: dq 180
const290: dq 804
const291: dq 44
const292: dq 23
const293: dq 432
const294: dq 264
const295: dq 426
const296: dq 883
const297: dq 70
const298: dq 876
const299: dq 71.51
const300: dq 778
const301: dq 186
const302: dq 19
const303: dq 666
const304: dq 940
const305: dq 584
const306: dq 887
const307: dq 59
const308: dq 52
const309: dq 80.42
const310: dq 3.05
const311: dq 70.75
const312: dq 33.54
const313: dq 784
const314: dq 3
const315: dq 323
const316: dq 359
const317: dq 888
const318: dq 667
const319: dq 988
const320: dq 396
const321: dq 138
const322: dq 781
const323: dq 1.23
const324: dq 218
const325: dq 346
const326: dq 793
const327: dq 772
const328: dq 106
const329: dq 15
const330: dq 253
const331: dq 534
const332: dq 182
const333: dq 911
const334: dq 459
const335: dq 476
const336: dq 941
const337: dq 254
const338: dq 275
const339: dq 739
const340: dq 1000
const341: dq 538
const342: dq 27.77
const343: dq 35.09
const344: dq 40.79
const345: dq 87.25
const346: dq 54.39
const347: dq 65.98
const348: dq 399
const349: dq 269
const350: dq 506
const351: dq 834
const352: dq 964
const353: dq 571
const354: dq 644
const355: dq 959
const356: dq 388
const357: dq 65
const358: dq 214
const359: dq 191
const360: dq 34.43
const361: dq 76.97
const362: dq 461
const363: dq 450
const364: dq 843
const365: dq 4.84
const366: dq 532
const367: dq 295
const368: dq 149
const369: dq 885
const370: dq 307
const371: dq 46.37
const372: dq 873
const373: dq 886
const374: dq 481
const375: dq 570
const376: dq 37
const377: dq 977
const378: dq 652
const379: dq 272
const380: dq 514
const381: dq 807
const382: dq 605
const383: dq 335
const384: dq 657
const385: dq 377
const386: dq 953
const387: dq 285
const388: dq 195
const389: dq 11
const390: dq 516
const391: dq 127
const392: dq 397
const393: dq 86.19
const394: dq 162
const395: dq 428
const396: dq 357
const397: dq 554
const398: dq 171
const399: dq 129
const400: dq 331
const401: dq 302
const402: dq 630
const403: dq 228
const404: dq 496
const405: dq 828
const406: dq 891
const407: dq 705
const408: dq 797
const409: dq 617
const410: dq 235
const411: dq 258
const412: dq 875
const413: dq 681
const414: dq 382
const415: dq 493
const416: dq 260
const417: dq 957
const418: dq 917
const419: dq 383
const420: dq 838
const421: dq 486
const422: dq 810
const423: dq 730
const424: dq 71
const425: dq 385
const426: dq 905
const427: dq 101
const428: dq 372
const429: dq 116
const430: dq 34.81
const431: dq 37.98
const432: dq 5.1
const433: dq 494
const434: dq 133
const435: dq 114
const436: dq 234
const437: dq 853
const438: dq 73
const439: dq 386
const440: dq 5
const441: dq 32
const442: dq 400
const443: dq 847
const444: dq 290
const445: dq 731
const446: dq 591
const447: dq 692
const448: dq 546
const449: dq 916
const450: dq 981
const451: dq 999
const452: dq 93
const453: dq 165
const454: dq 527
const455: dq 874
const456: dq 899
const457: dq 555
const458: dq 894
const459: dq 121
const460: dq 709
const461: dq 420
const462: dq 145
const463: dq 2.2
const464: dq 592
const465: dq 515
const466: dq 636
const467: dq 55.16
const468: dq 980
const469: dq 353
const470: dq 477
const471: dq 547
const472: dq 55.17
const473: dq 794
const474: dq 662
const475: dq 728
const476: dq 689
const477: dq 43
const478: dq 856
const479: dq 572
const480: db `f.png`, 0
const481: dq 82.03
const482: dq 97.32
const483: dq 48.62
const484: dq 44.4
const485: dq 94.85
const486: dq 24.81
const487: dq 45.75
const488: dq 11.68
const489: dq 77.43
const490: dq 22.54
const491: dq 29
const492: dq 661
const493: dq 658
const494: dq 713
const495: dq 868
const496: dq 274
const497: dq 2.88
const498: dq 815
const499: dq 982
const500: dq 780
const501: dq 327
const502: dq 844
const503: dq 776
const504: dq 232
const505: dq 393
const506: dq 257
const507: dq 621
const508: dq 61.55
const509: dq 50.13
const510: dq 98
const511: dq 55
const512: dq 120
const513: dq 421
const514: dq 862
const515: dq 521
const516: dq 381
const517: dq 39
const518: dq 545
const519: dq 529
const520: dq 792
const521: dq 928
const522: dq 733
const523: dq 99
const524: dq 93.97
const525: dq 771
const526: dq 864
const527: dq 30
const528: dq 829
const529: dq 541
const530: dq 818
const531: dq 56.3
const532: dq 53.62
const533: dq 58
const534: dq 43.51
const535: dq 788
const536: dq 247
const537: dq 217
const538: dq 416
const539: dq 85.87
const540: dq 616
const541: dq 861
const542: dq 687
const543: dq 15.44
const544: dq 880
const545: dq 729
const546: dq 63
const547: dq 81
const548: dq 304
const549: dq 351
const550: dq 266
const551: dq 208
const552: dq 404
const553: dq 339
const554: dq 368
const555: dq 300
const556: dq 756
const557: dq 717
const558: dq 56.47
const559: dq 24.35
const560: dq 72.51
const561: dq 14
const562: dq 752
const563: dq 598
const564: dq 773
const565: dq 795
const566: dq 517
const567: dq 314
const568: dq 456
const569: dq 204
const570: dq 202
const571: dq 348
const572: dq 422
const573: dq 564
const574: dq 321
const575: dq 7
const576: dq 424
const577: dq 35.75
const578: dq 992
const579: dq 751
const580: dq 125
const581: dq 908
const582: dq 497
const583: dq 201
const584: dq 721
const585: db `f`, 0
const586: dq 97
const587: dq 722
const588: dq 255
const589: dq 884
const590: dq 222
const591: dq 808
const592: dq 934
const593: dq 435
const594: dq 512
const595: dq 768
const596: dq 519
const597: dq 328
const598: dq 976
const599: dq 878
const600: dq 342
const601: dq 395
const602: dq 551
const603: dq 632
const604: dq 10
const605: dq 60.09
const606: dq 54.87
const607: dq 745
const608: dq 387
const609: dq 872
const610: dq 947
const611: dq 892
const612: dq 51.49
const613: dq 84.97
const614: dq 150
const615: dq 881
const616: dq 29.16
const617: dq 648
const618: dq 475
const619: dq 882
const620: dq 16
const621: dq 901
const622: dq 49
const623: dq 325
const624: dq 698
const625: dq 94.94
const626: dq 249
const627: dq 354
const628: dq 59.58
const629: dq 194
const630: dq 57.54
const631: dq 215
const632: dq 78.39
const633: dq 243
const634: dq 583
const635: dq 113
const636: dq 702
const637: dq 866
const638: dq 978
const639: dq 802
const640: dq 90
const641: dq 902
const642: dq 627
const643: dq 320
const644: dq 332
const645: dq 443
const646: dq 141
const647: dq 53
const648: dq 676
const649: dq 203
const650: dq 607
const651: dq 470
const652: dq 21
const653: dq 720
const654: dq 13
const655: dq 789
const656: dq 520
const657: dq 581
const658: dq 95
const659: dq 464
const660: dq 588
const661: dq 441
const662: dq 78
const663: dq 8
const664: dq 187
const665: dq 699
const666: dq 945
const667: dq 775
const668: dq 790
const669: dq 473
const670: dq 62.93
const671: dq 79.99
const672: dq 322
const673: dq 230
const674: dq 860
const675: dq 79.73
const676: dq 78.86
const677: dq 56.27
const678: dq 593
const679: dq 22
const680: dq 40
const681: dq 167
const682: dq 284
const683: dq 85
const684: dq 402
const685: dq 192
const686: dq 193
const687: dq 5.04
const688: dq 53.74
const689: dq 86.7
const690: dq 15.13
const691: dq 17.29
const692: dq 11.85
const693: dq 256
const694: dq 743
const695: dq 155
const696: dq 287
const697: dq 33.22
const698: dq 42.59
const699: dq 84.85
const700: dq 603
const701: dq 93.01
const702: dq 60.17
const703: dq 96
const704: dq 437
const705: dq 406
const706: dq 12.75
const707: dq 563
const708: dq 799
const709: dq 61.61
const710: dq 94.84
const711: db `n`, 0
const712: dq 126
const713: dq 589
const714: dq 511
const715: dq 80.43
const716: dq 990
const717: dq 918
const718: dq 3.07
const719: dq 12.56
const720: dq 90.93
const721: dq 14.25
const722: dq 345
const723: dq 9.8
const724: dq 36.86
const725: dq 49.11
const726: dq 94.78
const727: dq 409
const728: dq 41.73
const729: db `C.png`, 0
const730: dq 278
const731: db `(BoolType)`, 0
const732: dq 82.15
const733: dq 921
const734: dq 63.15
const735: dq 942
const736: dq 877
const737: dq 747
const738: dq 22.31
const739: dq 68.66
const740: db `M`, 0
const741: db `Q`, 0
const742: db `U`, 0
const743: db `I`, 0
const744: dq 814
const745: dq 736
const746: dq 90.91
const747: dq 915
const748: dq 73.79
const749: db `V`, 0
const750: dq 298
const751: db `N`, 0
const752: dq 919
const753: dq 643
const754: dq 427
const755: dq 35.36
const756: dq 78.88
const757: dq 566
const758: dq 628
const759: dq 701
const760: dq 142
const761: dq 47.53
const762: dq 944
const763: dq 7.64
const764: dq 38.64
const765: dq 53.82
const766: db `P`, 0
const767: dq 152
const768: dq 613
const769: db `T`, 0
const770: dq 70.41
const771: dq 53.6
const772: dq 41.54
const773: dq 267
const774: dq 948
const775: db `K.png`, 0
const776: db `(FloatType)`, 0

section .text
A:
_A:
	push rbp
	mov rbp, rsp
	push rdi
	mov rax, [rel const94] ; False
	push rax
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4110
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4112
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4114
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4114:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4115
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4115:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[,][] 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump4116
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4116:
	imul rdi, [rsp + 0 + 8] ; multiply by x 
	jno .jump4117
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4117:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4118: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4119
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4121
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4121:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4122
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4122:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump4123
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4123:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump4124
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4124:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4125: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4125 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4125 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump4120
.jump4119:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4126
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4126:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4127
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4127:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by y 
	jno .jump4128
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4128:
	imul rdi, [rsp + 0 + 8] ; multiply by j 
	jno .jump4129
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4129:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4130: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4130 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4130 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump4120:
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4118 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4118 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4131
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4131:
	cmp rax, [rsp + 16]
	jl .jump4132
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4132:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4133
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4133:
	cmp rax, [rsp + 24]
	jl .jump4134
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4134:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 16
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4113
.jump4112:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4135
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4137
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4139
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4139:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump4140
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4140:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4141: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4142
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4144
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4144:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4145
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4145:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump4146
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4146:
	imul rdi, [rsp + 0 + 8] ; multiply by y 
	jno .jump4147
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4147:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump4148: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 8], 1
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4148 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4148 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump4143
.jump4142:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4149
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4149:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4150
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4150:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by t 
	jno .jump4151
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4151:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump4152
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4152:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump4153: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 8], 1
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4153 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4153 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump4143:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'J'
	add qword [rsp + 0], 1
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4141 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump4138
.jump4137:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4154
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4154:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump4155
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4155:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4156: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4157
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4159
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4159:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4160
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4160:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by J 
	jno .jump4161
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4161:
	imul rdi, [rsp + 0 + 8] ; multiply by D 
	jno .jump4162
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4162:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump4163: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 8], 1
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4163 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4163 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump4158
.jump4157:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4164
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4164:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4165
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4165:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by D 
	jno .jump4166
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4166:
	imul rdi, [rsp + 0 + 8] ; multiply by F 
	jno .jump4167
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4167:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump4168: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 8], 1
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4168 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4168 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump4158:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'J'
	add qword [rsp + 0], 1
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4156 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump4138:
	jmp .jump4136
.jump4135:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4169
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4169:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4170
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4170:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by j 
	jno .jump4171
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4171:
	imul rdi, [rsp + 0 + 8] ; multiply by F 
	jno .jump4172
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4172:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4173: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4173 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4173 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4174
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4174:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump4175
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4175:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4176: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4177
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4177:
	; Computing bound for 'K'
	mov rax, [rel const21] ; 500
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4178
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4178:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 500 
	jno .jump4179
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4179:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump4180
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4180:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump4181: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 8], 1
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4181 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4181 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'J'
	add qword [rsp + 0], 1
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4176 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4182
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4182:
	cmp rax, [rsp + 8]
	jl .jump4183
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4183:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rdi, 48
	call _jpl_alloc
	; Moving 48 bytes from rsp to rax 
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 48
	push rax
	mov rax, 2
	push rax
.jump4136:
.jump4113:
	jmp .jump4111
.jump4110:
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4184
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4186
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4186:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4187
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4187:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump4188
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4188:
	imul rdi, [rsp + 0 + 8] ; multiply by D 
	jno .jump4189
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4189:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4190: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4191
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump4192
.jump4191:
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
.jump4192:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4193
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4193:
	; Computing bound for 'L'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4194
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4194:
	; Computing bound for 'N'
	mov rax, [rel const722] ; 345
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4195
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4195:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4196
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4196:
	; Computing bound for 'L'
	mov rax, [rel const473] ; 794
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4197
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4197:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4198: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4198 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4198 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4198 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4198 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4199
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4199:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[L : 794, M : F, N : 345, O : p] D) 
	jno .jump4200
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4200:
	imul rdi, [rsp + 0 + 8] ; multiply by (if v then J else k) 
	jno .jump4201
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4201:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4202: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4202 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4202 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4190 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4190 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8 ; Add alignment
	sub rsp, 32
	; Moving 32 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4203
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4203:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4204
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4204:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4205
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4205:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by j 
	jno .jump4206
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4206:
	imul rdi, [rsp + 0 + 8] ; multiply by G 
	jno .jump4207
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4207:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump4208
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4208:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4209: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4209 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4209 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4209 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4210
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4210:
	cmp rax, [rsp + 24]
	jl .jump4211
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4211:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4212
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4212:
	cmp rax, [rsp + 32]
	jl .jump4213
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4213:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4214
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4214:
	cmp rax, [rsp + 40]
	jl .jump4215
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4215:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _A
	add rsp, 16
	add rsp, 32
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4216
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4216:
	cmp rax, [rsp + 16]
	jl .jump4217
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4217:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4218
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4218:
	cmp rax, [rsp + 24]
	jl .jump4219
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4219:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4185
.jump4184:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4220
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4220:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4221
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4221:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by y 
	jno .jump4222
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4222:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump4223
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4223:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4224: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4225
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4225:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4226
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4226:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by y 
	jno .jump4227
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4227:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump4228
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4228:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4229: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4229 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4229 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4224 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4224 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8 ; Add alignment
	sub rsp, 32
	; Moving 32 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const275] ; 553
	push rax
	pop rdi
	call _A
	add rsp, 16
	add rsp, 32
	add rsp, 8 ; Remove alignment
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4230
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4230:
	; Computing bound for 'L'
	sub rsp, 32
	; Moving 32 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4231
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	jmp .jump4232
.jump4231:
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
.jump4232:
	pop rdi
	call _A
	add rsp, 16
	add rsp, 32
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4233
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4233:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4234
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4234:
	; Computing bound for 'J'
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4235
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4235:
	cmp rax, [rsp + 8]
	jl .jump4236
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4236:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4237
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4237:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4238: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'M'
	add qword [rsp + 24], 1
	; Compare M to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4238 ; If M < bound, next iter
	mov qword [rsp + 24], 0 ; M = 0
	add qword [rsp + 16], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4238 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4238 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4238 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4239
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4239:
	cmp rax, [rsp + 16]
	jl .jump4240
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4240:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4241
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4241:
	cmp rax, [rsp + 24]
	jl .jump4242
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4242:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4185:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4243
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4243:
	; Computing bound for 'J'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'J'
	mov rax, [rel const667] ; 775
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4244
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4244:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4245: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'J'
	add qword [rsp + 0], 1
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4245 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4246
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4246:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,][,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[J : 775] y) 
	jno .jump4247
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4247:
	imul rdi, [rsp + 0 + 8] ; multiply by C 
	jno .jump4248
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4248:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4249: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4250
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4250:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4251
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump4251:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4252
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4252:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4253
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4253:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump4254
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4254:
	imul rdi, [rsp + 0 + 8] ; multiply by (F % i) 
	jno .jump4255
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4255:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump4256
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4256:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4257: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4258
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4258:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4259
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4259:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by t 
	jno .jump4260
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4260:
	imul rdi, [rsp + 0 + 8] ; multiply by z 
	jno .jump4261
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4261:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4262: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'P'
	add qword [rsp + 8], 1
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4262 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4262 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'N'
	add qword [rsp + 16], 1
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4257 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4257 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4257 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4249 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4249 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4263
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4263:
	cmp rax, [rsp + 16]
	jl .jump4264
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4264:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4265
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4265:
	cmp rax, [rsp + 24]
	jl .jump4266
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4266:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const603] ; 632
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4267
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4267:
	cmp rax, [rsp + 24]
	jl .jump4268
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4268:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4269
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4269:
	cmp rax, [rsp + 32]
	jl .jump4270
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4270:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4271
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4271:
	cmp rax, [rsp + 40]
	jl .jump4272
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4272:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4273
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4273:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4274
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4274:
	; Computing bound for 'J'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4275
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4275:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4276
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4276:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4277: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4277 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4277 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4278
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4278:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4279: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4279 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4279 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4279 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4280
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4280:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by j 
	jno .jump4281
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4281:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4282: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const723] ; 9.8
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'J'
	add qword [rsp + 0], 1
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4282 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4283
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4283:
	cmp rax, [rsp + 8]
	jl .jump4284
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4284:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4285
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4287
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4287:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4288
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4288:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4289
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4289:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4290
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4290:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump4291
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4291:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump4292
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4292:
	imul rdi, [rsp + 0 + 16] ; multiply by z 
	jno .jump4293
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4293:
	imul rdi, [rsp + 0 + 24] ; multiply by u 
	jno .jump4294
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4294:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4295: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'M'
	add qword [rsp + 24], 1
	; Compare M to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4295 ; If M < bound, next iter
	mov qword [rsp + 24], 0 ; M = 0
	add qword [rsp + 16], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4295 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4295 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4295 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4296
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4296:
	cmp rax, [rsp + 32]
	jl .jump4297
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4297:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4298
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4298:
	cmp rax, [rsp + 40]
	jl .jump4299
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4299:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4300
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4300:
	cmp rax, [rsp + 48]
	jl .jump4301
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4301:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4302
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4302:
	cmp rax, [rsp + 56]
	jl .jump4303
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4303:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4304
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4305
	mov rax, [rel const94] ; False
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
.jump4305:
	push rax
	pop rax
.jump4304:
	push rax
	pop rax
	cmp rax, 0
	je .jump4306
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4308
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4308:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4309
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4309:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump4310
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4310:
	imul rdi, [rsp + 0 + 8] ; multiply by D 
	jno .jump4311
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4311:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4312: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4312 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4312 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump4307
.jump4306:
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4313
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4315
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4317
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4317:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4318
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4318:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by j 
	jno .jump4319
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4319:
	imul rdi, [rsp + 0 + 8] ; multiply by C 
	jno .jump4320
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4320:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4321: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4321 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4321 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump4316
.jump4315:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4322
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4322:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4323
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4323:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump4324
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4324:
	imul rdi, [rsp + 0 + 8] ; multiply by H 
	jno .jump4325
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4325:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4326: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4326 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4326 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump4316:
	jmp .jump4314
.jump4313:
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4327
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4329
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4329:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4330
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4330:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by u 
	jno .jump4331
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4331:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump4332
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4332:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4333: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4333 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4333 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump4328
.jump4327:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4334
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4334:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4335
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4335:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by y 
	jno .jump4336
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4336:
	imul rdi, [rsp + 0 + 8] ; multiply by t 
	jno .jump4337
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4337:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4338: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4338 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4338 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump4328:
.jump4314:
.jump4307:
	jmp .jump4286
.jump4285:
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump4339
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
.jump4339:
	push rax
	pop rax
	cmp rax, 0
	je .jump4340
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
.jump4340:
	push rax
	pop rax
	cmp rax, 0
	je .jump4341
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4343
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4343:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4344
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4344:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (C - G) 
	jno .jump4345
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4345:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump4346
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4346:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4347: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4348
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4348:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by K 
	jno .jump4349
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4349:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4350: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 0], 1
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4350 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4351
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4351:
	cmp rax, [rsp + 8]
	jl .jump4352
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4352:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4347 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4347 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump4342
.jump4341:
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4353
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4355
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4355:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4356
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4356:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by z 
	jno .jump4357
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4357:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump4358
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4358:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4359: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4359 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4359 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump4354
.jump4353:
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4360
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4362
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4362:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4363
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4363:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by F 
	jno .jump4364
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4364:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump4365
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4365:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4366: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4366 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4366 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump4361
.jump4360:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4367
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4367:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4368
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4368:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by C 
	jno .jump4369
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4369:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump4370
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4370:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4371: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4371 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4371 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump4361:
.jump4354:
.jump4342:
.jump4286:
	mov rdi, 72
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 72 bytes from rsp to rax 
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 72
	push rax
	mov rax, 3
	push rax
.jump4111:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4372
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4372:
	cmp rax, [rsp + 8]
	jl .jump4373
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4373:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	pop rax
	add rsp, 40 ; Local variables
	pop rbp
	ret
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 32
	; Moving 32 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4374
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4374:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump4375
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4375:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump4376: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'M'
	add qword [rsp + 0], 1
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4376 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _A
	add rsp, 16
	add rsp, 32
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4377
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4377:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4378
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4378:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4379
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4379:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump4380
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4380:
	imul rdi, [rsp + 0 + 8] ; multiply by F 
	jno .jump4381
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4381:
imul rdi, [rsp + 0 + 16] ; multiply by A((array[M : h] z), s, E) 
	jno .jump4382
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4382:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump4383: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	sub rsp, 32
	; Moving 32 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const201] ; 727
	push rax
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _A
	add rsp, 16
	add rsp, 32
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp 
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'O'
	add qword [rsp + 16], 1
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4383 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4383 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4383 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 24
	; Moving 24 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4384
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4384:
	cmp rax, [rsp + 16]
	jl .jump4385
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4385:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4386
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4386:
	cmp rax, [rsp + 24]
	jl .jump4387
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4387:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	sub rsp, 32
	; Moving 32 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _A
	add rsp, 16
	add rsp, 32
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4388
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4388:
	cmp rax, [rsp + 24]
	jl .jump4389
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4389:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4390
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4390:
	cmp rax, [rsp + 32]
	jl .jump4391
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4391:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4392
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4392:
	cmp rax, [rsp + 40]
	jl .jump4393
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4393:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4394
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4394:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by G 
	jno .jump4395
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4395:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4396: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 0], 1
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4396 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	pop rax
	add rsp, 88 ; Local variables
	pop rbp
	ret

F:
_F:
	push rbp
	mov rbp, rsp
	push rdi
	push rsi
	push rdx
	sub rsp, 24
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8 ; Add alignment
	mov rax, [rel const8] ; True
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4561
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	jmp .jump4562
.jump4561:
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
.jump4562:
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4563
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4565
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4565:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4566
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4566:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4567
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4567:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump4568
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4568:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump4569
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4569:
	imul rdi, [rsp + 0 + 16] ; multiply by x 
	jno .jump4570
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4570:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4571: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 16], 1
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4571 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4571 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4571 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4564
.jump4563:
	mov rax, [rel const732] ; 82.15
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4572
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4574
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4574:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4575
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4575:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4576
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4576:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by D 
	jno .jump4577
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4577:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump4578
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4578:
	imul rdi, [rsp + 0 + 16] ; multiply by E 
	jno .jump4579
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4579:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4580: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 16], 1
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4580 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4580 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4580 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4573
.jump4572:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4581
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4581:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4582
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4582:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4583
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4583:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by z 
	jno .jump4584
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4584:
	imul rdi, [rsp + 0 + 8] ; multiply by G 
	jno .jump4585
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4585:
	imul rdi, [rsp + 0 + 16] ; multiply by E 
	jno .jump4586
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4586:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4587: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 16], 1
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4587 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4587 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4587 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4573:
.jump4564:
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4588
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 1
	push rax
	jmp .jump4589
.jump4588:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4590
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4590:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump4591
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4591:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4592: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 32]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'I'
	add qword [rsp + 0], 1
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4592 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump4589:
	mov rax, [rel const166] ; 735
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4593
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4593:
	cmp rax, [rsp + 8]
	jl .jump4594
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4594:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _A
	add rsp, 16
	add rsp, 32
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4595
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4595:
	; Computing bound for 'J'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4596
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4598
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4598:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const733] ; 921
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4599
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4599:
	; Computing bound for 'I'
	sub rsp, 32
	; Moving 32 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 280 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 280 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4600
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4600:
	cmp rax, [rsp + 24]
	jl .jump4601
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4601:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4602
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4602:
	cmp rax, [rsp + 32]
	jl .jump4603
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4603:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4604
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4604:
	cmp rax, [rsp + 40]
	jl .jump4605
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4605:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4606
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4606:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by w[E, E, r] 
	jno .jump4607
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4607:
	imul rdi, [rsp + 0 + 8] ; multiply by (921 - y) 
	jno .jump4608
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4608:
	imul rdi, [rsp + 0 + 16] ; multiply by (- s) 
	jno .jump4609
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4609:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4610: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 16], 1
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4610 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4610 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4610 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4597
.jump4596:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4611
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4611:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4612
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4612:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4613
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4613:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (G * G) 
	jno .jump4614
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4614:
	imul rdi, [rsp + 0 + 8] ; multiply by E 
	jno .jump4615
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4615:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump4616
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4616:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4617: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump4618
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	pop rax
.jump4618:
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 16], 1
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4617 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4617 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4617 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4597:
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4619
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4619:
	cmp rax, [rsp + 24]
	jl .jump4620
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4620:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4621
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4621:
	cmp rax, [rsp + 32]
	jl .jump4622
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4622:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4623
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4623:
	cmp rax, [rsp + 40]
	jl .jump4624
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4624:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4625
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	jmp .jump4626
.jump4625:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump4626:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4627
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4627:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4628
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4628:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by (- D) 
	jno .jump4629
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4629:
imul rdi, [rsp + 0 + 8] ; multiply by (if (if (! true) then (array[I : w[E, E, r], J : (921 - y), K : (- s)] (! B)) else (array[I : (G * G), J : E, K : b] (true || B)))[j, u, j] then y else G) 
	jno .jump4630
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4630:
imul rdi, [rsp + 0 + 16] ; multiply by (- A((if (! f) then [a] else (array[I : b] a))[735], b, (if ((if B then B else m) == true) then (array[I : h, J : o, K : x] H) else (if (c != 82.15) then (array[I : D, J : b, K : E] H) else (array[I : z, J : G, K : E] H))))) 
	jno .jump4631
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4631:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4632: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const734] ; 63.15
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4633
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4633:
	cmp rax, [rsp + 8]
	jl .jump4634
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4634:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4635
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4637
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4637:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4638
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4638:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4639
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4639:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4640
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4640:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by G 
	jno .jump4641
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4641:
	imul rdi, [rsp + 0 + 8] ; multiply by D 
	jno .jump4642
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4642:
	imul rdi, [rsp + 0 + 16] ; multiply by I 
	jno .jump4643
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4643:
	imul rdi, [rsp + 0 + 24] ; multiply by E 
	jno .jump4644
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4644:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4645: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4646
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump4647
.jump4646:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump4647:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4645 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4645 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4645 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4645 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const735] ; 942
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'N'
	mov rax, [rel const736] ; 877
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4648
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4648:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4649
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4649:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4650
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4650:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4651: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'N'
	add qword [rsp + 16], 1
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4651 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4651 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4651 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4652
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4652:
	cmp rax, [rsp + 32]
	jl .jump4653
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4653:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4654
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4654:
	cmp rax, [rsp + 40]
	jl .jump4655
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4655:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4656
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4656:
	cmp rax, [rsp + 48]
	jl .jump4657
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4657:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4658
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4658:
	cmp rax, [rsp + 56]
	jl .jump4659
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4659:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4636
.jump4635:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump4636:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 16], 1
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4632 ; If K < bound, next iter
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4632 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4632 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4660
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4660:
	cmp rax, [rsp + 8]
	jl .jump4661
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4661:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4662
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4662:
	; Computing bound for 'I'
	mov rax, [rel const737] ; 747
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4663
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4663:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
.jump4664: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'J'
	add qword [rsp + 8], 1
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4664 ; If J < bound, next iter
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4664 ; If I < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4665
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4665:
	cmp rax, [rsp + 24]
	jl .jump4666
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4666:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4667
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4667:
	cmp rax, [rsp + 32]
	jl .jump4668
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4668:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4669
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4669:
	cmp rax, [rsp + 40]
	jl .jump4670
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4670:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rsi
	pop rdx
	lea rdi, [rsp + 0]
	call _F
	sub rsp, 24
	; Moving 24 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const738] ; 22.31
	push rax
	mov rax, [rel const739] ; 68.66
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump4671
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const740] ; 'M'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4671:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4672
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4672:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4673
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4673:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4674
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4674:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by j 
	jno .jump4675
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4675:
	imul rdi, [rsp + 0 + 8] ; multiply by z 
	jno .jump4676
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4676:
	imul rdi, [rsp + 0 + 16] ; multiply by (- (- i)) 
	jno .jump4677
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4677:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump4678: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 280 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 280 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'O'
	add qword [rsp + 16], 1
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4678 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4678 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4678 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump4679
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const741] ; 'Q'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4679:
	sub rsp, 32
	; Moving 32 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 104 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 104 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4680
	mov rax, [rel const94] ; False
	push rax
	jmp .jump4681
.jump4680:
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
.jump4681:
	pop rax
	cmp rax, 0
	jne .jump4682
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const742] ; 'U'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4682:
	sub rsp, 24
	; Moving 24 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 320 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 160 ; Local variables
	pop rbp
	ret

G:
_G:
	push rbp
	mov rbp, rsp
	push rdi
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4683
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	jmp .jump4684
.jump4683:
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4685
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
.jump4685:
	push rax
	pop rax
	cmp rax, 0
	jne .jump4686
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
.jump4686:
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump4687
	sub rsp, 40
	; Moving 40 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 160 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 160 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 160 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4688
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4688:
	cmp rax, [rsp + 32]
	jl .jump4689
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4689:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4690
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4690:
	cmp rax, [rsp + 40]
	jl .jump4691
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4691:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4692
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4692:
	cmp rax, [rsp + 48]
	jl .jump4693
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4693:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4694
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4694:
	cmp rax, [rsp + 56]
	jl .jump4695
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4695:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump4687:
	push rax
.jump4684:
	pop rax
	cmp rax, 0
	jne .jump4696
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const743] ; 'I'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4696:
	sub rsp, 32
	; Moving 32 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 280 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 280 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	sub rsp, 40
	; Moving 40 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 160 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 160 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 160 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 40
	; Moving 40 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 160 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 160 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 160 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rdi, 80
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 80 bytes from rsp to rax 
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 80
	push rax
	mov rax, 2
	push rax
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4697
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4697:
	cmp rax, [rsp + 8]
	jl .jump4698
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4698:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4699
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4699:
	cmp rax, [rsp + 8]
	jl .jump4700
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4700:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	mov rax, [rel const651] ; 470
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4701
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4701:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4702
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4702:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4703
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4703:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4704
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4704:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump4705
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4705:
	imul rdi, [rsp + 0 + 8] ; multiply by j 
	jno .jump4706
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4706:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump4707
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4707:
	imul rdi, [rsp + 0 + 24] ; multiply by 470 
	jno .jump4708
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4708:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4709: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'M'
	add qword [rsp + 24], 1
	; Compare M to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4709 ; If M < bound, next iter
	mov qword [rsp + 24], 0 ; M = 0
	add qword [rsp + 16], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4709 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4709 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4709 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4710
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4710:
	cmp rax, [rsp + 32]
	jl .jump4711
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4711:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4712
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4712:
	cmp rax, [rsp + 40]
	jl .jump4713
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4713:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4714
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4714:
	cmp rax, [rsp + 48]
	jl .jump4715
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4715:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4716
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4716:
	cmp rax, [rsp + 56]
	jl .jump4717
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4717:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4718
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4718:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4719
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4719:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4720
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4720:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump4721
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4721:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump4722
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4722:
imul rdi, [rsp + 0 + 16] ; multiply by (array[J : i, K : j, L : b, M : 470] r)[E, D, t, E] 
	jno .jump4723
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4723:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4724: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4724 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4724 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4724 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const551] ; 208
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4725
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4725:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4726
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4726:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4727
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4727:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4728
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4728:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump4729
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4729:
	imul rdi, [rsp + 0 + 8] ; multiply by u 
	jno .jump4730
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4730:
	imul rdi, [rsp + 0 + 16] ; multiply by t 
	jno .jump4731
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4731:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4732: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4732 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4732 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4732 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	mov rax, [rel const744] ; 814
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4733
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4733:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 814 
	jno .jump4734
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4734:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4735: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'J'
	add qword [rsp + 0], 1
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4735 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _A
	add rsp, 16
	add rsp, 32
	push rax
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _A
	add rsp, 16
	add rsp, 32
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4736
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4736:
	cmp rax, [rsp + 32]
	jl .jump4737
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4737:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4738
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4738:
	cmp rax, [rsp + 40]
	jl .jump4739
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4739:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4740
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4740:
	cmp rax, [rsp + 48]
	jl .jump4741
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4741:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4742
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4742:
	cmp rax, [rsp + 56]
	jl .jump4743
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4743:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4744
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump4746
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	pop rax
.jump4746:
	push rax
	pop rax
	cmp rax, 0
	je .jump4747
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	jmp .jump4748
.jump4747:
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
.jump4748:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4749
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4749:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4750
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4750:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[][,][,] 
	imul rdi, [rsp + 0 + 0] ; multiply by D 
	jno .jump4751
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4751:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (f || B) then D else j) 
	jno .jump4752
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4752:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4753: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4754
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	mov rax, [rel const453] ; 165
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4756
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4756:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4757
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4757:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[][,] 
	imul rdi, [rsp + 0 + 0] ; multiply by z 
	jno .jump4758
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4758:
	imul rdi, [rsp + 0 + 8] ; multiply by 165 
	jno .jump4759
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4759:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4760: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4761
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4761:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4762
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4762:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump4763
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4763:
	imul rdi, [rsp + 0 + 8] ; multiply by z 
	jno .jump4764
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4764:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump4765: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4765 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4765 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4760 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4760 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump4755
.jump4754:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4766
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4766:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4767
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4767:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[][,] 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump4768
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4768:
	imul rdi, [rsp + 0 + 8] ; multiply by D 
	jno .jump4769
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4769:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump4770: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4771
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4771:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4772
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4772:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by y 
	jno .jump4773
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4773:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump4774
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4774:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump4775: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4775 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4775 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4770 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4770 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump4755:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4753 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4753 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4776
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4776:
	cmp rax, [rsp + 16]
	jl .jump4777
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4777:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4778
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4778:
	cmp rax, [rsp + 24]
	jl .jump4779
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4779:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4780
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4780:
	cmp rax, [rsp + 16]
	jl .jump4781
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4781:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4782
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4782:
	cmp rax, [rsp + 24]
	jl .jump4783
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4783:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4745
.jump4744:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4784
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4784:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4785
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4785:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump4786
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4786:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump4787
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4787:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4788: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const745] ; 736
	push rax
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'K'
	add qword [rsp + 8], 1
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4788 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4788 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump4745:
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4789
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4789:
	cmp rax, [rsp + 16]
	jl .jump4790
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4790:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4791
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4791:
	cmp rax, [rsp + 24]
	jl .jump4792
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4792:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 16
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4793
	sub rsp, 40
	; Moving 40 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 160 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 160 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 160 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	jmp .jump4794
.jump4793:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4795
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4795:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump4796
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4796:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump4797: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4798
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4798:
	; Computing bound for 'P'
	mov rax, [rel const447] ; 692
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4799
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4799:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4800
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4800:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4801
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4801:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by ((- y) * E) 
	jno .jump4802
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4802:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump4803
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4803:
	imul rdi, [rsp + 0 + 16] ; multiply by 692 
	jno .jump4804
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4804:
	imul rdi, [rsp + 0 + 24] ; multiply by t 
	jno .jump4805
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4805:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump4806: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 240 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 240 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 240 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'Q'
	add qword [rsp + 24], 1
	; Compare Q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4806 ; If Q < bound, next iter
	mov qword [rsp + 24], 0 ; Q = 0
	add qword [rsp + 16], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4806 ; If P < bound, next iter
	mov qword [rsp + 16], 0 ; P = 0
	add qword [rsp + 8], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4806 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4806 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'M'
	add qword [rsp + 0], 1
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4797 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4807
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4807:
	cmp rax, [rsp + 8]
	jl .jump4808
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4808:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4809
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4811
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4811:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4812
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4812:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof void[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by K 
	jno .jump4813
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4813:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump4814
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4814:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump4815: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4816
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4818
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4818:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4819
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4819:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4820
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4820:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by K 
	jno .jump4821
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4821:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump4822
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4822:
	imul rdi, [rsp + 0 + 16] ; multiply by u 
	jno .jump4823
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4823:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4824: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4824 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4824 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4824 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4817
.jump4816:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4825
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4825:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4826
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4826:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4827
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4827:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by z 
	jno .jump4828
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4828:
	imul rdi, [rsp + 0 + 8] ; multiply by y 
	jno .jump4829
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4829:
	imul rdi, [rsp + 0 + 16] ; multiply by z 
	jno .jump4830
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4830:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4831: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4831 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4831 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4831 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4817:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'N'
	add qword [rsp + 8], 1
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4815 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4815 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump4810
.jump4809:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4832
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4832:
	; Computing bound for 'M'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4833
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4833:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4834
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4834:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4835
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4835:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump4836
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4836:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump4837
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4837:
	imul rdi, [rsp + 0 + 16] ; multiply by E 
	jno .jump4838
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4838:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump4839: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 16], 1
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4839 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4839 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4839 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4840
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump4841
.jump4840:
	sub rsp, 16
	; Moving 16 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump4841:
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _A
	add rsp, 16
	add rsp, 32
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4842
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4842:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof void[,,] 
imul rdi, [rsp + 0 + 0] ; multiply by A((if L then a else J), z, (array[M : i, N : s, O : E] H)) 
	jno .jump4843
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4843:
	imul rdi, [rsp + 0 + 8] ; multiply by x 
	jno .jump4844
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4844:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump4845: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4846
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4848
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4848:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4849
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4849:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4850
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4850:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by M 
	jno .jump4851
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4851:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump4852
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4852:
	imul rdi, [rsp + 0 + 16] ; multiply by D 
	jno .jump4853
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4853:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4854: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4854 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4854 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4854 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4847
.jump4846:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4855
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4855:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4856
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4856:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4857
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4857:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by j 
	jno .jump4858
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4858:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump4859
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4859:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump4860
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4860:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump4861: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4861 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4861 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4861 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4847:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'N'
	add qword [rsp + 8], 1
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4845 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4845 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump4810:
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4862
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4862:
	cmp rax, [rsp + 16]
	jl .jump4863
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4863:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4864
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4864:
	cmp rax, [rsp + 24]
	jl .jump4865
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4865:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _A
	add rsp, 16
	add rsp, 32
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4866
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4866:
	cmp rax, [rsp + 32]
	jl .jump4867
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4867:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4868
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4868:
	cmp rax, [rsp + 40]
	jl .jump4869
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4869:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4870
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4870:
	cmp rax, [rsp + 48]
	jl .jump4871
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4871:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4872
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4872:
	cmp rax, [rsp + 56]
	jl .jump4873
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4873:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4794:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4874
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4874:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4875
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4875:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4876
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4876:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump4877
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4877:
	imul rdi, [rsp + 0 + 8] ; multiply by K 
	jno .jump4878
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4878:
	imul rdi, [rsp + 0 + 16] ; multiply by O 
	jno .jump4879
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4879:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump4880: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'T'
	add qword [rsp + 16], 1
	; Compare T to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4880 ; If T < bound, next iter
	mov qword [rsp + 16], 0 ; T = 0
	add qword [rsp + 8], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4880 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4880 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 136 ; Local variables
	pop rbp
	ret
	mov rax, [rel const746] ; 90.91
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 136 ; Local variables
	pop rbp
	ret

H:
_H:
	push rbp
	mov rbp, rsp
	push rdi
	push rsi
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump4881
	lea rdi, [rel const742] ; 'U'
	call _fail_assertion
.jump4881:
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4882
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4884
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4884:
	; Computing bound for 'U'
	mov rax, [rel const747] ; 915
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4885
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4885:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
.jump4886: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'V'
	add qword [rsp + 8], 1
	; Compare V to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4886 ; If V < bound, next iter
	mov qword [rsp + 8], 0 ; V = 0
	add qword [rsp + 0], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4886 ; If U < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump4883
.jump4882:
	mov rax, [rel const748] ; 73.79
	push rax
.jump4883:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump4887
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const749] ; 'V'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4887:
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -64 to rsp 
		mov r10, [rbp - -64 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4888
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	jmp .jump4889
.jump4888:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump4890
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const124] ; 641
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4891
	mov rax, [rel const8] ; True
	push rax
	pop rax
.jump4891:
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump4892
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
.jump4892:
	push rax
	pop rax
.jump4890:
	push rax
.jump4889:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4893
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4895
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4895:
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4896
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4896:
	; Computing bound for 'X'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4897
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4897:
	; Computing bound for 'Z'
	mov rax, [rel const750] ; 298
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4898
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4898:
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4899
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4899:
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4900
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4900:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
.jump4901: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'aa'
	add qword [rsp + 24], 1
	; Compare aa to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4901 ; If aa < bound, next iter
	mov qword [rsp + 24], 0 ; aa = 0
	add qword [rsp + 16], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4901 ; If Z < bound, next iter
	mov qword [rsp + 16], 0 ; Z = 0
	add qword [rsp + 8], 1 ; Y++
	; Compare Y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4901 ; If Y < bound, next iter
	mov qword [rsp + 8], 0 ; Y = 0
	add qword [rsp + 0], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4901 ; If X < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4902
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4902:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[X : L, Y : L, Z : 298, aa : P] h) 
	jno .jump4903
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4903:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump4904
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4904:
	imul rdi, [rsp + 0 + 16] ; multiply by P 
	jno .jump4905
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4905:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
.jump4906: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Z'
	add qword [rsp + 16], 1
	; Compare Z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4906 ; If Z < bound, next iter
	mov qword [rsp + 16], 0 ; Z = 0
	add qword [rsp + 8], 1 ; Y++
	; Compare Y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4906 ; If Y < bound, next iter
	mov qword [rsp + 8], 0 ; Y = 0
	add qword [rsp + 0], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4906 ; If X < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4894
.jump4893:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4907
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4907:
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4908
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4908:
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4909
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4909:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by E 
	jno .jump4910
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4910:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump4911
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4911:
	imul rdi, [rsp + 0 + 16] ; multiply by L 
	jno .jump4912
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4912:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
.jump4913: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ad'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4914
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4914:
	; Computing bound for 'ac'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4915
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4915:
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4916
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4916:
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4917
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4917:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ad' to 0
	mov rax, 0
	push rax
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
.jump4918: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'ad'
	add qword [rsp + 24], 1
	; Compare ad to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4918 ; If ad < bound, next iter
	mov qword [rsp + 24], 0 ; ad = 0
	add qword [rsp + 16], 1 ; ac++
	; Compare ac to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4918 ; If ac < bound, next iter
	mov qword [rsp + 16], 0 ; ac = 0
	add qword [rsp + 8], 1 ; ab++
	; Compare ab to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4918 ; If ab < bound, next iter
	mov qword [rsp + 8], 0 ; ab = 0
	add qword [rsp + 0], 1 ; aa++
	; Compare aa to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4918 ; If aa < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Z'
	add qword [rsp + 16], 1
	; Compare Z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4913 ; If Z < bound, next iter
	mov qword [rsp + 16], 0 ; Z = 0
	add qword [rsp + 8], 1 ; Y++
	; Compare Y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4913 ; If Y < bound, next iter
	mov qword [rsp + 8], 0 ; Y = 0
	add qword [rsp + 0], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4913 ; If X < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4894:
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add rsp, 88 ; Local variables
	pop rbp
	ret

I:
_I:
	push rbp
	mov rbp, rsp
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4919
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4919:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4920
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4920:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump4921: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4921 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4921 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 24 ; Local variables
	pop rbp
	ret
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump4922
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const751] ; 'N'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4922:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4923
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4923:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4924
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4924:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by t 
	jno .jump4925
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4925:
	imul rdi, [rsp + 0 + 8] ; multiply by j 
	jno .jump4926
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4926:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump4927: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4928
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	jmp .jump4929
.jump4928:
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
.jump4929:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4927 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4927 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4930
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4930:
	cmp rax, [rsp + 16]
	jl .jump4931
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4931:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4932
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4932:
	cmp rax, [rsp + 24]
	jl .jump4933
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4933:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4934
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4936
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4938
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4938:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4939
	mov rax, [rel const752] ; 919
	push rax
	jmp .jump4940
.jump4939:
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4941
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	jmp .jump4942
.jump4941:
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
.jump4942:
.jump4940:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4943
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4943:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4944
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4944:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4945
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4945:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by j 
	jno .jump4946
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4946:
	imul rdi, [rsp + 0 + 8] ; multiply by u 
	jno .jump4947
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4947:
	imul rdi, [rsp + 0 + 16] ; multiply by (if B then 919 else (if false then u else i)) 
	jno .jump4948
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4948:
	imul rdi, [rsp + 0 + 24] ; multiply by h 
	jno .jump4949
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4949:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump4950: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4951
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4951:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4952
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4952:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by N 
	jno .jump4953
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4953:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump4954
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4954:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump4955: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4956
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4956:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4957
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4957:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4958
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4958:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by D 
	jno .jump4959
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4959:
	imul rdi, [rsp + 0 + 8] ; multiply by O 
	jno .jump4960
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4960:
	imul rdi, [rsp + 0 + 16] ; multiply by P 
	jno .jump4961
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4961:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump4962: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'V'
	add qword [rsp + 16], 1
	; Compare V to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4962 ; If V < bound, next iter
	mov qword [rsp + 16], 0 ; V = 0
	add qword [rsp + 8], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4962 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4962 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'S'
	add qword [rsp + 8], 1
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4955 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4955 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4963
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4963:
	cmp rax, [rsp + 16]
	jl .jump4964
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4964:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4965
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4965:
	cmp rax, [rsp + 24]
	jl .jump4966
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4966:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'Q'
	add qword [rsp + 24], 1
	; Compare Q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4950 ; If Q < bound, next iter
	mov qword [rsp + 24], 0 ; Q = 0
	add qword [rsp + 16], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4950 ; If P < bound, next iter
	mov qword [rsp + 16], 0 ; P = 0
	add qword [rsp + 8], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4950 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4950 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4967
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump4969
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	pop rax
.jump4969:
	push rax
	pop rax
	cmp rax, 0
	je .jump4970
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	mov rax, [rel const205] ; 479
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4972
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4972:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4973
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4973:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4974
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4974:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4975
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4975:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by t 
	jno .jump4976
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4976:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump4977
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4977:
	imul rdi, [rsp + 0 + 16] ; multiply by z 
	jno .jump4978
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4978:
	imul rdi, [rsp + 0 + 24] ; multiply by 479 
	jno .jump4979
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4979:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump4980: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'Q'
	add qword [rsp + 24], 1
	; Compare Q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4980 ; If Q < bound, next iter
	mov qword [rsp + 24], 0 ; Q = 0
	add qword [rsp + 16], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4980 ; If P < bound, next iter
	mov qword [rsp + 16], 0 ; P = 0
	add qword [rsp + 8], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4980 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4980 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump4971
.jump4970:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4981
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4981:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4982
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4982:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4983
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4983:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4984
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4984:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by u 
	jno .jump4985
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4985:
	imul rdi, [rsp + 0 + 8] ; multiply by t 
	jno .jump4986
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4986:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump4987
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4987:
	imul rdi, [rsp + 0 + 24] ; multiply by u 
	jno .jump4988
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4988:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump4989: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'Q'
	add qword [rsp + 24], 1
	; Compare Q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4989 ; If Q < bound, next iter
	mov qword [rsp + 24], 0 ; Q = 0
	add qword [rsp + 16], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4989 ; If P < bound, next iter
	mov qword [rsp + 16], 0 ; P = 0
	add qword [rsp + 8], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4989 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4989 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump4971:
	jmp .jump4968
.jump4967:
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4990
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4992
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4992:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4993
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4993:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4994
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4994:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4995
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4995:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by D 
	jno .jump4996
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4996:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump4997
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4997:
	imul rdi, [rsp + 0 + 16] ; multiply by y 
	jno .jump4998
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4998:
	imul rdi, [rsp + 0 + 24] ; multiply by x 
	jno .jump4999
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4999:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5000: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'Q'
	add qword [rsp + 24], 1
	; Compare Q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5000 ; If Q < bound, next iter
	mov qword [rsp + 24], 0 ; Q = 0
	add qword [rsp + 16], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5000 ; If P < bound, next iter
	mov qword [rsp + 16], 0 ; P = 0
	add qword [rsp + 8], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5000 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5000 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump4991
.jump4990:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5001
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5001:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5002
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5002:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5003
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5003:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5004
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5004:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by y 
	jno .jump5005
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5005:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump5006
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5006:
	imul rdi, [rsp + 0 + 16] ; multiply by u 
	jno .jump5007
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5007:
	imul rdi, [rsp + 0 + 24] ; multiply by k 
	jno .jump5008
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5008:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5009: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'Q'
	add qword [rsp + 24], 1
	; Compare Q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5009 ; If Q < bound, next iter
	mov qword [rsp + 24], 0 ; Q = 0
	add qword [rsp + 16], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5009 ; If P < bound, next iter
	mov qword [rsp + 16], 0 ; P = 0
	add qword [rsp + 8], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5009 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5009 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump4991:
.jump4968:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5010
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5010:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5011
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5011:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump5012
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5012:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump5013
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5013:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5014: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5015
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5015:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5016
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5016:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by t 
	jno .jump5017
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5017:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump5018
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5018:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5019: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Q'
	add qword [rsp + 8], 1
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5019 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5019 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5014 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5014 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5020
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	jmp .jump5021
.jump5020:
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump5022
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5023
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
.jump5023:
	push rax
	pop rax
.jump5022:
	push rax
.jump5021:
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	pop rdi
	pop rsi
	call _H
	add rsp, 24
	add rsp, 40
	push rax
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5024
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5024:
	; Computing bound for 'N'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5025
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5025:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5026
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5026:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5027
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5027:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5028: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'P'
	add qword [rsp + 16], 1
	; Compare P to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5028 ; If P < bound, next iter
	mov qword [rsp + 16], 0 ; P = 0
	add qword [rsp + 8], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5028 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5028 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5029
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5029:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[N : t, O : D, P : y] P) 
	jno .jump5030
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5030:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump5031
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5031:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5032: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5033
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5033:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5034
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5034:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5035
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5035:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5036
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5036:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump5037
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5037:
	imul rdi, [rsp + 0 + 8] ; multiply by y 
	jno .jump5038
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5038:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump5039
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5039:
	imul rdi, [rsp + 0 + 24] ; multiply by N 
	jno .jump5040
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5040:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5041: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'S'
	add qword [rsp + 24], 1
	; Compare S to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5041 ; If S < bound, next iter
	mov qword [rsp + 24], 0 ; S = 0
	add qword [rsp + 16], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5041 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5041 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5041 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5032 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5032 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const584] ; 721
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5042
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5042:
	cmp rax, [rsp + 16]
	jl .jump5043
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5043:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5044
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5044:
	cmp rax, [rsp + 24]
	jl .jump5045
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5045:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 40
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5046
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump5046:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5047
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5047:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5048
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5048:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump5049
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5049:
	imul rdi, [rsp + 0 + 8] ; multiply by (p / i) 
	jno .jump5050
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5050:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5051: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5052
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5052:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5053
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5053:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (h - E) 
	jno .jump5054
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5054:
	imul rdi, [rsp + 0 + 8] ; multiply by t 
	jno .jump5055
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5055:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5056: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Q'
	add qword [rsp + 8], 1
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5056 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5056 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5051 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5051 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rdi
	pop rsi
	call _H
	add rsp, 24
	add rsp, 40
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5057
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5059
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	mov rax, [rel const753] ; 643
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5061
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5061:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5062
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5062:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump5063
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5063:
	imul rdi, [rsp + 0 + 8] ; multiply by 643 
	jno .jump5064
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5064:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5065: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5065 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5065 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump5060
.jump5059:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5066
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5066:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5067
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5067:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by z 
	jno .jump5068
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5068:
	imul rdi, [rsp + 0 + 8] ; multiply by u 
	jno .jump5069
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5069:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5070: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5070 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5070 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump5060:
	jmp .jump5058
.jump5057:
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5071
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5073
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5073:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5074
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5074:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump5075
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5075:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump5076
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5076:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5077: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5077 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5077 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump5072
.jump5071:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5078
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5078:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5079
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5079:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by E 
	jno .jump5080
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5080:
	imul rdi, [rsp + 0 + 8] ; multiply by y 
	jno .jump5081
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5081:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5082: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5082 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5082 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump5072:
.jump5058:
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5083
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5083:
	cmp rax, [rsp + 16]
	jl .jump5084
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5084:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5085
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5085:
	cmp rax, [rsp + 24]
	jl .jump5086
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5086:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5087
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5087:
	cmp rax, [rsp + 32]
	jl .jump5088
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5088:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5089
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5089:
	cmp rax, [rsp + 40]
	jl .jump5090
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5090:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5091
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5091:
	cmp rax, [rsp + 48]
	jl .jump5092
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5092:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5093
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5093:
	cmp rax, [rsp + 56]
	jl .jump5094
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5094:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4937
.jump4936:
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5095
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5097
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5097:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5098
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5098:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by D 
	jno .jump5099
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5099:
	imul rdi, [rsp + 0 + 8] ; multiply by (- p) 
	jno .jump5100
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5100:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5101: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5102
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5104
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5104:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5105
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5105:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5106
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5106:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump5107
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5107:
	imul rdi, [rsp + 0 + 8] ; multiply by x 
	jno .jump5108
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5108:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump5109
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5109:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5110: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'R'
	add qword [rsp + 16], 1
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5110 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5110 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5110 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump5103
.jump5102:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5111
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5111:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5112
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5112:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5113
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5113:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump5114
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5114:
	imul rdi, [rsp + 0 + 8] ; multiply by j 
	jno .jump5115
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5115:
	imul rdi, [rsp + 0 + 16] ; multiply by s 
	jno .jump5116
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5116:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5117: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'R'
	add qword [rsp + 16], 1
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5117 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5117 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5117 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump5103:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5101 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5101 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump5096
.jump5095:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5118
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5118:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5119
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5119:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump5120
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5120:
	imul rdi, [rsp + 0 + 8] ; multiply by (- D) 
	jno .jump5121
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5121:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5122: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5123
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5123:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5124
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5124:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5125
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5125:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by N 
	jno .jump5126
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5126:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump5127
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5127:
	imul rdi, [rsp + 0 + 16] ; multiply by r 
	jno .jump5128
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5128:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5129: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5130
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5130:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump5131
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5131:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump5132: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'S'
	add qword [rsp + 0], 1
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5132 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'R'
	add qword [rsp + 16], 1
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5129 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5129 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5129 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5122 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5122 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump5096:
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5133
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5133:
	cmp rax, [rsp + 16]
	jl .jump5134
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5134:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5135
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5135:
	cmp rax, [rsp + 24]
	jl .jump5136
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5136:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4937:
	jmp .jump4935
.jump4934:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5137
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5137:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5138
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5138:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5139
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5139:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump5140
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5140:
	imul rdi, [rsp + 0 + 8] ; multiply by (- b) 
	jno .jump5141
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5141:
	imul rdi, [rsp + 0 + 16] ; multiply by s 
	jno .jump5142
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5142:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5143: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5144
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5144:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5145
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5145:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5146
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5146:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5147
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5147:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump5148
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5148:
	imul rdi, [rsp + 0 + 8] ; multiply by N 
	jno .jump5149
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5149:
	imul rdi, [rsp + 0 + 16] ; multiply by D 
	jno .jump5150
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5150:
	imul rdi, [rsp + 0 + 24] ; multiply by r 
	jno .jump5151
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5151:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump5152: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5153
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5153:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5154
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5154:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5155
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5155:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by P 
	jno .jump5156
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5156:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump5157
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5157:
	imul rdi, [rsp + 0 + 16] ; multiply by o 
	jno .jump5158
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5158:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
.jump5159: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5160
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5160:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by W 
	jno .jump5161
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5161:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'X' to 0
	mov rax, 0
	push rax
.jump5162: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'X'
	add qword [rsp + 0], 1
	; Compare X to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5162 ; If X < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'W'
	add qword [rsp + 16], 1
	; Compare W to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5159 ; If W < bound, next iter
	mov qword [rsp + 16], 0 ; W = 0
	add qword [rsp + 8], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5159 ; If V < bound, next iter
	mov qword [rsp + 8], 0 ; V = 0
	add qword [rsp + 0], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5159 ; If U < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'T'
	add qword [rsp + 24], 1
	; Compare T to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5152 ; If T < bound, next iter
	mov qword [rsp + 24], 0 ; T = 0
	add qword [rsp + 16], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5152 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5152 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5152 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const754] ; 427
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5163
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5163:
	cmp rax, [rsp + 32]
	jl .jump5164
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5164:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5165
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5165:
	cmp rax, [rsp + 40]
	jl .jump5166
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5166:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5167
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5167:
	cmp rax, [rsp + 48]
	jl .jump5168
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5168:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5169
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5169:
	cmp rax, [rsp + 56]
	jl .jump5170
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5170:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'P'
	add qword [rsp + 16], 1
	; Compare P to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5143 ; If P < bound, next iter
	mov qword [rsp + 16], 0 ; P = 0
	add qword [rsp + 8], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5143 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5143 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5171
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5171:
	cmp rax, [rsp + 24]
	jl .jump5172
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5172:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5173
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5173:
	cmp rax, [rsp + 32]
	jl .jump5174
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5174:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5175
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5175:
	cmp rax, [rsp + 40]
	jl .jump5176
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5176:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4935:
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5177
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const755] ; 35.36
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5178
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	jmp .jump5179
.jump5178:
	mov rax, [rel const275] ; 553
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
.jump5179:
	pop rax
.jump5177:
	push rax
	pop rax
	cmp rax, 0
	je .jump5180
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5182
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5182:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump5183
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5183:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5184: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5185
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5185:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5186
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5186:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5187
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5187:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- E) 
	jno .jump5188
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5188:
	imul rdi, [rsp + 0 + 8] ; multiply by j 
	jno .jump5189
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5189:
	imul rdi, [rsp + 0 + 16] ; multiply by y 
	jno .jump5190
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5190:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump5191: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5192
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5192:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5193
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5193:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5194
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5194:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5195
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5195:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by D 
	jno .jump5196
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5196:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump5197
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5197:
	imul rdi, [rsp + 0 + 16] ; multiply by t 
	jno .jump5198
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5198:
	imul rdi, [rsp + 0 + 24] ; multiply by s 
	jno .jump5199
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5199:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump5200: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'U'
	add qword [rsp + 24], 1
	; Compare U to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5200 ; If U < bound, next iter
	mov qword [rsp + 24], 0 ; U = 0
	add qword [rsp + 16], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5200 ; If T < bound, next iter
	mov qword [rsp + 16], 0 ; T = 0
	add qword [rsp + 8], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5200 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5200 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5191 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5191 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5191 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5201
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	jmp .jump5202
.jump5201:
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
.jump5202:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5203
	mov rax, [rel const133] ; 262
	push rax
	jmp .jump5204
.jump5203:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
.jump5204:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5205
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5205:
	cmp rax, [rsp + 24]
	jl .jump5206
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5206:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5207
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5207:
	cmp rax, [rsp + 32]
	jl .jump5208
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5208:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5209
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5209:
	cmp rax, [rsp + 40]
	jl .jump5210
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5210:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'N'
	add qword [rsp + 0], 1
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5184 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump5181
.jump5180:
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5211
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5213
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5213:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5214
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5214:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5215
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5215:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5216
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5216:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by (u * t) 
	jno .jump5217
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5217:
	imul rdi, [rsp + 0 + 8] ; multiply by D 
	jno .jump5218
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5218:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump5219
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5219:
	imul rdi, [rsp + 0 + 24] ; multiply by j 
	jno .jump5220
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5220:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5221: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'Q'
	add qword [rsp + 24], 1
	; Compare Q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5221 ; If Q < bound, next iter
	mov qword [rsp + 24], 0 ; Q = 0
	add qword [rsp + 16], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5221 ; If P < bound, next iter
	mov qword [rsp + 16], 0 ; P = 0
	add qword [rsp + 8], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5221 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5221 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5222
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5222:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5223
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5223:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5224
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5224:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5225
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5225:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by t 
	jno .jump5226
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5226:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump5227
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5227:
	imul rdi, [rsp + 0 + 16] ; multiply by t 
	jno .jump5228
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5228:
	imul rdi, [rsp + 0 + 24] ; multiply by p 
	jno .jump5229
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5229:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5230: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 320 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5231
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5231:
	cmp rax, [rsp + 16]
	jl .jump5232
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5232:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5233
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5233:
	cmp rax, [rsp + 24]
	jl .jump5234
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5234:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'Q'
	add qword [rsp + 24], 1
	; Compare Q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5230 ; If Q < bound, next iter
	mov qword [rsp + 24], 0 ; Q = 0
	add qword [rsp + 16], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5230 ; If P < bound, next iter
	mov qword [rsp + 16], 0 ; P = 0
	add qword [rsp + 8], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5230 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5230 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rdi, 80
	call _jpl_alloc
	; Moving 80 bytes from rsp to rax 
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 80
	push rax
	mov rax, 2
	push rax
	jmp .jump5212
.jump5211:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5235
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5235:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump5236
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5236:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5237: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5238
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5240
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5240:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5241
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5241:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5242
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5242:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5243
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5243:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump5244
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5244:
	imul rdi, [rsp + 0 + 8] ; multiply by t 
	jno .jump5245
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5245:
	imul rdi, [rsp + 0 + 16] ; multiply by t 
	jno .jump5246
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5246:
	imul rdi, [rsp + 0 + 24] ; multiply by h 
	jno .jump5247
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5247:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump5248: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'R'
	add qword [rsp + 24], 1
	; Compare R to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5248 ; If R < bound, next iter
	mov qword [rsp + 24], 0 ; R = 0
	add qword [rsp + 16], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5248 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5248 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5248 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump5239
.jump5238:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5249
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5249:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5250
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5250:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5251
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5251:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5252
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5252:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by N 
	jno .jump5253
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5253:
	imul rdi, [rsp + 0 + 8] ; multiply by D 
	jno .jump5254
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5254:
	imul rdi, [rsp + 0 + 16] ; multiply by y 
	jno .jump5255
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5255:
	imul rdi, [rsp + 0 + 24] ; multiply by E 
	jno .jump5256
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5256:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump5257: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'R'
	add qword [rsp + 24], 1
	; Compare R to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5257 ; If R < bound, next iter
	mov qword [rsp + 24], 0 ; R = 0
	add qword [rsp + 16], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5257 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5257 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5257 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump5239:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'N'
	add qword [rsp + 0], 1
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5237 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump5212:
.jump5181:
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5258
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5258:
	cmp rax, [rsp + 8]
	jl .jump5259
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5259:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5260
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5260:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5261
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5261:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump5262
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5262:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump5263
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5263:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5264: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'Q'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5265
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5265:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5266: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'P'
	add qword [rsp + 0], 1
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5266 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5267
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5267:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5268
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5268:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5269: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'Q'
	add qword [rsp + 8], 1
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5269 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5269 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const756] ; 78.88
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5270
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
.jump5270:
	push rax
	pop rax
	cmp rax, 0
	je .jump5271
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	mov rax, [rel const47] ; 650
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5273
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5273:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 650 
	jno .jump5274
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5274:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5275: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'P'
	add qword [rsp + 0], 1
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5275 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5276
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5276:
	cmp rax, [rsp + 8]
	jl .jump5277
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5277:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5278
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5280
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5280:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5281
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5281:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- (k - o)) 
	jno .jump5282
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5282:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump5283
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5283:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5284: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Q'
	add qword [rsp + 8], 1
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5284 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5284 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump5279
.jump5278:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5285
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5285:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5286
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5286:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by z 
	jno .jump5287
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5287:
	imul rdi, [rsp + 0 + 8] ; multiply by u 
	jno .jump5288
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5288:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5289: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const317] ; 888
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Q'
	add qword [rsp + 8], 1
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5289 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5289 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump5279:
	jmp .jump5272
.jump5271:
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5290
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5292
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5292:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5293
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5293:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by t 
	jno .jump5294
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5294:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump5295
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5295:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5296: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5297
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5297:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5298
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5298:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by Q 
	jno .jump5299
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5299:
	imul rdi, [rsp + 0 + 8] ; multiply by t 
	jno .jump5300
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5300:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump5301: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const757] ; 566
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'S'
	add qword [rsp + 8], 1
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5301 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5301 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'Q'
	add qword [rsp + 8], 1
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5296 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5296 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5302
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5302:
	cmp rax, [rsp + 16]
	jl .jump5303
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5303:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5304
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5304:
	cmp rax, [rsp + 24]
	jl .jump5305
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5305:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5291
.jump5290:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5306
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5306:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5307
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5307:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump5308
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5308:
	imul rdi, [rsp + 0 + 8] ; multiply by D 
	jno .jump5309
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5309:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5310: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5311
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5311:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5312
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5312:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by N 
	jno .jump5313
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5313:
	imul rdi, [rsp + 0 + 8] ; multiply by D 
	jno .jump5314
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5314:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump5315: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'S'
	add qword [rsp + 8], 1
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5315 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5315 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'Q'
	add qword [rsp + 8], 1
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5310 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5310 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5316
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5316:
	cmp rax, [rsp + 16]
	jl .jump5317
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5317:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5318
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5318:
	cmp rax, [rsp + 24]
	jl .jump5319
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5319:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5291:
.jump5272:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5264 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5264 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5320
	sub rsp, 40
	; Moving 40 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 240 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 240 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 240 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5322
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5322:
	cmp rax, [rsp + 32]
	jl .jump5323
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5323:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5324
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5324:
	cmp rax, [rsp + 40]
	jl .jump5325
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5325:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5326
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5326:
	cmp rax, [rsp + 48]
	jl .jump5327
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5327:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5328
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5328:
	cmp rax, [rsp + 56]
	jl .jump5329
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5329:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5321
.jump5320:
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
.jump5321:
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const94] ; False
	push rax
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump5330
	mov rax, [rel const94] ; False
	push rax
	pop rax
.jump5330:
	push rax
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5331
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5331:
	cmp rax, [rsp + 8]
	jl .jump5332
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5332:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5333
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	jmp .jump5334
.jump5333:
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
.jump5334:
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	pop rdi
	pop rsi
	call _H
	add rsp, 24
	add rsp, 40
	push rax
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5335
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5335:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5336
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5336:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5337
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5337:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5338
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5338:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by E 
	jno .jump5339
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5339:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump5340
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5340:
	imul rdi, [rsp + 0 + 16] ; multiply by y 
	jno .jump5341
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5341:
	imul rdi, [rsp + 0 + 24] ; multiply by r 
	jno .jump5342
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5342:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5343: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5344
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5346
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5346:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5347
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5347:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5348
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5348:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5349
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5349:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump5350
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5350:
	imul rdi, [rsp + 0 + 8] ; multiply by N 
	jno .jump5351
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5351:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump5352
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5352:
	imul rdi, [rsp + 0 + 24] ; multiply by j 
	jno .jump5353
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5353:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump5354: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5355
	sub rsp, 32
	; Moving 32 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump5356
.jump5355:
	sub rsp, 32
	; Moving 32 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
.jump5356:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'U'
	add qword [rsp + 24], 1
	; Compare U to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5354 ; If U < bound, next iter
	mov qword [rsp + 24], 0 ; U = 0
	add qword [rsp + 16], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5354 ; If T < bound, next iter
	mov qword [rsp + 16], 0 ; T = 0
	add qword [rsp + 8], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5354 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5354 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump5345
.jump5344:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5357
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5357:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5358
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5358:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5359
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5359:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5360
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5360:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof rgba[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- y) 
	jno .jump5361
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5361:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump5362
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5362:
	imul rdi, [rsp + 0 + 16] ; multiply by (o + o) 
	jno .jump5363
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5363:
	imul rdi, [rsp + 0 + 24] ; multiply by r 
	jno .jump5364
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5364:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump5365: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5366
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5366:
	; Computing bound for 'X'
	mov rax, [rel const758] ; 628
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5367
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5367:
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5368
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5368:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5369
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5369:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump5370
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5370:
	imul rdi, [rsp + 0 + 8] ; multiply by S 
	jno .jump5371
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5371:
	imul rdi, [rsp + 0 + 16] ; multiply by 628 
	jno .jump5372
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5372:
	imul rdi, [rsp + 0 + 24] ; multiply by T 
	jno .jump5373
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5373:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump5374: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'Y'
	add qword [rsp + 24], 1
	; Compare Y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5374 ; If Y < bound, next iter
	mov qword [rsp + 24], 0 ; Y = 0
	add qword [rsp + 16], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5374 ; If X < bound, next iter
	mov qword [rsp + 16], 0 ; X = 0
	add qword [rsp + 8], 1 ; W++
	; Compare W to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5374 ; If W < bound, next iter
	mov qword [rsp + 8], 0 ; W = 0
	add qword [rsp + 0], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5374 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'U'
	add qword [rsp + 24], 1
	; Compare U to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5365 ; If U < bound, next iter
	mov qword [rsp + 24], 0 ; U = 0
	add qword [rsp + 16], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5365 ; If T < bound, next iter
	mov qword [rsp + 16], 0 ; T = 0
	add qword [rsp + 8], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5365 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5365 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5375
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	jmp .jump5376
.jump5375:
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
.jump5376:
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5377
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5377:
	cmp rax, [rsp + 32]
	jl .jump5378
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5378:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5379
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5379:
	cmp rax, [rsp + 40]
	jl .jump5380
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5380:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5381
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5381:
	cmp rax, [rsp + 48]
	jl .jump5382
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5382:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5383
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5383:
	cmp rax, [rsp + 56]
	jl .jump5384
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5384:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5345:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'Q'
	add qword [rsp + 24], 1
	; Compare Q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5343 ; If Q < bound, next iter
	mov qword [rsp + 24], 0 ; Q = 0
	add qword [rsp + 16], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5343 ; If P < bound, next iter
	mov qword [rsp + 16], 0 ; P = 0
	add qword [rsp + 8], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5343 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5343 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5385
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5385:
	cmp rax, [rsp + 32]
	jl .jump5386
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5386:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5387
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5387:
	cmp rax, [rsp + 40]
	jl .jump5388
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5388:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5389
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5389:
	cmp rax, [rsp + 48]
	jl .jump5390
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5390:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5391
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5391:
	cmp rax, [rsp + 56]
	jl .jump5392
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5392:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5393
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5393:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5394
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5394:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by y 
	jno .jump5395
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5395:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump5396
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5396:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5397: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5398
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5400
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5400:
	; Computing bound for 'P'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5401
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5401:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5402: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'P'
	add qword [rsp + 0], 1
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5402 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5403
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5403:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[P : N] (- y)) 
	jno .jump5404
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5404:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump5405
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5405:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5406: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5407
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5407:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5408
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5408:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump5409
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5409:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump5410
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5410:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump5411: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'S'
	add qword [rsp + 8], 1
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5411 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5411 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'Q'
	add qword [rsp + 8], 1
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5406 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5406 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump5399
.jump5398:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5412
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5412:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5413
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5413:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump5414
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5414:
	imul rdi, [rsp + 0 + 8] ; multiply by u 
	jno .jump5415
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5415:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5416: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5417
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5419
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5419:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5420
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5420:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by t 
	jno .jump5421
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5421:
	imul rdi, [rsp + 0 + 8] ; multiply by x 
	jno .jump5422
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5422:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump5423: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'S'
	add qword [rsp + 8], 1
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5423 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5423 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump5418
.jump5417:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5424
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5424:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5425
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5425:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump5426
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5426:
	imul rdi, [rsp + 0 + 8] ; multiply by P 
	jno .jump5427
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5427:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump5428: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'S'
	add qword [rsp + 8], 1
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5428 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5428 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump5418:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'Q'
	add qword [rsp + 8], 1
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5416 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5416 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump5399:
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5429
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5429:
	cmp rax, [rsp + 16]
	jl .jump5430
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5430:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5431
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5431:
	cmp rax, [rsp + 24]
	jl .jump5432
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5432:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5397 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5397 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5433
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5433:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5434
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5434:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5435
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5435:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5436
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5436:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,][,] 
	imul rdi, [rsp + 0 + 0] ; multiply by j 
	jno .jump5437
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5437:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump5438
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5438:
	imul rdi, [rsp + 0 + 16] ; multiply by s 
	jno .jump5439
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5439:
	imul rdi, [rsp + 0 + 24] ; multiply by p 
	jno .jump5440
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5440:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5441: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5442
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5442:
	; Computing bound for 'R'
	mov rax, [rel const759] ; 701
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5443
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5443:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 701 
	jno .jump5444
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5444:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump5445
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5445:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump5446: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5447
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5447:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5448
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5448:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by z 
	jno .jump5449
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5449:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump5450
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5450:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump5451: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'U'
	add qword [rsp + 8], 1
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5451 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5451 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'S'
	add qword [rsp + 8], 1
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5446 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5446 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'Q'
	add qword [rsp + 24], 1
	; Compare Q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5441 ; If Q < bound, next iter
	mov qword [rsp + 24], 0 ; Q = 0
	add qword [rsp + 16], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5441 ; If P < bound, next iter
	mov qword [rsp + 16], 0 ; P = 0
	add qword [rsp + 8], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5441 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5441 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5452
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5452:
	cmp rax, [rsp + 32]
	jl .jump5453
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5453:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5454
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5454:
	cmp rax, [rsp + 40]
	jl .jump5455
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5455:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5456
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5456:
	cmp rax, [rsp + 48]
	jl .jump5457
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5457:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5458
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5458:
	cmp rax, [rsp + 56]
	jl .jump5459
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5459:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const228] ; 812
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5460
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5460:
	cmp rax, [rsp + 16]
	jl .jump5461
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5461:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5462
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5462:
	cmp rax, [rsp + 24]
	jl .jump5463
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5463:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const209] ; 530
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5464
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5464:
	cmp rax, [rsp + 16]
	jl .jump5465
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5465:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5466
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5466:
	cmp rax, [rsp + 24]
	jl .jump5467
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5467:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rdi
	pop rsi
	call _H
	add rsp, 24
	add rsp, 40
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5468
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5468:
	cmp rax, [rsp + 24]
	jl .jump5469
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5469:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5470
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5470:
	cmp rax, [rsp + 32]
	jl .jump5471
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5471:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5472
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5472:
	cmp rax, [rsp + 40]
	jl .jump5473
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5473:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5474
	mov rax, [rel const94] ; False
	push rax
	jmp .jump5475
.jump5474:
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
.jump5475:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5476
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5478
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5478:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5479
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5479:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5480
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5480:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5481
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5481:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump5482
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5482:
	imul rdi, [rsp + 0 + 8] ; multiply by O 
	jno .jump5483
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5483:
	imul rdi, [rsp + 0 + 16] ; multiply by O 
	jno .jump5484
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5484:
	imul rdi, [rsp + 0 + 24] ; multiply by O 
	jno .jump5485
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5485:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5486: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'S'
	add qword [rsp + 24], 1
	; Compare S to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5486 ; If S < bound, next iter
	mov qword [rsp + 24], 0 ; S = 0
	add qword [rsp + 16], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5486 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5486 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5486 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const760] ; 142
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5487
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5487:
	cmp rax, [rsp + 32]
	jl .jump5488
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5488:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5489
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5489:
	cmp rax, [rsp + 40]
	jl .jump5490
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5490:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5491
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5491:
	cmp rax, [rsp + 48]
	jl .jump5492
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5492:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5493
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5493:
	cmp rax, [rsp + 56]
	jl .jump5494
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5494:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5477
.jump5476:
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
.jump5477:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5495
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5495:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5496
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5496:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5497
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5497:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5498
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5498:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5499: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const761] ; 47.53
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'S'
	add qword [rsp + 24], 1
	; Compare S to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5499 ; If S < bound, next iter
	mov qword [rsp + 24], 0 ; S = 0
	add qword [rsp + 16], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5499 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5499 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5499 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5500
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5502
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5502:
	; Computing bound for 'R'
	mov rax, [rel const762] ; 944
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5503
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5503:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5504
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5504:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5505
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5505:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump5506
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5506:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump5507
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5507:
	imul rdi, [rsp + 0 + 16] ; multiply by 944 
	jno .jump5508
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5508:
	imul rdi, [rsp + 0 + 24] ; multiply by h 
	jno .jump5509
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5509:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5510: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5511
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5513
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5513:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5514
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5514:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5515
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5515:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by P 
	jno .jump5516
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5516:
	imul rdi, [rsp + 0 + 8] ; multiply by P 
	jno .jump5517
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5517:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump5518
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5518:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump5519: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump5520
	sub rsp, 40
	; Moving 40 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 32]
		mov [rsp + 32], r10
		mov r10, [r12 - 240 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 240 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 240 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const149] ; 268
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5521
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5521:
	cmp rax, [rsp + 32]
	jl .jump5522
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5522:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5523
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5523:
	cmp rax, [rsp + 40]
	jl .jump5524
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5524:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5525
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5525:
	cmp rax, [rsp + 48]
	jl .jump5526
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5526:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5527
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5527:
	cmp rax, [rsp + 56]
	jl .jump5528
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5528:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
.jump5520:
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'V'
	add qword [rsp + 16], 1
	; Compare V to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5519 ; If V < bound, next iter
	mov qword [rsp + 16], 0 ; V = 0
	add qword [rsp + 8], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5519 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5519 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump5512
.jump5511:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5529
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5529:
	; Computing bound for 'U'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5530
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5530:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5531
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5531:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5532
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5532:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump5533
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5533:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump5534
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5534:
	imul rdi, [rsp + 0 + 16] ; multiply by R 
	jno .jump5535
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5535:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump5536: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'V'
	add qword [rsp + 16], 1
	; Compare V to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5536 ; If V < bound, next iter
	mov qword [rsp + 16], 0 ; V = 0
	add qword [rsp + 8], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5536 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5536 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5537
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5537:
	cmp rax, [rsp + 24]
	jl .jump5538
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5538:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5539
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5539:
	cmp rax, [rsp + 32]
	jl .jump5540
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5540:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5541
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5541:
	cmp rax, [rsp + 40]
	jl .jump5542
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5542:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5543
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5543:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5544
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5544:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (P + P) 
	jno .jump5545
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5545:
imul rdi, [rsp + 0 + 8] ; multiply by (array[T : x, U : h, V : R] x)[P, h, o] 
	jno .jump5546
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5546:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump5547
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5547:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump5548: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const78] ; 820
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'V'
	add qword [rsp + 16], 1
	; Compare V to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5548 ; If V < bound, next iter
	mov qword [rsp + 16], 0 ; V = 0
	add qword [rsp + 8], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5548 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5548 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump5512:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'S'
	add qword [rsp + 24], 1
	; Compare S to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5510 ; If S < bound, next iter
	mov qword [rsp + 24], 0 ; S = 0
	add qword [rsp + 16], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5510 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5510 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5510 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5549
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump5549:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5550
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5550:
	cmp rax, [rsp + 32]
	jl .jump5551
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5551:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5552
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5552:
	cmp rax, [rsp + 40]
	jl .jump5553
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5553:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5554
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5554:
	cmp rax, [rsp + 48]
	jl .jump5555
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5555:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5556
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5556:
	cmp rax, [rsp + 56]
	jl .jump5557
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5557:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5501
.jump5500:
	mov rax, [rel const763] ; 7.64
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5558
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5560
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	pop rax
.jump5560:
	push rax
	pop rax
	cmp rax, 0
	je .jump5561
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump5563
	mov rax, [rel const764] ; 38.64
	push rax
	mov rax, [rel const765] ; 53.82
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
.jump5563:
	push rax
	pop rax
	cmp rax, 0
	je .jump5564
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5566
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5566:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5567
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5567:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5568
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5568:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by D 
	jno .jump5569
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5569:
	imul rdi, [rsp + 0 + 8] ; multiply by D 
	jno .jump5570
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5570:
	imul rdi, [rsp + 0 + 16] ; multiply by j 
	jno .jump5571
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5571:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5572: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5573
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5573:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5574
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5574:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5575
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5575:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump5576
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5576:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump5577
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5577:
	imul rdi, [rsp + 0 + 16] ; multiply by r 
	jno .jump5578
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5578:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump5579: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'U'
	add qword [rsp + 16], 1
	; Compare U to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5579 ; If U < bound, next iter
	mov qword [rsp + 16], 0 ; U = 0
	add qword [rsp + 8], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5579 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5579 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'R'
	add qword [rsp + 16], 1
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5572 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5572 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5572 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump5565
.jump5564:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5580
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5580:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5581
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5581:
	; Computing bound for 'P'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5582
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5582:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5583
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5583:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5584
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5584:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5585: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'R'
	add qword [rsp + 16], 1
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5585 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5585 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5585 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5586
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5586:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[P : p, Q : x, R : p] E) 
	jno .jump5587
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5587:
	imul rdi, [rsp + 0 + 8] ; multiply by D 
	jno .jump5588
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5588:
	imul rdi, [rsp + 0 + 16] ; multiply by D 
	jno .jump5589
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5589:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5590: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5591
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5591:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5592
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5592:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5593
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5593:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump5594
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5594:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump5595
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5595:
	imul rdi, [rsp + 0 + 16] ; multiply by D 
	jno .jump5596
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5596:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump5597: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'U'
	add qword [rsp + 16], 1
	; Compare U to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5597 ; If U < bound, next iter
	mov qword [rsp + 16], 0 ; U = 0
	add qword [rsp + 8], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5597 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5597 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'R'
	add qword [rsp + 16], 1
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5590 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5590 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5590 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump5565:
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5598
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5598:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5599
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5599:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5600
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5600:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5601
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5601:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump5602
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5602:
	imul rdi, [rsp + 0 + 8] ; multiply by (- E) 
	jno .jump5603
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5603:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump5604
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5604:
	imul rdi, [rsp + 0 + 24] ; multiply by s 
	jno .jump5605
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5605:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5606: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'S'
	add qword [rsp + 24], 1
	; Compare S to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5606 ; If S < bound, next iter
	mov qword [rsp + 24], 0 ; S = 0
	add qword [rsp + 16], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5606 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5606 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5606 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5607
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5607:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5608
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5608:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by j 
	jno .jump5609
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5609:
	imul rdi, [rsp + 0 + 8] ; multiply by O 
	jno .jump5610
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5610:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5611: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5612
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5612:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5613
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5613:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by O 
	jno .jump5614
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5614:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump5615
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5615:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump5616: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'S'
	add qword [rsp + 8], 1
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5616 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5616 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'Q'
	add qword [rsp + 8], 1
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5611 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5611 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	pop rdi
	pop rsi
	call _H
	add rsp, 24
	add rsp, 40
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5617
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5617:
	cmp rax, [rsp + 24]
	jl .jump5618
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5618:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5619
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5619:
	cmp rax, [rsp + 32]
	jl .jump5620
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5620:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5621
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5621:
	cmp rax, [rsp + 40]
	jl .jump5622
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5622:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5562
.jump5561:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5623
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5623:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5624
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5624:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5625
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5625:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump5626
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5626:
	imul rdi, [rsp + 0 + 8] ; multiply by z 
	jno .jump5627
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5627:
	imul rdi, [rsp + 0 + 16] ; multiply by x 
	jno .jump5628
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5628:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5629: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5630
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump5630:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'R'
	add qword [rsp + 16], 1
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5629 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5629 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5629 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump5562:
	jmp .jump5559
.jump5558:
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5631
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5633
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	jmp .jump5634
.jump5633:
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
.jump5634:
	pop rax
	cmp rax, 0
	jne .jump5635
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
.jump5635:
	push rax
	pop rax
	cmp rax, 0
	je .jump5636
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	jmp .jump5637
.jump5636:
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
.jump5637:
	jmp .jump5632
.jump5631:
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5638
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	jmp .jump5639
.jump5638:
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
.jump5639:
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	mov rax, [rel const412] ; 875
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5640
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5640:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5641
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5641:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5642
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5642:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5643
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5643:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by z 
	jno .jump5644
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5644:
	imul rdi, [rsp + 0 + 8] ; multiply by x 
	jno .jump5645
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5645:
	imul rdi, [rsp + 0 + 16] ; multiply by O 
	jno .jump5646
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5646:
	imul rdi, [rsp + 0 + 24] ; multiply by 875 
	jno .jump5647
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5647:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5648: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'S'
	add qword [rsp + 24], 1
	; Compare S to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5648 ; If S < bound, next iter
	mov qword [rsp + 24], 0 ; S = 0
	add qword [rsp + 16], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5648 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5648 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5648 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5649
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5649:
	cmp rax, [rsp + 32]
	jl .jump5650
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5650:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5651
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5651:
	cmp rax, [rsp + 40]
	jl .jump5652
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5652:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5653
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5653:
	cmp rax, [rsp + 48]
	jl .jump5654
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5654:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5655
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5655:
	cmp rax, [rsp + 56]
	jl .jump5656
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5656:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5657
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5657:
	cmp rax, [rsp + 8]
	jl .jump5658
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5658:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5632:
	pop rax
	cmp rax, 0
	je .jump5659
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5661
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5661:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5662
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5662:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5663: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'Q'
	add qword [rsp + 8], 1
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5663 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5663 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5664
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5664:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5665
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5665:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5666
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5666:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump5667
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5667:
	imul rdi, [rsp + 0 + 8] ; multiply by u 
	jno .jump5668
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5668:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[P : b, Q : t] h) 
	jno .jump5669
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5669:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5670: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const8] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'R'
	add qword [rsp + 16], 1
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5670 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5670 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5670 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump5660
.jump5659:
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5671
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5673
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5675
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5677
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5677:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5678
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5678:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5679
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5679:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by D 
	jno .jump5680
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5680:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump5681
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5681:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump5682
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5682:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5683: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'R'
	add qword [rsp + 16], 1
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5683 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5683 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5683 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump5676
.jump5675:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5684
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5684:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5685
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5685:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5686
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5686:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by D 
	jno .jump5687
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5687:
	imul rdi, [rsp + 0 + 8] ; multiply by j 
	jno .jump5688
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5688:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump5689
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5689:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5690: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'R'
	add qword [rsp + 16], 1
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5690 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5690 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5690 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump5676:
	jmp .jump5674
.jump5673:
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5691
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5693
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5693:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5694
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5694:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5695
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5695:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by z 
	jno .jump5696
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5696:
	imul rdi, [rsp + 0 + 8] ; multiply by D 
	jno .jump5697
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5697:
	imul rdi, [rsp + 0 + 16] ; multiply by z 
	jno .jump5698
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5698:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5699: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'R'
	add qword [rsp + 16], 1
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5699 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5699 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5699 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump5692
.jump5691:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5700
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5700:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5701
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5701:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5702
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5702:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump5703
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5703:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump5704
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5704:
	imul rdi, [rsp + 0 + 16] ; multiply by s 
	jno .jump5705
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5705:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5706: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'R'
	add qword [rsp + 16], 1
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5706 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5706 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5706 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump5692:
.jump5674:
	jmp .jump5672
.jump5671:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5707
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5707:
	; Computing bound for 'Q'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5708
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5708:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5709
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5709:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5710
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5710:
	; Computing bound for 'P'
	sub rsp, 32
	; Moving 32 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 280 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 280 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5711
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5711:
	cmp rax, [rsp + 24]
	jl .jump5712
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5712:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5713
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5713:
	cmp rax, [rsp + 32]
	jl .jump5714
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5714:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5715
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5715:
	cmp rax, [rsp + 40]
	jl .jump5716
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5716:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5717
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5717:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5718: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'S'
	add qword [rsp + 24], 1
	; Compare S to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5718 ; If S < bound, next iter
	mov qword [rsp + 24], 0 ; S = 0
	add qword [rsp + 16], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5718 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5718 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5718 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5719
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5719:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5720
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump5721
.jump5720:
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5722
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump5722:
	cqo
	idiv r10
	push rax
.jump5721:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5723
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5723:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (if m then O else (j / y)) 
	jno .jump5724
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5724:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[P : w[j, o, i], Q : r, R : p, S : O] k) 
	jno .jump5725
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5725:
	imul rdi, [rsp + 0 + 16] ; multiply by x 
	jno .jump5726
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5726:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5727: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'R'
	add qword [rsp + 16], 1
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5727 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5727 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5727 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump5672:
.jump5660:
.jump5559:
.jump5501:
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5728
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5728:
	cmp rax, [rsp + 24]
	jl .jump5729
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5729:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5730
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5730:
	cmp rax, [rsp + 32]
	jl .jump5731
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5731:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5732
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5732:
	cmp rax, [rsp + 40]
	jl .jump5733
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5733:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump5734
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const766] ; 'P'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5734:
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 200 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5735
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5735:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5736
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5736:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5737
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5737:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5738
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5738:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump5739
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5739:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump5740
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5740:
	imul rdi, [rsp + 0 + 16] ; multiply by O 
	jno .jump5741
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5741:
	imul rdi, [rsp + 0 + 24] ; multiply by k 
	jno .jump5742
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5742:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump5743: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'U'
	add qword [rsp + 24], 1
	; Compare U to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5743 ; If U < bound, next iter
	mov qword [rsp + 24], 0 ; U = 0
	add qword [rsp + 16], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5743 ; If T < bound, next iter
	mov qword [rsp + 16], 0 ; T = 0
	add qword [rsp + 8], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5743 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5743 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5744
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	jmp .jump5745
.jump5744:
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
.jump5745:
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5746
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump5747
.jump5746:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
.jump5747:
	mov rax, [rel const767] ; 152
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5748
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5748:
	cmp rax, [rsp + 8]
	jl .jump5749
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5749:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5750
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5750:
	cmp rax, [rsp + 32]
	jl .jump5751
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5751:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5752
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5752:
	cmp rax, [rsp + 40]
	jl .jump5753
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5753:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5754
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5754:
	cmp rax, [rsp + 48]
	jl .jump5755
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5755:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5756
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5756:
	cmp rax, [rsp + 56]
	jl .jump5757
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5757:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 72 ; Local variables
	pop rbp
	ret

J:
_J:
	push rbp
	mov rbp, rsp
	push rdi
	push rsi
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 16 ; Local variables
	pop rbp
	ret
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5758
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5758:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5759
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5759:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by z 
	jno .jump5760
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5760:
	imul rdi, [rsp + 0 + 8] ; multiply by u 
	jno .jump5761
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5761:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5762: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5763
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5765
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5767
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5767:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5768
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5768:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5769
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5769:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by (r + (- b)) 
	jno .jump5770
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5770:
	imul rdi, [rsp + 0 + 8] ; multiply by E 
	jno .jump5771
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5771:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump5772
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5772:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5773: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'R'
	add qword [rsp + 16], 1
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5773 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5773 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5773 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump5766
.jump5765:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5774
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5774:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5775
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5775:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5776
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5776:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by D 
	jno .jump5777
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5777:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump5778
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5778:
	imul rdi, [rsp + 0 + 16] ; multiply by (- b) 
	jno .jump5779
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5779:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5780: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'R'
	add qword [rsp + 16], 1
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5780 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5780 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5780 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump5766:
	sub rsp, 32
	; Moving 32 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5781
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5783
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5783:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5784
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5784:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5785
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5785:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump5786
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5786:
	imul rdi, [rsp + 0 + 8] ; multiply by L 
	jno .jump5787
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5787:
	imul rdi, [rsp + 0 + 16] ; multiply by E 
	jno .jump5788
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5788:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5789: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'R'
	add qword [rsp + 16], 1
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5789 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5789 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5789 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump5782
.jump5781:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5790
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5790:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5791
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5791:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5792
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5792:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by t 
	jno .jump5793
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5793:
	imul rdi, [rsp + 0 + 8] ; multiply by (x + y) 
	jno .jump5794
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5794:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump5795
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5795:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5796: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'R'
	add qword [rsp + 16], 1
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5796 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5796 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5796 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump5782:
	sub rsp, 24
	; Moving 24 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 320 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5797
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5797:
	cmp rax, [rsp + 16]
	jl .jump5798
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5798:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5799
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5799:
	cmp rax, [rsp + 24]
	jl .jump5800
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5800:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rdi
	pop rsi
	call _J
	add rsp, 32
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _I
	add rsp, 32
	add rsp, 32
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _I
	add rsp, 32
	add rsp, 32
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump5764
.jump5763:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
.jump5764:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5762 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5762 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5801
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5801:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5802
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const768] ; 613
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	jmp .jump5803
.jump5802:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5804
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5804:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5805
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5805:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5806
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5806:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump5807
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5807:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump5808
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5808:
	imul rdi, [rsp + 0 + 16] ; multiply by j 
	jno .jump5809
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5809:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump5810: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 120 to rsp 
		mov r10, [r12 - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5810 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5810 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5810 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5811
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5811:
	cmp rax, [rsp + 24]
	jl .jump5812
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5812:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5813
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5813:
	cmp rax, [rsp + 32]
	jl .jump5814
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5814:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5815
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5815:
	cmp rax, [rsp + 40]
	jl .jump5816
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5816:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
.jump5803:
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5817
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5817:
	cmp rax, [rsp + 8]
	jl .jump5818
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5818:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5819
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5821
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5821:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5822
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5822:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump5823: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'P'
	add qword [rsp + 8], 1
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5823 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5823 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump5820
.jump5819:
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
.jump5820:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5824
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5824:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (if [(if B then (613 >= (- s)) else (! (array[O : o, P : k, Q : j] f)[o, p, E]))][o] then (sum[O : i, P : r] O) else z) 
	jno .jump5825
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5825:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump5826
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5826:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump5827: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'P'
	add qword [rsp + 8], 1
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5827 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5827 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 88 ; Local variables
	pop rbp
	ret
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump5828
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const769] ; 'T'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5828:
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5829
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5831
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5831:
	; Computing bound for 'T'
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5832
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5832:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5833
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5833:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5834
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5834:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5835
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump5835:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5836
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5836:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by (- (z / L)) 
	jno .jump5837
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5837:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump5838
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5838:
	imul rdi, [rsp + 0 + 16] ; multiply by E 
	jno .jump5839
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5839:
	imul rdi, [rsp + 0 + 24] ; multiply by r 
	jno .jump5840
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5840:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump5841: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 288 to rsp 
		mov r10, [r12 - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5842
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5844
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5844:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by U 
	jno .jump5845
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5845:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'X' to 0
	mov rax, 0
	push rax
.jump5846: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'X'
	add qword [rsp + 0], 1
	; Compare X to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5846 ; If X < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump5843
.jump5842:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5847
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5847:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump5848
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5848:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'X' to 0
	mov rax, 0
	push rax
.jump5849: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'X'
	add qword [rsp + 0], 1
	; Compare X to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5849 ; If X < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump5843:
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5850
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5850:
	cmp rax, [rsp + 8]
	jl .jump5851
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5851:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'W'
	add qword [rsp + 24], 1
	; Compare W to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5841 ; If W < bound, next iter
	mov qword [rsp + 24], 0 ; W = 0
	add qword [rsp + 16], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5841 ; If V < bound, next iter
	mov qword [rsp + 16], 0 ; V = 0
	add qword [rsp + 8], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5841 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5841 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5852
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5852:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 280 to rsp 
		mov r10, [r12 - 280 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5853
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5853:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- (t - x)) 
	jno .jump5854
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5854:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump5855
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5855:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump5856: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5857
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5857:
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5858
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5858:
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5859
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5859:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 312 to rsp 
		mov r10, [r12 - 312 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5860
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5860:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by E 
	jno .jump5861
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5861:
	imul rdi, [rsp + 0 + 8] ; multiply by D 
	jno .jump5862
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5862:
	imul rdi, [rsp + 0 + 16] ; multiply by L 
	jno .jump5863
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5863:
	imul rdi, [rsp + 0 + 24] ; multiply by b 
	jno .jump5864
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5864:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump5865: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 64 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'Y'
	add qword [rsp + 24], 1
	; Compare Y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5865 ; If Y < bound, next iter
	mov qword [rsp + 24], 0 ; Y = 0
	add qword [rsp + 16], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5865 ; If X < bound, next iter
	mov qword [rsp + 16], 0 ; X = 0
	add qword [rsp + 8], 1 ; W++
	; Compare W to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5865 ; If W < bound, next iter
	mov qword [rsp + 8], 0 ; W = 0
	add qword [rsp + 0], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5865 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5866
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5866:
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from r12 - 160 to rsp 
		mov r10, [r12 - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5867
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5867:
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5868
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5868:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 320 to rsp 
		mov r10, [r12 - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5869
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5869:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by D 
	jno .jump5870
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5870:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump5871
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5871:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump5872
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5872:
	imul rdi, [rsp + 0 + 24] ; multiply by Q 
	jno .jump5873
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5873:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump5874: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Y'
	add qword [rsp + 24], 1
	; Compare Y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5874 ; If Y < bound, next iter
	mov qword [rsp + 24], 0 ; Y = 0
	add qword [rsp + 16], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5874 ; If X < bound, next iter
	mov qword [rsp + 16], 0 ; X = 0
	add qword [rsp + 8], 1 ; W++
	; Compare W to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5874 ; If W < bound, next iter
	mov qword [rsp + 8], 0 ; W = 0
	add qword [rsp + 0], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5874 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5875
	mov rax, [rel const272] ; 177
	push rax
	jmp .jump5876
.jump5875:
	sub rsp, 8
	; Moving 8 bytes from r12 - 240 to rsp 
		mov r10, [r12 - 240 + 0]
		mov [rsp + 0], r10
.jump5876:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5877
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5877:
	cmp rax, [rsp + 32]
	jl .jump5878
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5878:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5879
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5879:
	cmp rax, [rsp + 40]
	jl .jump5880
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5880:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5881
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5881:
	cmp rax, [rsp + 48]
	jl .jump5882
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5882:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5883
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5883:
	cmp rax, [rsp + 56]
	jl .jump5884
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5884:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5885
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5885:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5886
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5886:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump5887: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'W'
	add qword [rsp + 8], 1
	; Compare W to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5887 ; If W < bound, next iter
	mov qword [rsp + 8], 0 ; W = 0
	add qword [rsp + 0], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5887 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5888
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5888:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 272 to rsp 
		mov r10, [r12 - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5889
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5889:
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5890
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5890:
	; Computing bound for 'W'
	mov rax, [rel const672] ; 322
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5891
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5891:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp 
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5892
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5892:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump5893
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5893:
	imul rdi, [rsp + 0 + 8] ; multiply by 322 
	jno .jump5894
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5894:
	imul rdi, [rsp + 0 + 16] ; multiply by Q 
	jno .jump5895
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5895:
	imul rdi, [rsp + 0 + 24] ; multiply by y 
	jno .jump5896
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5896:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump5897: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 72 to rsp 
		mov r10, [r12 - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'Y'
	add qword [rsp + 24], 1
	; Compare Y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5897 ; If Y < bound, next iter
	mov qword [rsp + 24], 0 ; Y = 0
	add qword [rsp + 16], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5897 ; If X < bound, next iter
	mov qword [rsp + 16], 0 ; X = 0
	add qword [rsp + 8], 1 ; W++
	; Compare W to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5897 ; If W < bound, next iter
	mov qword [rsp + 8], 0 ; W = 0
	add qword [rsp + 0], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5897 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5898
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5898:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5899
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5899:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by L 
	jno .jump5900
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5900:
	imul rdi, [rsp + 0 + 8] ; multiply by t 
	jno .jump5901
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5901:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump5902: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 64 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'W'
	add qword [rsp + 8], 1
	; Compare W to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5902 ; If W < bound, next iter
	mov qword [rsp + 8], 0 ; W = 0
	add qword [rsp + 0], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5902 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump5903
	mov rax, [rel const94] ; False
	push rax
	pop rax
.jump5903:
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rdi
	pop rsi
	call _H
	add rsp, 24
	add rsp, 40
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5904
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5904:
	cmp rax, [rsp + 32]
	jl .jump5905
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5905:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5906
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5906:
	cmp rax, [rsp + 40]
	jl .jump5907
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5907:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5908
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5908:
	cmp rax, [rsp + 48]
	jl .jump5909
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5909:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5910
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5910:
	cmp rax, [rsp + 56]
	jl .jump5911
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5911:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'U'
	add qword [rsp + 8], 1
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5856 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5856 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const94] ; False
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	pop rdi
	pop rsi
	call _H
	add rsp, 24
	add rsp, 40
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5912
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5912:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
imul rdi, [rsp + 0 + 0] ; multiply by H(u, (array[T : (- (t - x)), U : s] (array[V : E, W : D, X : L, Y : b] O)[H((- o), (array[V : L, W : t] O), (array[V : b, W : 322, X : Q, Y : y] d), (M || false)), (Q % (sum[V : y, W : k] b)), i, (array[V : D, W : r, X : h, Y : Q] j)[o, j, L, (if m then 177 else r)]]), (array[T : (- (z / L)), U : s, V : E, W : r] (if B then (array[X : U] d) else (array[X : i] d))[k]), false) 
	jno .jump5913
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5913:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump5914
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5914:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump5915: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'U'
	add qword [rsp + 8], 1
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5915 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5915 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5916
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5916:
	cmp rax, [rsp + 16]
	jl .jump5917
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5917:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5918
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5918:
	cmp rax, [rsp + 24]
	jl .jump5919
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5919:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5830
.jump5829:
	mov rax, [rel const770] ; 70.41
	push rax
.jump5830:
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 88 ; Local variables
	pop rbp
	ret

jpl_main:
_jpl_main:
	push rbp
	mov rbp, rsp
	push r12
	mov r12, rbp ; end of jpl_main prelude
	mov rax, [rel const0] ; 224
	push rax
	mov rax, [rel const1] ; 556
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const2] ; 816
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1:
	; Computing bound for 'c'
	mov rax, [rel const4] ; 418
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2:
	; Computing bound for 'b'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const5] ; 18
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3:
	; Computing bound for 'b'
	mov rax, [rel const6] ; 452
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4:
	; Computing bound for 'a'
	mov rax, [rel const7] ; 620
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump6: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump7
	mov rax, [rel const9] ; 374
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump8
.jump7:
	mov rax, [rel const10] ; 787
	push rax
	mov rax, [rel const11] ; 340
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
.jump8:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump9
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump9:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump10:
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const13] ; 303
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump11
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump11:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump12: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const14] ; 536
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump13
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump13:
	; Computing bound for 'b'
	mov rax, [rel const15] ; 870
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump14
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump14:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump15: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 8], 1
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump15 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump15 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump12 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump16
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump16:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump17: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump17 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump17 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump17 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump17 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump18
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump18:
	; Computing bound for 'b'
	mov rax, [rel const16] ; 225
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump19
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump19:
	; Computing bound for 'a'
	mov rax, [rel const17] ; 252
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump20
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump20:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump21: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump21 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump21 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump21 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump22
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const18] ; 293
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump24
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump24:
	; Computing bound for 'b'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const19] ; 50.32
	push rax
	mov rax, [rel const20] ; 5.83
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump25
	mov rax, [rel const21] ; 500
	push rax
	jmp .jump26
.jump25:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const22] ; 668
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump27
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump27:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump28: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump28 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump26:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump29
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump29:
	; Computing bound for 'c'
	mov rax, [rel const23] ; 341
	push rax
	mov rax, [rel const24] ; 822
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump30
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump30:
	; Computing bound for 'b'
	mov rax, [rel const25] ; 50
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump31
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump31:
	; Computing bound for 'a'
	mov rax, [rel const26] ; 312
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump32
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump32:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 312 
	jno .jump33
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump33:
	imul rdi, [rsp + 0 + 8] ; multiply by 50 
	jno .jump34
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump34:
	imul rdi, [rsp + 0 + 16] ; multiply by (822 * 341) 
	jno .jump35
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump35:
imul rdi, [rsp + 0 + 24] ; multiply by (if (5.83 >= 50.32) then 500 else (sum[a : 668] a)) 
	jno .jump36
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump36:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump37: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump37 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump37 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump37 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump37 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const28] ; 329
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump38
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump38:
	; Computing bound for 'b'
	mov rax, [rel const29] ; 467
	push rax
	mov rax, [rel const30] ; 688
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump39
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump39:
	; Computing bound for 'a'
	mov rax, [rel const31] ; 750
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump40
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump40:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump41: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump42
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump42:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump43
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump43:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump44
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump44:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump45
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump45:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump46: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump46 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump46 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump46 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump46 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump41 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump41 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump41 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const32] ; 103
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump47
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump47:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump48: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const33] ; 219
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump48 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const34] ; 112
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump49
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump49:
	cqo
	idiv r10
	push rax
	mov rax, [rel const36] ; 869
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const37] ; 2
	push rax
	mov rax, [rel const38] ; 612
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump50
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump50:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump51
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump51:
	; Computing bound for 'a'
	mov rax, [rel const39] ; 26
	push rax
	mov rax, [rel const40] ; 163
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump52
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump52:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump53: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump53 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump53 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump54
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump54:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump55: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const41] ; 663
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump55 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const42] ; 846
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump56
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump56:
	; Computing bound for 'c'
	mov rax, [rel const43] ; 619
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump57
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump57:
	; Computing bound for 'b'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const44] ; 665
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump58
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump58:
	; Computing bound for 'b'
	mov rax, [rel const45] ; 384
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump59
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump59:
	; Computing bound for 'a'
	mov rax, [rel const46] ; 277
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump60
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump60:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump61: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump61 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump61 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump61 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump62
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump62:
	; Computing bound for 'a'
	mov rax, [rel const47] ; 650
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump63
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump63:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump64: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump64 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump64 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump64 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump64 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const48] ; 695
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump65
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump65:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump66
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump66:
	cmp rax, [rsp + 32]
	jl .jump67
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump67:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump68
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump68:
	cmp rax, [rsp + 40]
	jl .jump69
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump69:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump70
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump70:
	cmp rax, [rsp + 48]
	jl .jump71
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump71:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump72
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump72:
	cmp rax, [rsp + 56]
	jl .jump73
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump73:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump74
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump74:
	; Computing bound for 'a'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump75
	mov rax, [rel const51] ; 585
	push rax
	jmp .jump76
.jump75:
	mov rax, [rel const52] ; 104
	push rax
.jump76:
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const53] ; 524
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump77
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump77:
	; Computing bound for 'c'
	mov rax, [rel const54] ; 430
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump78
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump78:
	; Computing bound for 'b'
	mov rax, [rel const55] ; 703
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump79
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump79:
	; Computing bound for 'a'
	mov rax, [rel const56] ; 732
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump80
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump80:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump81: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump81 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump81 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump81 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump81 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump82
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump82:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump83
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump83:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump84: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const57] ; 9
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump84 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump84 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump84 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump85
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump85:
	; Computing bound for 'b'
	mov rax, [rel const58] ; 179
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump86
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump86:
	; Computing bound for 'a'
	mov rax, [rel const59] ; 851
	push rax
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump87
	mov rax, [rel const60] ; 319
	push rax
	jmp .jump88
.jump87:
	mov rax, [rel const61] ; 920
	push rax
.jump88:
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump89
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump89:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump90: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump90 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump90 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump90 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump23
.jump22:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const62] ; 365
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump91
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump91:
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const63] ; 220
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump92
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump92:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump93: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const64] ; 54
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump93 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump94
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump94:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump95: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump95 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump95 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const65] ; 774
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump96
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const66] ; 552
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump98
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump98:
	; Computing bound for 'c'
	mov rax, [rel const67] ; 936
	push rax
	mov rax, [rel const68] ; 580
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	mov rax, [rel const69] ; 691
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump99
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump99:
	cmp rax, [rsp + 8]
	jl .jump100
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump100:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump101
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump101:
	; Computing bound for 'b'
	mov rax, [rel const70] ; 34
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump102
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump102:
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const71] ; 216
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump103
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump103:
	; Computing bound for 'a'
	mov rax, [rel const72] ; 333
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump104
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump104:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump105: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const73] ; 539
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump105 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump105 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump106
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump106:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (- (sum[a : (- 333), b : 216] 539)) 
	jno .jump107
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump107:
	imul rdi, [rsp + 0 + 8] ; multiply by 34 
	jno .jump108
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump108:
	imul rdi, [rsp + 0 + 16] ; multiply by [(580 * 936)][691] 
	jno .jump109
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump109:
	imul rdi, [rsp + 0 + 24] ; multiply by 552 
	jno .jump110
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump110:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump111: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump111 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump111 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump111 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump111 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump97
.jump96:
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump112
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const74] ; 565
	push rax
	mov rax, [rel const75] ; 466
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump114
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump114:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump115
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump115:
	; Computing bound for 'c'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const42] ; 846
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump116
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump116:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 846 
	jno .jump117
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump117:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump118: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const16] ; 225
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump118 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const76] ; 596
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump119
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump119:
	cmp rax, [rsp + 8]
	jl .jump120
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump120:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump121
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump121:
	; Computing bound for 'b'
	mov rax, [rel const77] ; 537
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump122
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump122:
	; Computing bound for 'a'
	mov rax, [rel const16] ; 225
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump123
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump123:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 225 
	jno .jump124
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump124:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 537) 
	jno .jump125
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump125:
imul rdi, [rsp + 0 + 16] ; multiply by (array[a : 846] 225)[(- 596)] 
	jno .jump126
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump126:
	imul rdi, [rsp + 0 + 24] ; multiply by (466 % 565) 
	jno .jump127
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump127:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump128: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump128 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump128 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump128 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump128 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump113
.jump112:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const0] ; 224
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump129
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump129:
	; Computing bound for 'c'
	mov rax, [rel const78] ; 820
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump130
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump130:
	; Computing bound for 'b'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump131
	mov rax, [rel const34] ; 112
	push rax
	jmp .jump132
.jump131:
	mov rax, [rel const79] ; 358
	push rax
.jump132:
	mov rax, [rel const80] ; 164
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump133
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump133:
	; Computing bound for 'a'
	mov rax, [rel const81] ; 660
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const82] ; 270
	push rax
	mov rax, [rel const83] ; 146
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump134
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump134:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump135
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump135:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by ((146 % 270) * (- 660)) 
	jno .jump136
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump136:
	imul rdi, [rsp + 0 + 8] ; multiply by (164 - (if true then 112 else 358)) 
	jno .jump137
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump137:
	imul rdi, [rsp + 0 + 16] ; multiply by (- 820) 
	jno .jump138
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump138:
	imul rdi, [rsp + 0 + 24] ; multiply by 224 
	jno .jump139
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump139:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump140: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump140 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump140 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump140 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump140 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump113:
.jump97:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const84] ; 299
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump141
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump141:
	; Computing bound for 'b'
	mov rax, [rel const85] ; 178
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump142
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump142:
	; Computing bound for 'a'
	mov rax, [rel const86] ; 575
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump143
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump143:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 575 
	jno .jump144
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump144:
	imul rdi, [rsp + 0 + 8] ; multiply by 178 
	jno .jump145
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump145:
	imul rdi, [rsp + 0 + 16] ; multiply by 299 
	jno .jump146
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump146:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump147: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump147 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump147 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump147 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const87] ; 259
	push rax
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump148
	mov rax, [rel const88] ; 474
	push rax
	jmp .jump149
.jump148:
	mov rax, [rel const89] ; 337
	push rax
.jump149:
	mov rax, [rel const62] ; 365
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump150
	mov rax, [rel const7] ; 620
	push rax
	jmp .jump151
.jump150:
	mov rax, [rel const90] ; 373
	push rax
.jump151:
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump152
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump154
	mov rax, [rel const51] ; 585
	push rax
	jmp .jump155
.jump154:
	mov rax, [rel const91] ; 696
	push rax
.jump155:
	jmp .jump153
.jump152:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const10] ; 787
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump156
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump156:
	; Computing bound for 'a'
	mov rax, [rel const92] ; 240
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump157
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump157:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump158: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump158 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump158 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
.jump153:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump159
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump159:
	cmp rax, [rsp + 24]
	jl .jump160
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump160:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump161
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump161:
	cmp rax, [rsp + 32]
	jl .jump162
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump162:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump163
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump163:
	cmp rax, [rsp + 40]
	jl .jump164
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump164:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump165
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump165:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump166: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump167
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump167:
	; Computing bound for 'b'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump168
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump168:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump169: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const93] ; 707
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump169 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump170
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump170:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (- (sum[b : a] 707)) 
	jno .jump171
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump171:
	imul rdi, [rsp + 0 + 8] ; multiply by a 
	jno .jump172
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump172:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump173: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'c'
	add qword [rsp + 8], 1
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump173 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump173 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump174
	mov rax, [rel const45] ; 384
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump175
.jump174:
	mov rax, [rel const95] ; 513
	push rax
	pop rax
	neg rax
	push rax
.jump175:
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump176
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump176:
	cmp rax, [rsp + 16]
	jl .jump177
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump177:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump178
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump178:
	cmp rax, [rsp + 24]
	jl .jump179
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump179:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump166 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const96] ; 471
	push rax
	mov rax, [rel const97] ; 280
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump180
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump180:
	; Computing bound for 'c'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump181
	mov rax, [rel const8] ; True
	push rax
	jmp .jump182
.jump181:
	mov rax, [rel const94] ; False
	push rax
.jump182:
	pop rax
	cmp rax, 0
	jne .jump183
	mov rax, [rel const94] ; False
	push rax
	pop rax
.jump183:
	push rax
	pop rax
	cmp rax, 0
	je .jump184
	mov rax, [rel const98] ; 710
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump185
.jump184:
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump186
	mov rax, [rel const99] ; 601
	push rax
	jmp .jump187
.jump186:
	mov rax, [rel const100] ; 469
	push rax
.jump187:
.jump185:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump188
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump188:
	; Computing bound for 'b'
	mov rax, [rel const101] ; 445
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump189
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump189:
	; Computing bound for 'a'
	mov rax, [rel const102] ; 25.63
	push rax
	mov rax, [rel const103] ; 28.62
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump190
	mov rax, [rel const104] ; 725
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump191
.jump190:
	mov rax, [rel const105] ; 221
	push rax
.jump191:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump192
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump192:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump193: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump194
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump194:
	; Computing bound for 'f'
	mov rax, [rel const106] ; 543
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump195
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump195:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump196
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump196:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump197: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump197 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump197 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump197 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump198
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump198:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump199
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump199:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump200
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump200:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump201: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump201 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump201 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump201 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump193 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump193 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump193 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump193 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const1] ; 556
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump202
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const72] ; 333
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump204
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump204:
	; Computing bound for 'b'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const107] ; 168
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump205
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump205:
	; Computing bound for 'c'
	mov rax, [rel const101] ; 445
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump206
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump206:
	; Computing bound for 'b'
	mov rax, [rel const108] ; 508
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump207
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump207:
	; Computing bound for 'a'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump208
	mov rax, [rel const109] ; 669
	push rax
	jmp .jump209
.jump208:
	mov rax, [rel const110] ; 635
	push rax
.jump209:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump210
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump210:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump211: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump211 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump211 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump211 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump211 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump212
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump212:
	; Computing bound for 'a'
	mov rax, [rel const111] ; 296
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump213
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump213:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump214: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump214 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump214 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump214 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump203
.jump202:
	mov rax, [rel const112] ; 550
	push rax
	pop rax
	neg rax
	push rax
.jump203:
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const113] ; 161
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump215
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump215:
	; Computing bound for 'a'
	mov rax, [rel const114] ; 371
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump216
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump216:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 371 
	jno .jump217
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump217:
	imul rdi, [rsp + 0 + 8] ; multiply by 161 
	jno .jump218
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump218:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump219: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump219 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump219 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const115] ; 261
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump220
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump222
	mov rax, [rel const8] ; True
	push rax
	jmp .jump223
.jump222:
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
.jump223:
	pop rax
	cmp rax, 0
	je .jump224
	mov rax, [rel const116] ; 273
	push rax
	jmp .jump225
.jump224:
	mov rax, [rel const117] ; 265
	push rax
	mov rax, [rel const73] ; 539
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rel const118] ; 455
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump226
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump226:
	cqo
	idiv r10
	push rax
.jump225:
	jmp .jump221
.jump220:
	mov rax, [rel const67] ; 936
	push rax
.jump221:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump227
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump227:
	cmp rax, [rsp + 16]
	jl .jump228
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump228:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump229
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump229:
	cmp rax, [rsp + 24]
	jl .jump230
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump230:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump231
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump231:
	cmp rax, [rsp + 32]
	jl .jump232
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump232:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump233
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump233:
	cmp rax, [rsp + 40]
	jl .jump234
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump234:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump235
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump235:
	cmp rax, [rsp + 48]
	jl .jump236
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump236:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump237
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump237:
	cmp rax, [rsp + 56]
	jl .jump238
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump238:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump23:
	mov rax, [rel const39] ; 26
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const119] ; 73.46
	push rax
	mov rax, [rel const120] ; 78.18
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const121] ; 30.27
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump239
	mov rax, [rel const122] ; 154
	push rax
	jmp .jump240
.jump239:
	mov rax, [rel const123] ; 533
	push rax
	mov rax, [rel const124] ; 641
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
.jump240:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const125] ; 504
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump241
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump241:
	; Computing bound for 'a'
	mov rax, [rel const126] ; 28
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump242
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump242:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump243: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const127] ; 654
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump244
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump244:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump243 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump243 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump245
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump245:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump246
	mov rax, [rel const128] ; 438
	push rax
	jmp .jump247
.jump246:
	mov rax, [rel const129] ; 922
	push rax
.jump247:
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump248
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump248:
	; Computing bound for 'b'
	mov rax, [rel const130] ; 297
	push rax
	mov rax, [rel const131] ; 206
	push rax
	mov rax, [rel const132] ; 693
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump249
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump249:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump250
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump250:
	; Computing bound for 'a'
	mov rax, [rel const8] ; True
	push rax
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump251
	mov rax, [rel const8] ; True
	push rax
	jmp .jump252
.jump251:
	mov rax, [rel const94] ; False
	push rax
.jump252:
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump253
	mov rax, [rel const133] ; 262
	push rax
	mov rax, [rel const134] ; 366
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rel const135] ; 468
	push rax
	mov rax, [rel const136] ; 462
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump255
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const137] ; 70.43
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const138] ; 22.24
	push rax
	mov rax, [rel const139] ; 23.53
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump257
	mov rax, [rel const83] ; 146
	push rax
	jmp .jump258
.jump257:
	mov rax, [rel const140] ; 871
	push rax
	mov rax, [rel const141] ; 398
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rel const142] ; 72
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
.jump258:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump259
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump259:
	; Computing bound for 'b'
	mov rax, [rel const143] ; 172
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump260
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump260:
	; Computing bound for 'a'
	mov rax, [rel const144] ; 646
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump261
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump261:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump262: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump263
	mov rax, [rel const142] ; 72
	push rax
	jmp .jump264
.jump263:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const18] ; 293
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump265
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump265:
	; Computing bound for 'd'
	mov rax, [rel const145] ; 835
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump266
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump266:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump267: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump267 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump267 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump264:
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump262 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump262 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump262 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump256
.jump255:
	mov rax, [rel const146] ; 92
	push rax
	pop rax
	neg rax
	push rax
.jump256:
	jmp .jump254
.jump253:
	mov rax, [rel const147] ; 574
	push rax
.jump254:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump268
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump268:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump269: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const71] ; 216
	push rax
	mov rax, [rel const148] ; 349
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump270
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	jmp .jump271
.jump270:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const149] ; 268
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump272
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump272:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump273
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump273:
	; Computing bound for 'd'
	mov rax, [rel const150] ; 301
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump274
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump274:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 301 
	jno .jump275
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump275:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump276
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump276:
	imul rdi, [rsp + 0 + 16] ; multiply by 268 
	jno .jump277
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump277:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump278: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump278 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump278 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump278 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump279
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump279:
	; Computing bound for 'f'
	mov rax, [rel const151] ; 766
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump280
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump280:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump281
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump281:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump282
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump282:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump283: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump283 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump283 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump283 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump283 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump284
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump284:
	cmp rax, [rsp + 24]
	jl .jump285
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump285:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump286
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump286:
	cmp rax, [rsp + 32]
	jl .jump287
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump287:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump288
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump288:
	cmp rax, [rsp + 40]
	jl .jump289
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump289:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump271:
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump269 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump269 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump269 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump290
	mov rax, [rel const94] ; False
	push rax
	pop rax
.jump290:
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump291
	mov rax, [rel const152] ; 64.25
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump292
.jump291:
	mov rax, [rel const153] ; 36.98
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump292:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const154] ; 741
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump293
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump293:
	; Computing bound for 'b'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const155] ; 336
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump294
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump294:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump295: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump295 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump296
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump296:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[b : 336] b) 
	jno .jump297
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump297:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 741) 
	jno .jump298
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump298:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump299: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const156] ; 21.68
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'c'
	add qword [rsp + 8], 1
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump299 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump299 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const157] ; 151
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump300
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump300:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump301: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump301 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const158] ; 907
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump302
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump302:
	; Computing bound for 'b'
	mov rax, [rel const159] ; 248
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump303
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump303:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 248 
	jno .jump304
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump304:
	imul rdi, [rsp + 0 + 8] ; multiply by 907 
	jno .jump305
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump305:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump306: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const160] ; 889
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'c'
	add qword [rsp + 8], 1
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump306 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump306 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const109] ; 669
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const161] ; 123
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump307
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump307:
	cmp rax, [rsp + 16]
	jl .jump308
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump308:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump309
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump309:
	cmp rax, [rsp + 24]
	jl .jump310
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump310:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump311
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump311:
	cmp rax, [rsp + 16]
	jl .jump312
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump312:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump313
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump313:
	cmp rax, [rsp + 24]
	jl .jump314
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump314:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump315
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const162] ; 986
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump317
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump317:
	; Computing bound for 'b'
	mov rax, [rel const163] ; 839
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump318
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump318:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 839 
	jno .jump319
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump319:
	imul rdi, [rsp + 0 + 8] ; multiply by 986 
	jno .jump320
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump320:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump321: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump322
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump322:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'c'
	add qword [rsp + 8], 1
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump321 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump321 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const164] ; 83
	push rax
	mov rax, [rel const165] ; 811
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump323
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump323:
	cmp rax, [rsp + 16]
	jl .jump324
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump324:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump325
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump325:
	cmp rax, [rsp + 24]
	jl .jump326
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump326:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump327
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump327:
	; Computing bound for 'c'
	mov rax, [rel const166] ; 735
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump328
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump328:
	; Computing bound for 'b'
	mov rax, [rel const124] ; 641
	push rax
	mov rax, [rel const167] ; 608
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump329
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump329:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump330
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump330:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump331: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 16], 1
	; Compare d to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump331 ; If d < bound, next iter
	mov qword [rsp + 16], 0 ; d = 0
	add qword [rsp + 8], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump331 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump331 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump332
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump332:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump333: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump334
	mov rax, [rel const168] ; 71.09
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const169] ; 910
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump336
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump336:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump337
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump337:
	; Computing bound for 'c'
	mov rax, [rel const73] ; 539
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump338
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump338:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump339: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const170] ; 21.76
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'e'
	add qword [rsp + 16], 1
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump339 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump339 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump339 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump340
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump342
	mov rax, [rel const171] ; 376
	push rax
	jmp .jump343
.jump342:
	mov rax, [rel const172] ; 578
	push rax
.jump343:
	jmp .jump341
.jump340:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump341:
	jmp .jump335
.jump334:
	mov rax, [rel const173] ; 655
	push rax
.jump335:
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump333 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump316
.jump315:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const174] ; 849
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump344
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump344:
	; Computing bound for 'b'
	mov rax, [rel const175] ; 175
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump345
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump345:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump346: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 8], 1
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump346 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump346 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump347
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump347:
	; Computing bound for 'd'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const176] ; 403
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump348
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump348:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump349: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump349 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump350
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump350:
	; Computing bound for 'c'
	mov rax, [rel const177] ; 573
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump351
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump351:
	; Computing bound for 'b'
	mov rax, [rel const178] ; 614
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump352
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump352:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by 614 
	jno .jump353
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump353:
	imul rdi, [rsp + 0 + 8] ; multiply by 573 
	jno .jump354
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump354:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[b : 403] b) 
	jno .jump355
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump355:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump356: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump357
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump357:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump358
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump358:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump359: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump359 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'd'
	add qword [rsp + 16], 1
	; Compare d to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump356 ; If d < bound, next iter
	mov qword [rsp + 16], 0 ; d = 0
	add qword [rsp + 8], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump356 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump356 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump360
	mov rax, [rel const151] ; 766
	push rax
	jmp .jump361
.jump360:
	mov rax, [rel const179] ; 895
	push rax
.jump361:
	mov rax, [rel const180] ; 485
	push rax
	mov rax, [rel const181] ; 929
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const182] ; 719
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump362
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump362:
	cmp rax, [rsp + 24]
	jl .jump363
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump363:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump364
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump364:
	cmp rax, [rsp + 32]
	jl .jump365
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump365:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump366
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump366:
	cmp rax, [rsp + 40]
	jl .jump367
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump367:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump368
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const82] ; 270
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump370
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump370:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump371: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const183] ; 600
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump371 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump369
.jump368:
	mov rax, [rel const184] ; 147
	push rax
.jump369:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump372
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump372:
	cmp rax, [rsp + 8]
	jl .jump373
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump373:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump374
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump374:
	; Computing bound for 'c'
	mov rax, [rel const185] ; 227
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump375
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump375:
	; Computing bound for 'b'
	mov rax, [rel const67] ; 936
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const186] ; 714
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump376
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump376:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump377: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 24], 1
	; Compare e to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump377 ; If e < bound, next iter
	mov qword [rsp + 24], 0 ; e = 0
	add qword [rsp + 16], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump377 ; If d < bound, next iter
	mov qword [rsp + 16], 0 ; d = 0
	add qword [rsp + 8], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump377 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump377 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
.jump316:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump378
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump378:
	; Computing bound for 'd'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const149] ; 268
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump379
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump379:
	; Computing bound for 'c'
	mov rax, [rel const187] ; 389
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump380
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump380:
	; Computing bound for 'b'
	mov rax, [rel const51] ; 585
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump381
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump381:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 585 
	jno .jump382
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump382:
	imul rdi, [rsp + 0 + 8] ; multiply by 389 
	jno .jump383
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump383:
	imul rdi, [rsp + 0 + 16] ; multiply by 268 
	jno .jump384
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump384:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump385: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump386
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump386:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump387
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump387:
	; Computing bound for 'f'
	mov rax, [rel const188] ; 535
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump388
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump388:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump389
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump389:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump390
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump390:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (b / b) 
	jno .jump391
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump391:
	imul rdi, [rsp + 0 + 8] ; multiply by 535 
	jno .jump392
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump392:
	imul rdi, [rsp + 0 + 16] ; multiply by c 
	jno .jump393
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump393:
	imul rdi, [rsp + 0 + 24] ; multiply by c 
	jno .jump394
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump394:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump395: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump395 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump395 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump395 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump395 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'd'
	add qword [rsp + 16], 1
	; Compare d to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump385 ; If d < bound, next iter
	mov qword [rsp + 16], 0 ; d = 0
	add qword [rsp + 8], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump385 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump385 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const189] ; 742
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump396
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump396:
	cmp rax, [rsp + 8]
	jl .jump397
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump397:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump398
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump398:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump399: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const190] ; 448
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump399 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rel const191] ; 283
	push rax
	mov rax, [rel const192] ; 642
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump400
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump400:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const193] ; 446
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const194] ; 51
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump401
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump401:
	cqo
	idiv r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump402
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump402:
	cmp rax, [rsp + 24]
	jl .jump403
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump403:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump404
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump404:
	cmp rax, [rsp + 32]
	jl .jump405
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump405:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump406
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump406:
	cmp rax, [rsp + 40]
	jl .jump407
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump407:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const195] ; 122
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump408
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump408:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump409: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump409 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const196] ; 963
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump410
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump410:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump411: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump411 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const197] ; 548
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump412
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump412:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump413: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump413 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump414
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump414:
	; Computing bound for 'b'
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const4] ; 418
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump415
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump415:
	cmp rax, [rsp + 8]
	jl .jump416
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump416:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const198] ; 783
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump417
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump417:
	cmp rax, [rsp + 8]
	jl .jump418
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump418:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump419
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump419:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump420
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump420:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (a[783] % a[418]) 
	jno .jump421
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump421:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[b : 548] b) 
	jno .jump422
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump422:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump423: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump424
	mov rax, [rel const199] ; 82
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump425
.jump424:
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
.jump425:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'c'
	add qword [rsp + 8], 1
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump423 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump423 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const178] ; 614
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump426
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump426:
	cmp rax, [rsp + 8]
	jl .jump427
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump427:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump428
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump428:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump429: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const200] ; 363
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump429 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const201] ; 727
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const202] ; 724
	push rax
	mov rax, [rel const45] ; 384
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump430
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump430:
	cmp rax, [rsp + 16]
	jl .jump431
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump431:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump432
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump432:
	cmp rax, [rsp + 24]
	jl .jump433
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump433:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const161] ; 123
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump434
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump434:
	cmp rax, [rsp + 32]
	jl .jump435
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump435:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump436
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump436:
	cmp rax, [rsp + 40]
	jl .jump437
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump437:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump438
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump438:
	cmp rax, [rsp + 48]
	jl .jump439
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump439:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump440
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump440:
	cmp rax, [rsp + 56]
	jl .jump441
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump441:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const203] ; 863
	push rax
	mov rax, [rel const204] ; 439
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump442
	mov rax, [rel const205] ; 479
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump443
.jump442:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const206] ; 411
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump444
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump444:
	; Computing bound for 'b'
	mov rax, [rel const60] ; 319
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump445
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump445:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 319 
	jno .jump446
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump446:
	imul rdi, [rsp + 0 + 8] ; multiply by 411 
	jno .jump447
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump447:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump448: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'c'
	add qword [rsp + 8], 1
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump448 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump448 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const207] ; 845
	push rax
	mov rax, [rel const208] ; 324
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump449
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump449:
	cmp rax, [rsp + 16]
	jl .jump450
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump450:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump451
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump451:
	cmp rax, [rsp + 24]
	jl .jump452
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump452:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump443:
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump453
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump453:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump454: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump455
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump455:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump456
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump456:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const99] ; 601
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump457
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump457:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump458
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump458:
	; Computing bound for 'c'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const209] ; 530
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump459
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump459:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump460
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump460:
	; Computing bound for 'c'
	mov rax, [rel const210] ; 498
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump461
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump461:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 498 
	jno .jump462
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump462:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump463
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump463:
	imul rdi, [rsp + 0 + 16] ; multiply by 530 
	jno .jump464
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump464:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump465: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 16], 1
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump465 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump465 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump465 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump466
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump466:
	cmp rax, [rsp + 24]
	jl .jump467
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump467:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump468
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump468:
	cmp rax, [rsp + 32]
	jl .jump469
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump469:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump470
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump470:
	cmp rax, [rsp + 40]
	jl .jump471
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump471:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump472
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump472:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (array[c : 498, d : b, e : 530] c)[b, b, b] 
	jno .jump473
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump473:
	imul rdi, [rsp + 0 + 8] ; multiply by (601 % b) 
	jno .jump474
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump474:
	imul rdi, [rsp + 0 + 16] ; multiply by (- b) 
	jno .jump475
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump475:
	imul rdi, [rsp + 0 + 24] ; multiply by (- b) 
	jno .jump476
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump476:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump477: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump478
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump478:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump479: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump479 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 24], 1
	; Compare f to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump477 ; If f < bound, next iter
	mov qword [rsp + 24], 0 ; f = 0
	add qword [rsp + 16], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump477 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump477 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump477 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump480
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	jmp .jump481
.jump480:
	mov rax, [rel const211] ; 271
	push rax
	mov rax, [rel const212] ; 105
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
.jump481:
	pop rax
	cmp rax, 0
	je .jump482
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump483
.jump482:
	mov rax, [rel const213] ; 763
	push rax
.jump483:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const214] ; 330
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump484
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump484:
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump485
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump485:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump486: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 8], 1
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump486 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump486 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const215] ; 582
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump487
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump487:
	cqo
	idiv r10
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump488
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump488:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump489
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump489:
	; Computing bound for 'd'
	mov rax, [rel const216] ; 318
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump490
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump490:
	; Computing bound for 'c'
	mov rax, [rel const217] ; 830
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump491
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump491:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump492: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 24], 1
	; Compare f to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump492 ; If f < bound, next iter
	mov qword [rsp + 24], 0 ; f = 0
	add qword [rsp + 16], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump492 ; If e < bound, next iter
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump492 ; If d < bound, next iter
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump492 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump493
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump493:
	cmp rax, [rsp + 32]
	jl .jump494
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump494:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump495
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump495:
	cmp rax, [rsp + 40]
	jl .jump496
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump496:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump497
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump497:
	cmp rax, [rsp + 48]
	jl .jump498
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump498:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump499
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump499:
	cmp rax, [rsp + 56]
	jl .jump500
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump500:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump454 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump501
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump501:
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const111] ; 296
	push rax
	mov rax, [rel const123] ; 533
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump502
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump502:
	cmp rax, [rsp + 8]
	jl .jump503
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump503:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump504
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump504:
	; Computing bound for 'b'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump505
	mov rax, [rel const218] ; 425
	push rax
	jmp .jump506
.jump505:
	mov rax, [rel const219] ; 56.77
	push rax
	mov rax, [rel const220] ; 77.66
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const221] ; 30.23
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump507
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const222] ; 291
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump509
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump509:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump510: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const223] ; 184
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump510 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump508
.jump507:
	mov rax, [rel const224] ; 305
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
.jump508:
.jump506:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump511
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump511:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump512: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const188] ; 535
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump513
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump513:
	; Computing bound for 'e'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump514
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const225] ; 294
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump516
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump516:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump517
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump517:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump518
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump518:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump519: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump519 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump519 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump519 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump520
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump520:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	jmp .jump515
.jump514:
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
.jump515:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump521
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump521:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump522
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump522:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump523
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump523:
imul rdi, [rsp + 0 + 8] ; multiply by (if false then (b % (sum[d : c, e : b, f : 294] c)) else b) 
	jno .jump524
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump524:
	imul rdi, [rsp + 0 + 16] ; multiply by (- (- 535)) 
	jno .jump525
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump525:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump526: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump526 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump526 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump526 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump527
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const133] ; 262
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump529
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump529:
	; Computing bound for 'd'
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump530
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump530:
	cmp rax, [rsp + 8]
	jl .jump531
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump531:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump532
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump532:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by a[b] 
	jno .jump533
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump533:
	imul rdi, [rsp + 0 + 8] ; multiply by 262 
	jno .jump534
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump534:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump535: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump535 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump535 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump528
.jump527:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump536
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump536:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump537
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump537:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- b) 
	jno .jump538
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump538:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump539
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump539:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump540: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump540 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump540 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump528:
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const226] ; 38
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump541
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump541:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump542
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump542:
	cmp rax, [rsp + 16]
	jl .jump543
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump543:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump544
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump544:
	cmp rax, [rsp + 24]
	jl .jump545
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump545:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump546
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump546:
	cmp rax, [rsp + 8]
	jl .jump547
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump547:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump548
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump548:
	cmp rax, [rsp + 24]
	jl .jump549
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump549:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump550
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump550:
	cmp rax, [rsp + 32]
	jl .jump551
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump551:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump552
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump552:
	cmp rax, [rsp + 40]
	jl .jump553
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump553:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 8], 1
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump512 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump512 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump554
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump554:
	; Computing bound for 'b'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const227] ; 645
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump555
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump555:
	; Computing bound for 'd'
	mov rax, [rel const228] ; 812
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump556
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump556:
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const159] ; 248
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump557
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump557:
	; Computing bound for 'b'
	mov rax, [rel const229] ; 549
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump558
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump558:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump559: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 8], 1
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump559 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump559 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump560
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump560:
	; Computing bound for 'b'
	mov rax, [rel const169] ; 910
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump561
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump561:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump562: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 24], 1
	; Compare e to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump562 ; If e < bound, next iter
	mov qword [rsp + 24], 0 ; e = 0
	add qword [rsp + 16], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump562 ; If d < bound, next iter
	mov qword [rsp + 16], 0 ; d = 0
	add qword [rsp + 8], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump562 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump562 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const230] ; 991
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rel const116] ; 273
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump563
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump564
	mov rax, [rel const94] ; False
	push rax
	jmp .jump565
.jump564:
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
.jump565:
	pop rax
.jump563:
	push rax
	pop rax
	cmp rax, 0
	je .jump566
	mov rax, [rel const78] ; 820
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump567
.jump566:
	mov rax, [rel const231] ; 649
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const232] ; 209
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump568
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump568:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rel const233] ; 711
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
.jump567:
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump569
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump569:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump570: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump571
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const234] ; 972
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump573
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump573:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump574
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump574:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- c) 
	jno .jump575
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump575:
	imul rdi, [rsp + 0 + 8] ; multiply by (b + (972 - c)) 
	jno .jump576
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump576:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump577: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump577 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump577 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump572
.jump571:
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump578
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump578:
	cqo
	idiv r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump579
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump579:
	cqo
	idiv r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump580
	mov rax, [rel const235] ; 24.45
	push rax
	sub rsp, 8 ; Add alignment
	mov rax, [rel const236] ; 4.64
	push rax
	mov rax, [rel const237] ; 58.4
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump582
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump584
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump584:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump585
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump585:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump586
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump586:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump587
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump587:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump588: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump588 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump588 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump583
.jump582:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump589
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump589:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump590
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump590:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (b * d) 
	jno .jump591
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump591:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump592
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump592:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump593: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump593 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump593 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump583:
	jmp .jump581
.jump580:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump594
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump594:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump595
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump595:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump596: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const238] ; 674
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump597
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump597:
	; Computing bound for 'g'
	mov rax, [rel const239] ; 391
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump598
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump598:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 391 
	jno .jump599
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump599:
	imul rdi, [rsp + 0 + 8] ; multiply by 674 
	jno .jump600
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump600:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump601: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump601 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump601 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump596 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const240] ; 417
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump602
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump602:
	cmp rax, [rsp + 8]
	jl .jump603
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump603:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump581:
.jump572:
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump604
	mov rax, [rel const8] ; True
	push rax
	pop rax
.jump604:
	push rax
	pop rax
	cmp rax, 0
	je .jump605
	mov rax, [rel const241] ; 9.97
	push rax
	mov rax, [rel const242] ; 12.1
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	jmp .jump606
.jump605:
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump607
	mov rax, [rel const94] ; False
	push rax
	jmp .jump608
.jump607:
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump609
	mov rax, [rel const8] ; True
	push rax
	pop rax
.jump609:
	push rax
.jump608:
.jump606:
	pop rax
	cmp rax, 0
	je .jump610
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const163] ; 839
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump612
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump612:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump613
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump613:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump614
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump614:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump615: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump615 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump615 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump615 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump616
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump616:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump617
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump617:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump618
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump618:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump619
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump619:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump620: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump620 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump620 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump621
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump621:
	; Computing bound for 'f'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump622
	mov rax, [rel const94] ; False
	push rax
	jmp .jump623
.jump622:
	mov rax, [rel const94] ; False
	push rax
.jump623:
	pop rax
	cmp rax, 0
	je .jump624
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump626
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump626:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump627
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump627:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump628
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump628:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump629
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump629:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump630
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump630:
	imul rdi, [rsp + 0 + 16] ; multiply by c 
	jno .jump631
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump631:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump632: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump632 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump632 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump632 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump625
.jump624:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump633
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump633:
	; Computing bound for 'g'
	mov rax, [rel const243] ; 708
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump634
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump634:
	; Computing bound for 'f'
	mov rax, [rel const244] ; 189
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump635
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump635:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 189 
	jno .jump636
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump636:
	imul rdi, [rsp + 0 + 8] ; multiply by 708 
	jno .jump637
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump637:
	imul rdi, [rsp + 0 + 16] ; multiply by d 
	jno .jump638
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump638:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump639: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump639 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump639 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump639 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump625:
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump640
	mov rax, [rel const245] ; 825
	push rax
	jmp .jump641
.jump640:
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
.jump641:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump642
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump642:
	; Computing bound for 'h'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump643
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	jmp .jump644
.jump643:
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
.jump644:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump645
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump645:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump646
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump646:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump647
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump647:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump648: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump648 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump648 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump648 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump648 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const246] ; 231
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump649
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump649:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump650
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump650:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump651: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump651 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump652
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump652:
	cmp rax, [rsp + 24]
	jl .jump653
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump653:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump654
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump654:
	cmp rax, [rsp + 32]
	jl .jump655
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump655:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump656
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump656:
	cmp rax, [rsp + 40]
	jl .jump657
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump657:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump658
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump658:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump659: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump659 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump659 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump659 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump659 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	jmp .jump611
.jump610:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump660
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump660:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump661: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump661 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump611:
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump662
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump662:
	cmp rax, [rsp + 16]
	jl .jump663
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump663:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump664
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump664:
	cmp rax, [rsp + 24]
	jl .jump665
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump665:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 24], 1
	; Compare e to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump570 ; If e < bound, next iter
	mov qword [rsp + 24], 0 ; e = 0
	add qword [rsp + 16], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump570 ; If d < bound, next iter
	mov qword [rsp + 16], 0 ; d = 0
	add qword [rsp + 8], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump570 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump570 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump666
	mov rax, [rel const8] ; True
	push rax
	pop rax
.jump666:
	push rax
	pop rax
	cmp rax, 0
	je .jump667
	mov rax, [rel const8] ; True
	push rax
	mov rax, [rel const247] ; 850
	push rax
	mov rax, [rel const248] ; 867
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
.jump667:
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump668
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump670
	mov rax, [rel const249] ; 50.5
	push rax
	mov rax, [rel const250] ; 96.3
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump671
.jump670:
	mov rax, [rel const251] ; 35.77
	push rax
.jump671:
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump669
.jump668:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const252] ; 659
	push rax
	mov rax, [rel const56] ; 732
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump672
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump672:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump673
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump673:
	; Computing bound for 'c'
	mov rax, [rel const253] ; 440
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump674
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump674:
	; Computing bound for 'b'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const254] ; 962
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump675
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump675:
	; Computing bound for 'c'
	mov rax, [rel const255] ; 364
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump676
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump676:
	; Computing bound for 'b'
	mov rax, [rel const256] ; 276
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump677
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump677:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 276 
	jno .jump678
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump678:
	imul rdi, [rsp + 0 + 8] ; multiply by 364 
	jno .jump679
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump679:
	imul rdi, [rsp + 0 + 16] ; multiply by 962 
	jno .jump680
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump680:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump681: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 16], 1
	; Compare d to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump681 ; If d < bound, next iter
	mov qword [rsp + 16], 0 ; d = 0
	add qword [rsp + 8], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump681 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump681 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const257] ; 362
	push rax
	mov rax, [rel const105] ; 221
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const258] ; 453
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump682
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump682:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump683: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const259] ; 281
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump683 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump684
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump684:
	cmp rax, [rsp + 24]
	jl .jump685
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump685:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump686
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump686:
	cmp rax, [rsp + 32]
	jl .jump687
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump687:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump688
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump688:
	cmp rax, [rsp + 40]
	jl .jump689
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump689:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump690
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump690:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump691: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump692
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump692:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump693
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump693:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by (- c) 
	jno .jump694
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump694:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump695
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump695:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump696: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const260] ; 91.82
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump696 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump696 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump697
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump697:
	cmp rax, [rsp + 16]
	jl .jump698
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump698:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump699
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump699:
	cmp rax, [rsp + 24]
	jl .jump700
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump700:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'd'
	add qword [rsp + 16], 1
	; Compare d to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump691 ; If d < bound, next iter
	mov qword [rsp + 16], 0 ; d = 0
	add qword [rsp + 8], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump691 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump691 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump669:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const174] ; 849
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump701
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump701:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump702: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump702 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump703
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump703:
	; Computing bound for 'c'
	mov rax, [rel const261] ; 966
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump704
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump704:
	; Computing bound for 'b'
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const262] ; 47
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump705
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump705:
	cmp rax, [rsp + 8]
	jl .jump706
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump706:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump707
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump707:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof float[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by a[47] 
	jno .jump708
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump708:
	imul rdi, [rsp + 0 + 8] ; multiply by 966 
	jno .jump709
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump709:
imul rdi, [rsp + 0 + 16] ; multiply by (- (sum[b : 849] b)) 
	jno .jump710
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump710:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump711: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const263] ; 344
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump712
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump712:
	; Computing bound for 'g'
	mov rax, [rel const232] ; 209
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump713
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump713:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump714
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump714:
	; Computing bound for 'e'
	mov rax, [rel const264] ; 634
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump715
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump715:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by 634 
	jno .jump716
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump716:
	imul rdi, [rsp + 0 + 8] ; multiply by d 
	jno .jump717
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump717:
	imul rdi, [rsp + 0 + 16] ; multiply by 209 
	jno .jump718
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump718:
	imul rdi, [rsp + 0 + 24] ; multiply by (344 * c) 
	jno .jump719
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump719:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump720: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const265] ; 30.02
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump720 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump720 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump720 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump720 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'd'
	add qword [rsp + 16], 1
	; Compare d to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump711 ; If d < bound, next iter
	mov qword [rsp + 16], 0 ; d = 0
	add qword [rsp + 8], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump711 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump711 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const266] ; 594
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const267] ; 561
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump721
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump721:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump722: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump723
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump723:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump724
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump724:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
.jump725: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'c'
	add qword [rsp + 0], 1
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump725 ; If c < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump726
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump726:
	cmp rax, [rsp + 8]
	jl .jump727
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump727:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump722 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const268] ; 952
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump728
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump728:
	; Computing bound for 'c'
	mov rax, [rel const34] ; 112
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump729
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump729:
	; Computing bound for 'b'
	mov rax, [rel const1] ; 556
	push rax
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const5] ; 18
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump730
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump730:
	cmp rax, [rsp + 8]
	jl .jump731
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump731:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump732
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump732:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump733
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump733:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump734: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump735
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump735:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump736
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump736:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump737: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump737 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump737 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump738
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump738:
	cqo
	idiv r10
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 16], 1
	; Compare d to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump734 ; If d < bound, next iter
	mov qword [rsp + 16], 0 ; d = 0
	add qword [rsp + 8], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump734 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump734 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump739
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump739:
	cmp rax, [rsp + 24]
	jl .jump740
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump740:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump741
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump741:
	cmp rax, [rsp + 32]
	jl .jump742
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump742:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump743
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump743:
	cmp rax, [rsp + 40]
	jl .jump744
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump744:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump745
	mov rax, [rel const8] ; True
	push rax
	pop rax
.jump745:
	push rax
	pop rax
	cmp rax, 0
	je .jump746
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const269] ; 472
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump748
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump748:
	cmp rax, [rsp + 8]
	jl .jump749
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump749:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump747
.jump746:
	mov rax, [rel const270] ; 821
	push rax
.jump747:
	pop rax
	neg rax
	push rax
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump750
	mov rax, [rel const94] ; False
	push rax
	pop rax
.jump750:
	push rax
	pop rax
	xor rax, 1
	push rax
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump751
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const80] ; 164
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump753
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump753:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump754: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const271] ; 840
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump754 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump752
.jump751:
	mov rax, [rel const272] ; 177
	push rax
.jump752:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const273] ; 286
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump755
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump755:
	; Computing bound for 'b'
	mov rax, [rel const274] ; 737
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump756
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump756:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 737 
	jno .jump757
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump757:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 286) 
	jno .jump758
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump758:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump759: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'c'
	add qword [rsp + 8], 1
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump759 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump759 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump760
	mov rax, [rel const275] ; 553
	push rax
	jmp .jump761
.jump760:
	mov rax, [rel const276] ; 576
	push rax
.jump761:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const277] ; 436
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump762
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump762:
	; Computing bound for 'b'
	mov rax, [rel const61] ; 920
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump763
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump763:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump764: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 8], 1
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump764 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump764 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const278] ; 68
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const279] ; 378
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump765
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump765:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump766: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const280] ; 326
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump766 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump767
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump767:
	cmp rax, [rsp + 16]
	jl .jump768
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump768:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump769
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump769:
	cmp rax, [rsp + 24]
	jl .jump770
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump770:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const281] ; 6
	push rax
	mov rax, [rel const61] ; 920
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump771
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump772
.jump771:
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 1
	push rax
	mov rax, [rel const282] ; 61
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump773
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump773:
	cmp rax, [rsp + 8]
	jl .jump774
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump774:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump772:
	mov rax, [rel const283] ; 174
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump775
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump775:
	cmp rax, [rsp + 8]
	jl .jump776
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump776:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump777
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump777:
	cmp rax, [rsp + 32]
	jl .jump778
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump778:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump779
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump779:
	cmp rax, [rsp + 40]
	jl .jump780
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump780:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump781
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump781:
	cmp rax, [rsp + 48]
	jl .jump782
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump782:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump783
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump783:
	cmp rax, [rsp + 56]
	jl .jump784
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump784:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump785
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump787
	mov rax, [rel const284] ; 46
	push rax
	jmp .jump788
.jump787:
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump789
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump791
	mov rax, [rel const285] ; 57.24
	push rax
	mov rax, [rel const286] ; 74.32
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
.jump791:
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump790
.jump789:
	mov rax, [rel const287] ; 81.57
	push rax
	mov rax, [rel const288] ; 44.57
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump792
	mov rax, [rel const289] ; 180
	push rax
	mov rax, [rel const232] ; 209
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump794
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump796
	mov rax, [rel const8] ; True
	push rax
	jmp .jump797
.jump796:
	mov rax, [rel const8] ; True
	push rax
.jump797:
	jmp .jump795
.jump794:
	mov rax, [rel const290] ; 804
	push rax
	mov rax, [rel const123] ; 533
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
.jump795:
	jmp .jump793
.jump792:
	mov rax, [rel const94] ; False
	push rax
.jump793:
.jump790:
	pop rax
	cmp rax, 0
	je .jump798
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const291] ; 44
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump800
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump800:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 44) 
	jno .jump801
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump801:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump802: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'b'
	add qword [rsp + 0], 1
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump802 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const292] ; 23
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump803
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump803:
	; Computing bound for 'b'
	mov rax, [rel const293] ; 432
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump804
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump804:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump805: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 8], 1
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump805 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump805 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump806
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump806:
	cmp rax, [rsp + 8]
	jl .jump807
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump807:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump799
.jump798:
	mov rax, [rel const294] ; 264
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const295] ; 426
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const296] ; 883
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump808
	mov rax, [rel const297] ; 70
	push rax
	jmp .jump809
.jump808:
	mov rax, [rel const203] ; 863
	push rax
.jump809:
.jump799:
.jump788:
	jmp .jump786
.jump785:
	mov rax, [rel const298] ; 876
	push rax
.jump786:
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rel const299] ; 71.51
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump810
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const113] ; 161
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump812
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump812:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump813
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump813:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump814
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump814:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump815: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump815 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump815 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump815 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump811
.jump810:
	mov rax, [rel const272] ; 177
	push rax
	pop rax
	neg rax
	push rax
.jump811:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump816
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump816:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const300] ; 778
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump817
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump817:
	cmp rax, [rsp + 8]
	jl .jump818
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump818:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump819
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump819:
	; Computing bound for 'd'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump820
	mov rax, [rel const8] ; True
	push rax
	pop rax
.jump820:
	push rax
	pop rax
	cmp rax, 0
	je .jump821
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const301] ; 186
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump823
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump823:
	; Computing bound for 'e'
	mov rax, [rel const227] ; 645
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump824
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump824:
	; Computing bound for 'd'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump825
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump825:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump826: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const109] ; 669
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump826 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump827
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump827:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump828: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump828 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump828 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump828 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump822
.jump821:
	mov rax, [rel const302] ; 19
	push rax
.jump822:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump829
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump829:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump830: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump830 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump830 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump830 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump831
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump831:
	; Computing bound for 'e'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const303] ; 666
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump832
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump832:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump833: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump834
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump835
.jump834:
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
.jump835:
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump833 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump836
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump836:
	; Computing bound for 'd'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump837
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump838
.jump837:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump838:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump839
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump839:
	; Computing bound for 'f'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump840
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump841
.jump840:
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump842
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump843
.jump842:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump843:
.jump841:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump844
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump844:
	; Computing bound for 'e'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump845
	mov rax, [rel const159] ; 248
	push rax
	jmp .jump846
.jump845:
	mov rax, [rel const304] ; 940
	push rax
.jump846:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump847
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump847:
	; Computing bound for 'd'
	mov rax, [rel const305] ; 584
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump848
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump848:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 584 
	jno .jump849
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump849:
	imul rdi, [rsp + 0 + 8] ; multiply by (if true then 248 else 940) 
	jno .jump850
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump850:
	imul rdi, [rsp + 0 + 16] ; multiply by (if true then b else (if true then b else b)) 
	jno .jump851
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump851:
	imul rdi, [rsp + 0 + 24] ; multiply by (if (! false) then b else b) 
	jno .jump852
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump852:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump853: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump854
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump854:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump855: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump855 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump856
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump856:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump857: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const211] ; 271
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump858
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump858:
	cqo
	idiv r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump857 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump853 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump853 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump853 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump853 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const306] ; 887
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump859
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump859:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump860: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const224] ; 305
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump861
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump861:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump860 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump862
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump862:
	; Computing bound for 'e'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const307] ; 59
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump863
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump863:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 59 
	jno .jump864
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump864:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump865: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump865 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump866
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump866:
	cmp rax, [rsp + 8]
	jl .jump867
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump867:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump868
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump868:
	; Computing bound for 'd'
	mov rax, [rel const30] ; 688
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump869
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump869:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump870: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump871
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump871:
	cmp rax, [rsp + 8]
	jl .jump872
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump872:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump873
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump873:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump870 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump870 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump870 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const308] ; 52
	push rax
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump874
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump875
.jump874:
	mov rax, [rel const95] ; 513
	push rax
.jump875:
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump876
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump876:
	cmp rax, [rsp + 32]
	jl .jump877
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump877:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump878
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump878:
	cmp rax, [rsp + 40]
	jl .jump879
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump879:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump880
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump880:
	cmp rax, [rsp + 48]
	jl .jump881
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump881:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump882
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump882:
	cmp rax, [rsp + 56]
	jl .jump883
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump883:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump884
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump884:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump885: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const309] ; 80.42
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const310] ; 3.05
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump886
	mov rax, [rel const311] ; 70.75
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump887
.jump886:
	mov rax, [rel const312] ; 33.54
	push rax
.jump887:
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump885 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump885 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump885 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const313] ; 784
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump888
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump888:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump889: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const314] ; 3
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump890
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump890:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump891
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump891:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump892
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump892:
	imul rdi, [rsp + 0 + 8] ; multiply by (3 + d) 
	jno .jump893
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump893:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump894: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump895
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump895:
	; Computing bound for 'g'
	mov rax, [rel const315] ; 323
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump896
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump896:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 323 
	jno .jump897
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump897:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump898
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump898:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump899: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const181] ; 929
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump899 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump899 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump894 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump894 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump900
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump900:
	cmp rax, [rsp + 16]
	jl .jump901
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump901:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump902
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump902:
	cmp rax, [rsp + 24]
	jl .jump903
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump903:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const316] ; 359
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump904
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump904:
	; Computing bound for 'f'
	mov rax, [rel const114] ; 371
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump905
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump905:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump906
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump906:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump907
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump907:
	imul rdi, [rsp + 0 + 8] ; multiply by (d + 371) 
	jno .jump908
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump908:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump909
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump909:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump910: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump911
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump911:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump912
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump912:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump913
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump913:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump914: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump914 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump914 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump914 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump910 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump910 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump910 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump915
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump915:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump916: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump916 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump917
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump917:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump918: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const276] ; 576
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump918 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump919
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump919:
	cmp rax, [rsp + 24]
	jl .jump920
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump920:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump921
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump921:
	cmp rax, [rsp + 32]
	jl .jump922
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump922:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump923
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump923:
	cmp rax, [rsp + 40]
	jl .jump924
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump924:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump925
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump925:
	cmp rax, [rsp + 16]
	jl .jump926
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump926:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump927
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump927:
	cmp rax, [rsp + 24]
	jl .jump928
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump928:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump889 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump929
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump929:
	; Computing bound for 'f'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump930
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const200] ; 363
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump931
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump931:
	cmp rax, [rsp + 8]
	jl .jump932
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump932:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
.jump930:
	push rax
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump933
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump935
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump937
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump937:
	; Computing bound for 'e'
	mov rax, [rel const317] ; 888
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump938
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump938:
	; Computing bound for 'd'
	mov rax, [rel const194] ; 51
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump939
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump939:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- (- 51)) 
	jno .jump940
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump940:
	imul rdi, [rsp + 0 + 8] ; multiply by 888 
	jno .jump941
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump941:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump942
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump942:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump943: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump943 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump943 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump943 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump936
.jump935:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump944
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump944:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump945
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump945:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump946
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump946:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump947
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump947:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump948: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const318] ; 667
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump949
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump949:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump950
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump950:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump951
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump951:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump952
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump952:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump953
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump953:
	imul rdi, [rsp + 0 + 16] ; multiply by 667 
	jno .jump954
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump954:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump955: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const29] ; 467
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump955 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump955 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump955 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump948 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump948 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const319] ; 988
	push rax
	mov rax, [rel const320] ; 396
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump956
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump956:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump957
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump957:
	cmp rax, [rsp + 16]
	jl .jump958
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump958:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump959
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump959:
	cmp rax, [rsp + 24]
	jl .jump960
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump960:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump936:
	jmp .jump934
.jump933:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const178] ; 614
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump961
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump961:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump962
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump962:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump963
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump963:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump964
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump964:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump965
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump965:
	imul rdi, [rsp + 0 + 16] ; multiply by 614 
	jno .jump966
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump966:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump967: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump967 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump967 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump967 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump968
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump968:
	cmp rax, [rsp + 8]
	jl .jump969
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump969:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump934:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump970
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump970:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump971
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump971:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump972: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump973
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump973:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump974
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump974:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump975: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump975 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump975 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump972 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump972 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump976
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump976:
	; Computing bound for 'd'
	mov rax, [rel const321] ; 138
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump977
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump977:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump978: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump978 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump978 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump979
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump981
	mov rax, [rel const94] ; False
	push rax
	pop rax
.jump981:
	push rax
	jmp .jump980
.jump979:
	mov rax, [rel const322] ; 781
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
.jump980:
	pop rax
	cmp rax, 0
	je .jump982
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const323] ; 1.23
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	jmp .jump983
.jump982:
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump984
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const298] ; 876
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	jmp .jump985
.jump984:
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
.jump985:
.jump983:
	pop rax
	cmp rax, 0
	jne .jump986
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump987
	mov rax, [rel const324] ; 218
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
.jump987:
	push rax
	pop rax
.jump986:
	push rax
	pop rax
	cmp rax, 0
	je .jump988
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const325] ; 346
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	jmp .jump989
.jump988:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const326] ; 793
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump990
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump990:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump991: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump991 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump992
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump992:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump993
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump993:
	; Computing bound for 'd'
	mov rax, [rel const240] ; 417
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump994
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump994:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by 417 
	jno .jump995
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump995:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump996
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump996:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[d : 793] d) 
	jno .jump997
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump997:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump998: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump998 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump998 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump998 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const327] ; 772
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const328] ; 106
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump999
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump999:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const263] ; 344
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1000
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1000:
	; Computing bound for 'e'
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const329] ; 15
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1001
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1001:
	cmp rax, [rsp + 8]
	jl .jump1002
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1002:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1003
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1003:
	; Computing bound for 'd'
	mov rax, [rel const330] ; 253
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1004
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1004:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1005: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1005 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1005 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1005 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1005 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1006
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1006:
	cmp rax, [rsp + 24]
	jl .jump1007
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1007:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1008
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1008:
	cmp rax, [rsp + 32]
	jl .jump1009
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1009:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1010
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1010:
	cmp rax, [rsp + 40]
	jl .jump1011
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1011:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const331] ; 534
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1012
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1012:
	cmp rax, [rsp + 8]
	jl .jump1013
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1013:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump989:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const130] ; 297
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1014
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1014:
	; Computing bound for 'd'
	mov rax, [rel const332] ; 182
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1015
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1015:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 182 
	jno .jump1016
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1016:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 297) 
	jno .jump1017
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1017:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1018: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1018 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1018 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const333] ; 911
	push rax
	mov rax, [rel const334] ; 459
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1019
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1019:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const201] ; 727
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1020
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1020:
	; Computing bound for 'e'
	mov rax, [rel const335] ; 476
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1021
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1021:
	; Computing bound for 'd'
	mov rax, [rel const9] ; 374
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1022
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1022:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 374 
	jno .jump1023
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1023:
	imul rdi, [rsp + 0 + 8] ; multiply by 476 
	jno .jump1024
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1024:
	imul rdi, [rsp + 0 + 16] ; multiply by 727 
	jno .jump1025
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1025:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1026: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1026 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1026 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1026 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1027
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1027:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1028: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const336] ; 941
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1028 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const325] ; 346
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1029
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1029:
	cmp rax, [rsp + 24]
	jl .jump1030
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1030:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1031
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1031:
	cmp rax, [rsp + 32]
	jl .jump1032
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1032:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1033
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1033:
	cmp rax, [rsp + 40]
	jl .jump1034
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1034:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1035
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1035:
	cmp rax, [rsp + 16]
	jl .jump1036
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1036:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1037
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1037:
	cmp rax, [rsp + 24]
	jl .jump1038
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1038:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump1039
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1040
	mov rax, [rel const337] ; 254
	push rax
	mov rax, [rel const338] ; 275
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	jmp .jump1041
.jump1040:
	mov rax, [rel const118] ; 455
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
.jump1041:
	pop rax
	cmp rax, 0
	je .jump1042
	mov rax, [rel const8] ; True
	push rax
	jmp .jump1043
.jump1042:
	mov rax, [rel const8] ; True
	push rax
.jump1043:
	pop rax
.jump1039:
	push rax
	pop rax
	cmp rax, 0
	je .jump1044
	mov rax, [rel const339] ; 739
	push rax
	jmp .jump1045
.jump1044:
	mov rax, [rel const340] ; 1000
	push rax
.jump1045:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1046
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1046:
	cmp rax, [rsp + 24]
	jl .jump1047
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1047:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1048
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1048:
	cmp rax, [rsp + 32]
	jl .jump1049
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1049:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1050
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1050:
	cmp rax, [rsp + 40]
	jl .jump1051
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1051:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1052
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1052:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1053
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1053:
	; Computing bound for 'd'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1054
	mov rax, [rel const273] ; 286
	push rax
	jmp .jump1055
.jump1054:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
.jump1055:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1056
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1056:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1057: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1058
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1060
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump1061
.jump1060:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump1061:
	jmp .jump1059
.jump1058:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump1059:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1062
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1064
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1064:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1065
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1065:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1066
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1066:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump1067
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1067:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump1068
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1068:
	imul rdi, [rsp + 0 + 16] ; multiply by e 
	jno .jump1069
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1069:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1070: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1070 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1070 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1070 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1071
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1071:
	cmp rax, [rsp + 24]
	jl .jump1072
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1072:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1073
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1073:
	cmp rax, [rsp + 32]
	jl .jump1074
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1074:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1075
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1075:
	cmp rax, [rsp + 40]
	jl .jump1076
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1076:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	jmp .jump1063
.jump1062:
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1077
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1079
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	jmp .jump1080
.jump1079:
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const341] ; 538
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
.jump1080:
	jmp .jump1078
.jump1077:
	mov rax, [rel const94] ; False
	push rax
.jump1078:
.jump1063:
	pop rax
	cmp rax, 0
	je .jump1081
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1083
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	jmp .jump1084
.jump1083:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1085
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1085:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump1086
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1086:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1087: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1087 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump1084:
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1088
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1088:
	cmp rax, [rsp + 8]
	jl .jump1089
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1089:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1090
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1090:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1091: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const342] ; 27.77
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1091 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const343] ; 35.09
	push rax
	jmp .jump1082
.jump1081:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1092
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1092:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by (- (- d)) 
	jno .jump1093
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1093:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1094: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const344] ; 40.79
	push rax
	mov rax, [rel const345] ; 87.25
	push rax
	mov rax, [rel const346] ; 54.39
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1095
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump1096
.jump1095:
	mov rax, [rel const347] ; 65.98
	push rax
.jump1096:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1094 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1097
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1097:
	; Computing bound for 'j'
	mov rax, [rel const348] ; 399
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1098
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1098:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1099
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1099:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1100
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1100:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump1101
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1101:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump1102
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1102:
	imul rdi, [rsp + 0 + 16] ; multiply by 399 
	jno .jump1103
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1103:
	imul rdi, [rsp + 0 + 24] ; multiply by e 
	jno .jump1104
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1104:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1105: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1105 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1105 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1105 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1105 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const349] ; 269
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1106
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1106:
	cmp rax, [rsp + 32]
	jl .jump1107
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1107:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1108
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1108:
	cmp rax, [rsp + 40]
	jl .jump1109
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1109:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1110
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1110:
	cmp rax, [rsp + 48]
	jl .jump1111
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1111:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1112
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1112:
	cmp rax, [rsp + 56]
	jl .jump1113
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1113:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1114
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1114:
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1115
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1115:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1116
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1116:
	; Computing bound for 'i'
	mov rax, [rel const350] ; 506
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1117
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1117:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1118
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1118:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1119: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1119 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1119 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1119 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1119 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1120
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1120:
	; Computing bound for 'h'
	mov rax, [rel const351] ; 834
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1121
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1121:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1122: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1122 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1122 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1122 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1123
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1123:
	cmp rax, [rsp + 8]
	jl .jump1124
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1124:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump1082:
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1057 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1057 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1057 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1057 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump1125
	mov rax, [rel const94] ; False
	push rax
	pop rax
.jump1125:
	push rax
	pop rax
	cmp rax, 0
	jne .jump1126
	mov rax, [rel const8] ; True
	push rax
	pop rax
.jump1126:
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1127
	mov rax, [rel const352] ; 964
	push rax
	jmp .jump1128
.jump1127:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1129
	mov rax, [rel const353] ; 571
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1131
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1131:
	cqo
	idiv r10
	push rax
	jmp .jump1130
.jump1129:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
.jump1130:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1132
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1132:
	; Computing bound for 'f'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1133
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump1134
.jump1133:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump1134:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1135
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1135:
	; Computing bound for 'e'
	mov rax, [rel const354] ; 644
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1136
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1136:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1137
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1137:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1138: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1138 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1138 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1138 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1138 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
.jump1128:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1139
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1139:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1140
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1140:
	; Computing bound for 'f'
	mov rax, [rel const355] ; 959
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1141
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1141:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1142
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1142:
	; Computing bound for 'd'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1143
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1143:
	; Computing bound for 'f'
	mov rax, [rel const356] ; 388
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1144
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1144:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1145
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1145:
	; Computing bound for 'd'
	mov rax, [rel const53] ; 524
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1146
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1146:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1147: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1147 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1147 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1147 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1147 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1148
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1148:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[d : 524, e : b, f : 388, g : b] b) 
	jno .jump1149
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1149:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump1150
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1150:
	imul rdi, [rsp + 0 + 16] ; multiply by 959 
	jno .jump1151
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1151:
	imul rdi, [rsp + 0 + 24] ; multiply by b 
	jno .jump1152
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1152:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1153: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1153 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1153 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1153 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1153 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const201] ; 727
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const357] ; 65
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1154
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1154:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1155: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1155 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1156
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump1157
.jump1156:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump1157:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1158
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1158:
	cmp rax, [rsp + 32]
	jl .jump1159
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1159:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1160
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1160:
	cmp rax, [rsp + 40]
	jl .jump1161
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1161:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1162
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1162:
	cmp rax, [rsp + 48]
	jl .jump1163
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1163:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1164
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1164:
	cmp rax, [rsp + 56]
	jl .jump1165
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1165:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1166
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1166:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1167
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1167:
	; Computing bound for 'e'
	mov rax, [rel const358] ; 214
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1168
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1168:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1169
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1169:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump1170
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1170:
	imul rdi, [rsp + 0 + 8] ; multiply by 214 
	jno .jump1171
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1171:
imul rdi, [rsp + 0 + 16] ; multiply by ((array[d : (sum[d : 524, e : b, f : 388, g : b] b), e : b, f : 959, g : b] d)[(if (! false) then (- b) else b), b, (sum[d : 65] b), 727] / (- (- b))) 
	jno .jump1172
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1172:
imul rdi, [rsp + 0 + 24] ; multiply by (if (! ((false || false) || true)) then 964 else (sum[d : b, e : 644, f : (- (if true then b else b)), g : (if true then (b / 571) else (b + b))] d)) 
	jno .jump1173
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1173:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1174: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1175
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const359] ; 191
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1177
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1177:
	cmp rax, [rsp + 8]
	jl .jump1178
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1178:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1176
.jump1175:
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1179
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1179:
	cqo
	idiv r10
	mov rax, rdx
	push rax
.jump1176:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1180
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1180:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by (if false then a[191] else (f % f)) 
	jno .jump1181
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1181:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1182: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const360] ; 34.43
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1183
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1183:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1184
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1184:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1185: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1185 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1185 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const361] ; 76.97
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1182 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1186
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1186:
	cmp rax, [rsp + 8]
	jl .jump1187
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1187:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1174 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1174 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1174 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1174 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1188
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1188:
	; Computing bound for 'd'
	mov rax, [rel const246] ; 231
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1189
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1189:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1190: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1190 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1190 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1191
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1191:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1192
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1192:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1193
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump1193:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1194
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1194:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (b / b) 
	jno .jump1195
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1195:
imul rdi, [rsp + 0 + 8] ; multiply by (((sum[d : 231, e : b] e) + b) / b) 
	jno .jump1196
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1196:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1197: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1197 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1197 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const362] ; 461
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1198
	mov rax, [rel const125] ; 504
	push rax
	jmp .jump1199
.jump1198:
	mov rax, [rel const363] ; 450
	push rax
.jump1199:
	mov rax, [rel const364] ; 843
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1200
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1200:
	cmp rax, [rsp + 16]
	jl .jump1201
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1201:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1202
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1202:
	cmp rax, [rsp + 24]
	jl .jump1203
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1203:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const99] ; 601
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1204
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1204:
	cmp rax, [rsp + 32]
	jl .jump1205
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1205:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1206
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1206:
	cmp rax, [rsp + 40]
	jl .jump1207
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1207:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1208
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1208:
	cmp rax, [rsp + 48]
	jl .jump1209
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1209:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1210
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1210:
	cmp rax, [rsp + 56]
	jl .jump1211
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1211:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump1212
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const365] ; 4.84
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
.jump1212:
	push rax
	pop rax
	cmp rax, 0
	je .jump1213
	mov rax, [rel const366] ; 532
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1215
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump1215:
	push rax
	pop rax
	cmp rax, 0
	je .jump1216
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump1217
.jump1216:
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1218
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1218:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1219
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1219:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1220: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const233] ; 711
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1220 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1220 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1221
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1221:
	cmp rax, [rsp + 8]
	jl .jump1222
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1222:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump1217:
	jmp .jump1214
.jump1213:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const194] ; 51
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
.jump1214:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1223
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1223:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1224: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const367] ; 295
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1225
	mov rax, [rel const368] ; 149
	push rax
	jmp .jump1226
.jump1225:
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
.jump1226:
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1224 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1227
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1227:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1228
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1228:
	; Computing bound for 'd'
	mov rax, [rel const75] ; 466
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1229
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1229:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by 466 
	jno .jump1230
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1230:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump1231
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1231:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[d : (if (false || (4.84 >= c)) then (if ((b != 532) && (! true)) then (- b) else a[(sum[d : b, e : b] 711)]) else (- (51 - b)))] (if (b == 295) then 149 else d)) 
	jno .jump1232
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1232:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1233: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1234
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1234:
	; Computing bound for 'h'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1235
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1237
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1237:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1238
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1238:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1239
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1239:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump1240
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1240:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump1241
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1241:
	imul rdi, [rsp + 0 + 16] ; multiply by e 
	jno .jump1242
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1242:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1243: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1243 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1243 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1243 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump1236
.jump1235:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1244
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1244:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1245
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1245:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1246
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1246:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump1247
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1247:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump1248
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1248:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump1249
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1249:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1250: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1250 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1250 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1250 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump1236:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1251
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1251:
	; Computing bound for 'g'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1252
	mov rax, [rel const369] ; 885
	push rax
	jmp .jump1253
.jump1252:
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
.jump1253:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1254
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1254:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1255: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1255 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1255 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1256
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1256:
	cmp rax, [rsp + 24]
	jl .jump1257
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1257:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1258
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1258:
	cmp rax, [rsp + 32]
	jl .jump1259
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1259:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1260
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1260:
	cmp rax, [rsp + 40]
	jl .jump1261
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1261:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1262
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1262:
	; Computing bound for 'g'
	mov rax, [rel const370] ; 307
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1263
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1263:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by 307 
	jno .jump1264
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1264:
imul rdi, [rsp + 0 + 8] ; multiply by (if false then (array[g : f, h : e, i : e] g) else (array[g : d, h : b, i : b] d))[d, (sum[g : (if true then 885 else d), h : (- e)] h), b] 
	jno .jump1265
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1265:
	imul rdi, [rsp + 0 + 16] ; multiply by d 
	jno .jump1266
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1266:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1267: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1268
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1268:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1269: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const371] ; 46.37
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1269 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1267 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1267 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1267 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const289] ; 180
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const341] ; 538
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	mov rax, [rel const8] ; True
	push rax
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1270
	mov rax, [rel const372] ; 873
	push rax
	jmp .jump1271
.jump1270:
	mov rax, [rel const82] ; 270
	push rax
.jump1271:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1272
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1272:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1273
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1273:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1274
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1274:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1275: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1275 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1275 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1275 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1276
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1276:
	cmp rax, [rsp + 8]
	jl .jump1277
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1277:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1278
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	jmp .jump1279
.jump1278:
	mov rax, [rel const373] ; 886
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1280
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1280:
	cqo
	idiv r10
	push rax
.jump1279:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1281
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1281:
	cmp rax, [rsp + 24]
	jl .jump1282
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1282:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1283
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1283:
	cmp rax, [rsp + 32]
	jl .jump1284
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1284:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1285
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1285:
	cmp rax, [rsp + 40]
	jl .jump1286
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1286:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1233 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1233 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1233 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const374] ; 481
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1287
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1287:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1288
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1288:
	; Computing bound for 'e'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1289
	mov rax, [rel const128] ; 438
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump1290
.jump1289:
	mov rax, [rel const375] ; 570
	push rax
	mov rax, [rel const376] ; 37
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
.jump1290:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1291
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1291:
	; Computing bound for 'd'
	mov rax, [rel const377] ; 977
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1292
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1292:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1293: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 24], 1
	; Compare g to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1293 ; If g < bound, next iter
	mov qword [rsp + 24], 0 ; g = 0
	add qword [rsp + 16], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1293 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1293 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1293 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1294
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1294:
	cmp rax, [rsp + 8]
	jl .jump1295
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1295:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const211] ; 271
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1296
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1296:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1297: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1297 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1298
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1298:
	cmp rax, [rsp + 8]
	jl .jump1299
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1299:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const378] ; 652
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1300
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1300:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1301
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1301:
	; Computing bound for 'd'
	mov rax, [rel const379] ; 272
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1302
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1302:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 272 
	jno .jump1303
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1303:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump1304
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1304:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1305: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1305 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1305 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1306
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1306:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1307
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1307:
	; Computing bound for 'd'
	mov rax, [rel const372] ; 873
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1308
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1308:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1309: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1309 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1309 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1309 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const380] ; 514
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1310
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1310:
	cmp rax, [rsp + 16]
	jl .jump1311
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1311:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1312
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1312:
	cmp rax, [rsp + 24]
	jl .jump1313
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1313:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1314
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1314:
	; Computing bound for 'e'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1315
	mov rax, [rel const16] ; 225
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	jmp .jump1316
.jump1315:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump1316:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1317
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1317:
	; Computing bound for 'd'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const381] ; 807
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1318
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1318:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 807 
	jno .jump1319
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1319:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1320: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const381] ; 807
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1320 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1321
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1321:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1322
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1322:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1323: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1323 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1323 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1324
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1324:
	cmp rax, [rsp + 8]
	jl .jump1325
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1325:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1326
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1326:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1327: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1328
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1328:
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const382] ; 605
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1329
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1329:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1330
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1330:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1331
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1331:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1332: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const383] ; 335
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1332 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1332 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1332 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1333
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1333:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1334
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1334:
	; Computing bound for 'g'
	mov rax, [rel const331] ; 534
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1335
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1335:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1336: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1337
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1337:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1336 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1336 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1336 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1336 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 16], 1
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1327 ; If f < bound, next iter
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1327 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1327 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1338
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1338:
	cqo
	idiv r10
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const384] ; 657
	push rax
	mov rax, [rel const385] ; 377
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1339
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1339:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1340
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1340:
	; Computing bound for 'd'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1341
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1343
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1343:
	cmp rax, [rsp + 8]
	jl .jump1344
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1344:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1342
.jump1341:
	mov rax, [rel const252] ; 659
	push rax
.jump1342:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1345
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1345:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if false then a[b] else 659) 
	jno .jump1346
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1346:
	imul rdi, [rsp + 0 + 8] ; multiply by (- (- ((b % 377) - 657))) 
	jno .jump1347
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1347:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1348: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1349
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1349:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1350
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1350:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- d) 
	jno .jump1351
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1351:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump1352
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1352:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1353: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const386] ; 953
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1353 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1353 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1354
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1354:
	cmp rax, [rsp + 16]
	jl .jump1355
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1355:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1356
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1356:
	cmp rax, [rsp + 24]
	jl .jump1357
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1357:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1358
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1358:
	cmp rax, [rsp + 8]
	jl .jump1359
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1359:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1348 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1348 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1360
	mov rax, [rel const8] ; True
	push rax
	mov rax, [rel const8] ; True
	push rax
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	mov rax, [rel const162] ; 986
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1361
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1361:
	cmp rax, [rsp + 8]
	jl .jump1362
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1362:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
.jump1360:
	push rax
	pop rax
	cmp rax, 0
	je .jump1363
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const8] ; 1
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1365
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1365:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 1 
	jno .jump1366
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1366:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump1367: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 0], 1
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1367 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1368
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1368:
	cmp rax, [rsp + 8]
	jl .jump1369
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1369:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1364
.jump1363:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump1364:
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1370
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1370:
	cmp rax, [rsp + 16]
	jl .jump1371
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1371:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1372
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1372:
	cmp rax, [rsp + 24]
	jl .jump1373
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1373:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1374
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1374:
	cmp rax, [rsp + 24]
	jl .jump1375
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1375:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1376
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1376:
	cmp rax, [rsp + 32]
	jl .jump1377
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1377:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1378
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1378:
	cmp rax, [rsp + 40]
	jl .jump1379
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1379:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _get_time
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	call _get_time
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp + 32]
	subsd xmm0, xmm1
	call _print_time
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const387] ; 285
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1380
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1380:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1381
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1381:
	; Computing bound for 'h'
	mov rax, [rel const388] ; 195
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1382
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1382:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1383
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1383:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1384
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1384:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump1385
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1385:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump1386
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1386:
	imul rdi, [rsp + 0 + 16] ; multiply by (- 195) 
	jno .jump1387
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1387:
	imul rdi, [rsp + 0 + 24] ; multiply by (285 % b) 
	jno .jump1388
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1388:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1389: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1389 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1389 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1389 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1389 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1390
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const389] ; 11
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1392
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1392:
	cmp rax, [rsp + 8]
	jl .jump1393
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1393:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const390] ; 516
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	jmp .jump1391
.jump1390:
	mov rax, [rel const391] ; 127
	push rax
.jump1391:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const374] ; 481
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1394
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1394:
	; Computing bound for 'h'
	mov rax, [rel const392] ; 397
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1395
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1395:
	; Computing bound for 'g'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1396
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump1397
.jump1396:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump1397:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1398
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1398:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const393] ; 86.19
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1399
	mov rax, [rel const335] ; 476
	push rax
	jmp .jump1400
.jump1399:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump1400:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1401
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1401:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1402: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	mov rax, [rel const394] ; 162
	push rax
	mov rax, [rel const381] ; 807
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1403
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1403:
	cmp rax, [rsp + 8]
	jl .jump1404
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1404:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1402 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1402 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1402 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1402 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1405
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1405:
	cmp rax, [rsp + 32]
	jl .jump1406
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1406:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1407
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1407:
	cmp rax, [rsp + 40]
	jl .jump1408
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1408:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1409
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1409:
	cmp rax, [rsp + 48]
	jl .jump1410
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1410:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1411
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1411:
	cmp rax, [rsp + 56]
	jl .jump1412
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1412:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1413
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1413:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1414
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1414:
	; Computing bound for 'f'
	mov rax, [rel const44] ; 665
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1415
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1415:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 665) 
	jno .jump1416
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1416:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump1417
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1417:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1418: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1418 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1418 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const395] ; 428
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const328] ; 106
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1419
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1419:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1420
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1420:
	cmp rax, [rsp + 16]
	jl .jump1421
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1421:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1422
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1422:
	cmp rax, [rsp + 24]
	jl .jump1423
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1423:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1424
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1424:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1425
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1425:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1426
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1426:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1427
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1427:
	; Computing bound for 'h'
	mov rax, [rel const396] ; 357
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1428
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1428:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1429
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1429:
	; Computing bound for 'f'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1430
	mov rax, [rel const57] ; 9
	push rax
	jmp .jump1431
.jump1430:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump1431:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1432
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1432:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1433: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const397] ; 554
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1433 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1433 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1433 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1433 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1434
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1434:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1435
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump1436
.jump1435:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump1436:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1437
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1437:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const98] ; 710
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1438
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1438:
	; Computing bound for 'f'
	mov rax, [rel const398] ; 171
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1439
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1439:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1440: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1440 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1440 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1441
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1441:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1442: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1443
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1443:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1442 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1442 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1442 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1442 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1444
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1444:
	; Computing bound for 'f'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1445
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1445:
	; Computing bound for 'f'
	mov rax, [rel const68] ; 580
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1446
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1446:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 580) 
	jno .jump1447
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1447:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump1448
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1448:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1449: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1449 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1449 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const292] ; 23
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1450
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1450:
	cmp rax, [rsp + 16]
	jl .jump1451
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1451:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1452
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1452:
	cmp rax, [rsp + 24]
	jl .jump1453
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1453:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1454
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1454:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1455: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1455 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1455 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1455 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1455 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1456
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1456:
	; Computing bound for 'f'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const399] ; 129
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1457
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1457:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1458
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1458:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1459: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1459 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1460
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1460:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const400] ; 331
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1461
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1461:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1462: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1462 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1463
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1463:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[f : 331] b) 
	jno .jump1464
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1464:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[f : b] f) 
	jno .jump1465
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1465:
	imul rdi, [rsp + 0 + 16] ; multiply by 129 
	jno .jump1466
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1466:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1467: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1468
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1468:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1469
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1469:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump1470
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1470:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump1471
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1471:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1472: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1472 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1472 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1467 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1467 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1467 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1473
	mov rax, [rel const8] ; True
	push rax
	pop rax
.jump1473:
	push rax
	pop rax
	cmp rax, 0
	je .jump1474
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1476
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1476:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1477: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1477 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump1475
.jump1474:
	mov rax, [rel const253] ; 440
	push rax
	pop rax
	neg rax
	push rax
.jump1475:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1478
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1478:
	cmp rax, [rsp + 24]
	jl .jump1479
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1479:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1480
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1480:
	cmp rax, [rsp + 32]
	jl .jump1481
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1481:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1482
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1482:
	cmp rax, [rsp + 40]
	jl .jump1483
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1483:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1484
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1484:
	; Computing bound for 'f'
	mov rax, [rel const354] ; 644
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1485
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1485:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1486: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1486 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1486 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const401] ; 302
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1487
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1487:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1488
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1488:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1489
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1489:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1490
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1490:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1491
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1491:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1492: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1492 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1492 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1492 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1492 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1493
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1493:
	; Computing bound for 'f'
	mov rax, [rel const277] ; 436
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1494
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1494:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 436) 
	jno .jump1495
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1495:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[f : b, g : b, h : b, i : b] b) 
	jno .jump1496
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1496:
	imul rdi, [rsp + 0 + 16] ; multiply by (- 302) 
	jno .jump1497
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1497:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1498: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1499
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1499:
	cmp rax, [rsp + 8]
	jl .jump1500
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1500:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1498 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1498 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1498 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump1501
	mov rax, [rel const94] ; False
	push rax
	pop rax
.jump1501:
	push rax
	pop rax
	cmp rax, 0
	je .jump1502
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump1503
.jump1502:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const402] ; 630
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1504
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1504:
	; Computing bound for 'g'
	mov rax, [rel const403] ; 228
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1505
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1505:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1506
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1506:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1507: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const404] ; 496
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1507 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1507 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1507 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump1503:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1508
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1508:
	cmp rax, [rsp + 24]
	jl .jump1509
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1509:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1510
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1510:
	cmp rax, [rsp + 32]
	jl .jump1511
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1511:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1512
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1512:
	cmp rax, [rsp + 40]
	jl .jump1513
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1513:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1514
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1514:
	cmp rax, [rsp + 16]
	jl .jump1515
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1515:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1516
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1516:
	cmp rax, [rsp + 24]
	jl .jump1517
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1517:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1518
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1518:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
imul rdi, [rsp + 0 + 0] ; multiply by (array[f : (sum[f : 331] b), g : (sum[f : b] f), h : 129] (array[i : h, j : b] h))[(- (b + b)), (if (true && true) then (sum[f : b] b) else (- 440)), (- b)][(array[f : (- 436), g : (sum[f : b, g : b, h : b, i : b] b), h : (- 302)] a[b])[(if (true || false) then b else (sum[f : b, g : 228, h : 630] 496)), b, (- b)], (sum[f : (- 644), g : (- b)] f)] 
	jno .jump1519
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1519:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[f : (array[f : (- 580), g : b] f)[23, b], g : (sum[f : (- (sum[f : 171, g : 710] b)), g : (if (c > c) then b else (- b)), h : (sum[f : (if false then 9 else b), g : (b * b), h : 357, i : b] 554), i : b] (f % g)), h : b, i : (array[f : (- 665), g : b] f)[(- (- b)), ((- 106) % (- 428))]] g) 
	jno .jump1520
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1520:
imul rdi, [rsp + 0 + 16] ; multiply by (array[f : b, g : b, h : (- 195), i : (285 % b)] g)[(sum[f : (if (86.19 < c) then 476 else b), g : (if true then b else b), h : (- 397), i : (- 481)] [i, f, g, b][(807 - 162)]), (if (! (b >= b)) then (516 * a[11]) else 127), b, (b + b)] 
	jno .jump1521
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1521:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1522: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1523
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1523:
	; Computing bound for 'j'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1524
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump1525
.jump1524:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump1525:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1526
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1526:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1527
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1527:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump1528
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1528:
	imul rdi, [rsp + 0 + 8] ; multiply by (if true then b else b) 
	jno .jump1529
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1529:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump1530
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1530:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1531: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1532
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1532:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1533
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1533:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump1534
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1534:
	imul rdi, [rsp + 0 + 8] ; multiply by j 
	jno .jump1535
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1535:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1536: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1536 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1536 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1531 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1531 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1531 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1537
	mov rax, [rel const405] ; 828
	push rax
	jmp .jump1538
.jump1537:
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
.jump1538:
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1539
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	jmp .jump1540
.jump1539:
	mov rax, [rel const61] ; 920
	push rax
.jump1540:
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1541
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1543
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1543:
	cqo
	idiv r10
	push rax
	jmp .jump1542
.jump1541:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump1542:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1544
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1544:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1545
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1545:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump1546
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1546:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump1547
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1547:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1548: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const94] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1548 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1548 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1549
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1549:
	cmp rax, [rsp + 8]
	jl .jump1550
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1550:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const406] ; 891
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1551
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1551:
	cmp rax, [rsp + 16]
	jl .jump1552
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1552:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1553
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1553:
	cmp rax, [rsp + 24]
	jl .jump1554
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1554:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1555
	mov rax, [rel const333] ; 911
	push rax
	jmp .jump1556
.jump1555:
	mov rax, [rel const407] ; 705
	push rax
.jump1556:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1557
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1557:
	cmp rax, [rsp + 24]
	jl .jump1558
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1558:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1559
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1559:
	cmp rax, [rsp + 32]
	jl .jump1560
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1560:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1561
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1561:
	cmp rax, [rsp + 40]
	jl .jump1562
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1562:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1522 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1522 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1522 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 1
	push rax
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1563
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1565
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1565:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1566
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1566:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1567: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1567 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1568
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1568:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1569
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1569:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1570
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1570:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1571
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1571:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1572
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1572:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1573: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1573 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1573 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1573 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1573 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1574
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1574:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1575: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1575 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1575 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1576
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1576:
	; Computing bound for 'g'
	mov rax, [rel const408] ; 797
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1577
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1577:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const332] ; 182
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1578
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1578:
	; Computing bound for 'h'
	mov rax, [rel const275] ; 553
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1579
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1579:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1580
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1580:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1581
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1581:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1582: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1583
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	jmp .jump1584
.jump1583:
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
.jump1584:
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1582 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1582 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1582 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1582 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1585
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1585:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[f : b, g : b, h : 553, i : (- (- 182))] (if false then i else f)) 
	jno .jump1586
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1586:
	imul rdi, [rsp + 0 + 8] ; multiply by 797 
	jno .jump1587
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1587:
imul rdi, [rsp + 0 + 16] ; multiply by (- (sum[f : (sum[f : b, g : b, h : b, i : b] i), g : (sum[f : b] f)] b)) 
	jno .jump1588
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1588:
	imul rdi, [rsp + 0 + 24] ; multiply by b 
	jno .jump1589
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1589:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1590: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1590 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1590 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1590 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1590 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1591
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1591:
	cmp rax, [rsp + 8]
	jl .jump1592
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1592:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1593
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1593:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1594
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1594:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump1595
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1595:
	imul rdi, [rsp + 0 + 8] ; multiply by a[b] 
	jno .jump1596
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1596:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1597: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const385] ; 377
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1598
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1598:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1599: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1599 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1597 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1597 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const409] ; 617
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1600
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1600:
	cmp rax, [rsp + 16]
	jl .jump1601
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1601:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1602
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1602:
	cmp rax, [rsp + 24]
	jl .jump1603
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1603:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1604
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1606
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1606:
	; Computing bound for 'f'
	mov rax, [rel const410] ; 235
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1607
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1607:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1608: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1608 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1608 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1609
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1609:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1610
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1610:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1611
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1611:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1612: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1612 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1612 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1612 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump1605
.jump1604:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
.jump1605:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const411] ; 258
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1613
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump1613:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rel const412] ; 875
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1614
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1616
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1616:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1617: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1617 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump1615
.jump1614:
	mov rax, [rel const413] ; 681
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const414] ; 382
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
.jump1615:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1618
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1618:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1619: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1620
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1620:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const201] ; 727
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1621
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1621:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const415] ; 493
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1622
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1622:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1623
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1623:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1624: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1624 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1624 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1625
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1625:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1626: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1626 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1626 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1626 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1619 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1627
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1627:
	cmp rax, [rsp + 32]
	jl .jump1628
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1628:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1629
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1629:
	cmp rax, [rsp + 40]
	jl .jump1630
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1630:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1631
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1631:
	cmp rax, [rsp + 48]
	jl .jump1632
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1632:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1633
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1633:
	cmp rax, [rsp + 56]
	jl .jump1634
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1634:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1564
.jump1563:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1635
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump1636
.jump1635:
	mov rax, [rel const416] ; 260
	push rax
	pop rax
	neg rax
	push rax
.jump1636:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1637
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1637:
	; Computing bound for 'g'
	mov rax, [rel const417] ; 957
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1638
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1638:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const418] ; 917
	push rax
	mov rax, [rel const419] ; 383
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1639
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump1639:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1640
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1640:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1641
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1641:
	; Computing bound for 'h'
	mov rax, [rel const420] ; 838
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1642
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1642:
	; Computing bound for 'g'
	mov rax, [rel const421] ; 486
	push rax
	mov rax, [rel const422] ; 810
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1643
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump1643:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1644
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1644:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1645
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1645:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1646: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1646 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1646 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1646 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1646 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1647
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1647:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1648: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1648 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1648 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1649
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1649:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1650: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const423] ; 730
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1650 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1650 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1650 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1651
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1651:
	; Computing bound for 'g'
	mov rax, [rel const424] ; 71
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1652
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1652:
	; Computing bound for 'f'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump1653
	mov rax, [rel const8] ; True
	push rax
	pop rax
.jump1653:
	push rax
	pop rax
	cmp rax, 0
	je .jump1654
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1656
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1656:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump1657
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1657:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1658: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const425] ; 385
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1658 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const304] ; 940
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1659
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1659:
	cmp rax, [rsp + 8]
	jl .jump1660
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1660:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1655
.jump1654:
	mov rax, [rel const34] ; 112
	push rax
.jump1655:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1661
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1661:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1662: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1662 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1662 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1662 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump1564:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1663
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1663:
	cmp rax, [rsp + 8]
	jl .jump1664
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1664:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump1665
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1666
	mov rax, [rel const94] ; False
	push rax
	jmp .jump1667
.jump1666:
	mov rax, [rel const8] ; True
	push rax
.jump1667:
	pop rax
.jump1665:
	push rax
	pop rax
	cmp rax, 0
	je .jump1668
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1670
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1670:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1671
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1671:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1672: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const80] ; 164
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1672 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1673
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1673:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1674: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const350] ; 506
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1674 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1674 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1675
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1675:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const2] ; 816
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1676
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1676:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1677
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1677:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump1678
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1678:
	imul rdi, [rsp + 0 + 8] ; multiply by (- (816 - b)) 
	jno .jump1679
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1679:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[f : (sum[f : b] 164), g : b] 506) 
	jno .jump1680
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1680:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1681: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1682
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1682:
	cmp rax, [rsp + 8]
	jl .jump1683
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1683:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1684
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1684:
	cqo
	idiv r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1681 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1681 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1681 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1685
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump1686
.jump1685:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const397] ; 554
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1687
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1687:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1688: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1688 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump1686:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const230] ; 991
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1689
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1689:
	cmp rax, [rsp + 8]
	jl .jump1690
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1690:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1691
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1691:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const177] ; 573
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1692
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1692:
	; Computing bound for 'f'
	mov rax, [rel const426] ; 905
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1693
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1693:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (b - 905) 
	jno .jump1694
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1694:
	imul rdi, [rsp + 0 + 8] ; multiply by (573 * b) 
	jno .jump1695
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1695:
	imul rdi, [rsp + 0 + 16] ; multiply by a[991] 
	jno .jump1696
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1696:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1697: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1697 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1697 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1697 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const82] ; 270
	push rax
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const218] ; 425
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1698
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1698:
	cmp rax, [rsp + 8]
	jl .jump1699
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1699:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1700
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1700:
	cmp rax, [rsp + 24]
	jl .jump1701
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1701:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1702
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1702:
	cmp rax, [rsp + 32]
	jl .jump1703
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1703:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1704
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1704:
	cmp rax, [rsp + 40]
	jl .jump1705
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1705:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1706
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1706:
	cmp rax, [rsp + 24]
	jl .jump1707
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1707:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1708
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1708:
	cmp rax, [rsp + 32]
	jl .jump1709
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1709:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1710
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1710:
	cmp rax, [rsp + 40]
	jl .jump1711
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1711:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1669
.jump1668:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump1669:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1712
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1712:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1713
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1713:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1714
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1714:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1715: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1715 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1715 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump1716
	mov rax, [rel const8] ; True
	push rax
	pop rax
.jump1716:
	push rax
	pop rax
	cmp rax, 0
	je .jump1717
	mov rax, [rel const48] ; 695
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump1718
.jump1717:
	mov rax, [rel const427] ; 101
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1719
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1719:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
.jump1718:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1720
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1720:
	; Computing bound for 'f'
	mov rax, [rel const181] ; 929
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1721
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1721:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 929 
	jno .jump1722
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1722:
imul rdi, [rsp + 0 + 8] ; multiply by (- (if (((sum[f : b, g : b] b) > b) || true) then (- 695) else (b * (- (b / 101))))) 
	jno .jump1723
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1723:
imul rdi, [rsp + 0 + 16] ; multiply by (if (false || (if false then false else true)) then (array[f : b, g : (- (816 - b)), h : (sum[f : (sum[f : b] 164), g : b] 506)] (g / a[h]))[(array[f : (b - 905), g : (573 * b), h : a[991]] g)[(- b), (- a[425]), 270], (if (e.a == c) then b else (sum[f : (- 554)] f)), (- b)] else (- b)) 
	jno .jump1724
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1724:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1725: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1726
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const428] ; 372
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1728
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1728:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1729
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1729:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1730
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1730:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump1731
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1731:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump1732
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1732:
	imul rdi, [rsp + 0 + 16] ; multiply by 372 
	jno .jump1733
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1733:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1734: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1734 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1734 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1734 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1735
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1735:
	cmp rax, [rsp + 8]
	jl .jump1736
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1736:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1737
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1737:
	cmp rax, [rsp + 24]
	jl .jump1738
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1738:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1739
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1739:
	cmp rax, [rsp + 32]
	jl .jump1740
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1740:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1741
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1741:
	cmp rax, [rsp + 40]
	jl .jump1742
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1742:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1743
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1743:
	; Computing bound for 'i'
	mov rax, [rel const429] ; 116
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1744
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1744:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1745: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1745 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1745 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	jmp .jump1727
.jump1726:
	mov rax, [rel const430] ; 34.81
	push rax
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1746
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1748
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const431] ; 37.98
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
.jump1748:
	push rax
	jmp .jump1747
.jump1746:
	mov rax, [rel const432] ; 5.1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
.jump1747:
	pop rax
	cmp rax, 0
	je .jump1749
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1751
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1751:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1752
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1752:
	; Computing bound for 'j'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1753
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	jmp .jump1754
.jump1753:
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
.jump1754:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1755
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1755:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1756
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1756:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1757: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1757 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1757 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1757 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1757 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	jmp .jump1750
.jump1749:
	mov rax, [rel const433] ; 494
	push rax
.jump1750:
.jump1727:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1725 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1725 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1725 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const434] ; 133
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1758
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1758:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1759: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const435] ; 114
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1759 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const149] ; 268
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1760
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1760:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1761
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1761:
	; Computing bound for 'g'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1762
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump1763
.jump1762:
	mov rax, [rel const67] ; 936
	push rax
.jump1763:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1764
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1764:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1765
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1765:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump1766
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1766:
	imul rdi, [rsp + 0 + 8] ; multiply by (if false then b else 936) 
	jno .jump1767
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1767:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump1768
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1768:
	imul rdi, [rsp + 0 + 24] ; multiply by 268 
	jno .jump1769
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1769:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1770: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1770 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1770 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1770 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1770 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const436] ; 234
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1771
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1771:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1772: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1772 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1773
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1773:
	cmp rax, [rsp + 32]
	jl .jump1774
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1774:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1775
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1775:
	cmp rax, [rsp + 40]
	jl .jump1776
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1776:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1777
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1777:
	cmp rax, [rsp + 48]
	jl .jump1778
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1778:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1779
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1779:
	cmp rax, [rsp + 56]
	jl .jump1780
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1780:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1781
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1781:
	; Computing bound for 'h'
	mov rax, [rel const437] ; 853
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1782
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1782:
	; Computing bound for 'g'
	mov rax, [rel const438] ; 73
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1783
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1783:
	; Computing bound for 'f'
	mov rax, [rel const439] ; 386
	push rax
	mov rax, [rel const440] ; 5
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const441] ; 32
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1784
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1784:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by ((32 * (- 5)) * 386) 
	jno .jump1785
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1785:
	imul rdi, [rsp + 0 + 8] ; multiply by 73 
	jno .jump1786
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1786:
	imul rdi, [rsp + 0 + 16] ; multiply by (- (- 853)) 
	jno .jump1787
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1787:
imul rdi, [rsp + 0 + 24] ; multiply by (array[f : b, g : (if false then b else 936), h : b, i : 268] (- b))[b, (sum[f : b] f), 234, b] 
	jno .jump1788
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1788:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1789: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const442] ; 400
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1789 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1789 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1789 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1789 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1790
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1790:
	; Computing bound for 'h'
	mov rax, [rel const284] ; 46
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1791
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1791:
	; Computing bound for 'g'
	mov rax, [rel const443] ; 847
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1792
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1792:
	; Computing bound for 'f'
	mov rax, [rel const278] ; 68
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1793
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1793:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1794: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 312 to rsp 
		mov r10, [rbp - 312 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1794 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1794 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1794 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1794 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1795
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1795:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const373] ; 886
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1796
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1796:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1797
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1797:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1798: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 296 to rsp 
		mov r10, [rbp - 296 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1798 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1798 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1799
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1799:
	; Computing bound for 'f'
	mov rax, [rel const444] ; 290
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1800
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1800:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 290 
	jno .jump1801
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1801:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[f : (- b), g : (- 886)] f) 
	jno .jump1802
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1802:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[f : 68, g : 847, h : (- 46), i : (- b)] (- g)) 
	jno .jump1803
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1803:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1804: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const258] ; 453
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1804 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1804 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1804 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1805
	mov rax, [rel const445] ; 731
	push rax
	jmp .jump1806
.jump1805:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump1806:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1807
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1807:
	cmp rax, [rsp + 24]
	jl .jump1808
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1808:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1809
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1809:
	cmp rax, [rsp + 32]
	jl .jump1810
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1810:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1811
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1811:
	cmp rax, [rsp + 40]
	jl .jump1812
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1812:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const441] ; 32
	push rax
	mov rax, [rel const446] ; 591
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1813
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1813:
	cmp rax, [rsp + 32]
	jl .jump1814
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1814:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1815
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1815:
	cmp rax, [rsp + 40]
	jl .jump1816
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1816:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1817
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1817:
	cmp rax, [rsp + 48]
	jl .jump1818
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1818:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1819
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1819:
	cmp rax, [rsp + 56]
	jl .jump1820
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1820:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const447] ; 692
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1821
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1821:
	cmp rax, [rsp + 24]
	jl .jump1822
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1822:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1823
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1823:
	cmp rax, [rsp + 32]
	jl .jump1824
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1824:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1825
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1825:
	cmp rax, [rsp + 40]
	jl .jump1826
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1826:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const395] ; 428
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1827
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1827:
	; Computing bound for 'g'
	mov rax, [rel const448] ; 546
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1828
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1828:
	; Computing bound for 'f'
	mov rax, [rel const449] ; 916
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1829
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1829:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 916 
	jno .jump1830
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1830:
	imul rdi, [rsp + 0 + 8] ; multiply by 546 
	jno .jump1831
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1831:
	imul rdi, [rsp + 0 + 16] ; multiply by 428 
	jno .jump1832
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1832:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1833: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1833 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1833 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1833 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1834
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1834:
	cmp rax, [rsp + 8]
	jl .jump1835
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1835:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1836
	mov rax, [rel const8] ; True
	push rax
	jmp .jump1837
.jump1836:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
.jump1837:
	pop rax
	cmp rax, 0
	je .jump1838
	mov rax, [rel const450] ; 981
	push rax
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const451] ; 999
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1840
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1840:
	cmp rax, [rsp + 8]
	jl .jump1841
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1841:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1842
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1842:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	jmp .jump1839
.jump1838:
	mov rax, [rel const452] ; 93
	push rax
	pop rax
	neg rax
	push rax
.jump1839:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const453] ; 165
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1843
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1845
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump1845:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	jmp .jump1844
.jump1843:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump1844:
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	mov rax, [rel const396] ; 357
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1846
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1846:
	cmp rax, [rsp + 8]
	jl .jump1847
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1847:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const454] ; 527
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1848
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1848:
	cmp rax, [rsp + 24]
	jl .jump1849
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1849:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1850
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1850:
	cmp rax, [rsp + 32]
	jl .jump1851
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1851:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1852
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1852:
	cmp rax, [rsp + 40]
	jl .jump1853
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1853:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1854
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1854:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1855
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1855:
	; Computing bound for 'f'
	mov rax, [rel const455] ; 874
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1856
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1856:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1857: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1857 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1857 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1858
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1858:
	; Computing bound for 'f'
	mov rax, [rel const46] ; 277
	push rax
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1859
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump1860
.jump1859:
	mov rax, [rel const84] ; 299
	push rax
.jump1860:
	mov rax, [rel const81] ; 660
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1861
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump1861:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rel const211] ; 271
	push rax
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const456] ; 899
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1862
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1862:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1863
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1863:
	; Computing bound for 'g'
	mov rax, [rel const15] ; 870
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1864
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1864:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1865
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1865:
	; Computing bound for 'f'
	mov rax, [rel const457] ; 555
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1866
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1866:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1867: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1867 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1867 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1868
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1868:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[f : 555, g : b] f) 
	jno .jump1869
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1869:
	imul rdi, [rsp + 0 + 8] ; multiply by 870 
	jno .jump1870
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1870:
	imul rdi, [rsp + 0 + 16] ; multiply by (b / 899) 
	jno .jump1871
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1871:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1872: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1872 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1872 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1872 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1873
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump1874
.jump1873:
	mov rax, [rel const458] ; 894
	push rax
.jump1874:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1875
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1875:
	; Computing bound for 'h'
	mov rax, [rel const420] ; 838
	push rax
	mov rax, [rel const459] ; 121
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1876
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1876:
	; Computing bound for 'g'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1877
	mov rax, [rel const134] ; 366
	push rax
	jmp .jump1878
.jump1877:
	mov rax, [rel const64] ; 54
	push rax
.jump1878:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1879
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1879:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1880
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1880:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1881: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 312 to rsp 
		mov r10, [rbp - 312 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1881 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1881 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1881 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1881 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1882
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump1883
.jump1882:
	mov rax, [rel const30] ; 688
	push rax
.jump1883:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1884
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1884:
	cmp rax, [rsp + 24]
	jl .jump1885
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1885:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1886
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1886:
	cmp rax, [rsp + 32]
	jl .jump1887
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1887:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1888
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1888:
	cmp rax, [rsp + 40]
	jl .jump1889
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1889:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1890
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1890:
	cmp rax, [rsp + 8]
	jl .jump1891
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1891:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1892
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1892:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1893: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1894
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1894:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1895
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1895:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1896
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1896:
	; Computing bound for 'h'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1897
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1897:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1898
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1898:
	; Computing bound for 'h'
	mov rax, [rel const0] ; 224
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1899
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1899:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1900: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const460] ; 709
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1900 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1900 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1900 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1901
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1901:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1902
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1902:
	; Computing bound for 'i'
	mov rax, [rel const78] ; 820
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1903
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1903:
	; Computing bound for 'h'
	mov rax, [rel const401] ; 302
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1904
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1904:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 302 
	jno .jump1905
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1905:
	imul rdi, [rsp + 0 + 8] ; multiply by 820 
	jno .jump1906
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1906:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump1907
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1907:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[h : 224, i : g, j : b] 709) 
	jno .jump1908
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1908:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1909: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 296 to rsp 
		mov r10, [rbp - 296 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1909 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1909 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1909 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1909 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rel const461] ; 420
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1910
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1910:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1911: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1911 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1912
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1912:
	cmp rax, [rsp + 32]
	jl .jump1913
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1913:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1914
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1914:
	cmp rax, [rsp + 40]
	jl .jump1915
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1915:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1916
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1916:
	cmp rax, [rsp + 48]
	jl .jump1917
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1917:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1918
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1918:
	cmp rax, [rsp + 56]
	jl .jump1919
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1919:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1920
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1920:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1921: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1922
	mov rax, [rel const8] ; True
	push rax
	jmp .jump1923
.jump1922:
	mov rax, [rel const8] ; True
	push rax
.jump1923:
	pop rax
	cmp rax, 0
	je .jump1924
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	jmp .jump1925
.jump1924:
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1926
	mov rax, [rel const372] ; 873
	push rax
	jmp .jump1927
.jump1926:
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
.jump1927:
.jump1925:
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1921 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1921 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1921 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1921 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1893 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1893 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1928
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1928:
	; Computing bound for 'f'
	mov rax, [rel const419] ; 383
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1929
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1929:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1930: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const462] ; 145
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1931
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1931:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const463] ; 2.2
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1932
	mov rax, [rel const464] ; 592
	push rax
	jmp .jump1933
.jump1932:
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
.jump1933:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1934
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1934:
	; Computing bound for 'j'
	mov rax, [rel const465] ; 515
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1935
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1935:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1936
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1936:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump1937
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1937:
	imul rdi, [rsp + 0 + 8] ; multiply by 515 
	jno .jump1938
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1938:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump1939
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1939:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1940: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1940 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1940 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1940 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1941
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1941:
	cmp rax, [rsp + 24]
	jl .jump1942
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1942:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1943
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1943:
	cmp rax, [rsp + 32]
	jl .jump1944
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1944:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1945
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1945:
	cmp rax, [rsp + 40]
	jl .jump1946
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1946:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1947
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump1947:
	cqo
	idiv r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1948
	mov rax, [rel const33] ; 219
	push rax
	jmp .jump1949
.jump1948:
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
.jump1949:
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1930 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1930 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1930 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1950
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	jmp .jump1951
.jump1950:
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
.jump1951:
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1952
	mov rax, [rel const466] ; 636
	push rax
	jmp .jump1953
.jump1952:
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1954
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1954:
	cmp rax, [rsp + 8]
	jl .jump1955
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1955:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump1953:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1956
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1956:
	cmp rax, [rsp + 8]
	jl .jump1957
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1957:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1958
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1958:
	cmp rax, [rsp + 8]
	jl .jump1959
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1959:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const467] ; 55.16
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1960
	mov rax, [rel const81] ; 660
	push rax
	jmp .jump1961
.jump1960:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const400] ; 331
	push rax
	mov rax, [rel const379] ; 272
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1962
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1964
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1964:
	; Computing bound for 'g'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const448] ; 546
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1965
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1965:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 546 
	jno .jump1966
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1966:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1967: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1967 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const200] ; 363
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1968
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1968:
	cmp rax, [rsp + 8]
	jl .jump1969
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1969:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1970
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1970:
	; Computing bound for 'f'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1971
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump1972
.jump1971:
	mov rax, [rel const416] ; 260
	push rax
.jump1972:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1973
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1973:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if true then b else 260) 
	jno .jump1974
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1974:
imul rdi, [rsp + 0 + 8] ; multiply by (array[f : 546] f)[(- 363)] 
	jno .jump1975
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1975:
	imul rdi, [rsp + 0 + 16] ; multiply by (- (- b)) 
	jno .jump1976
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1976:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1977: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1978
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1978:
	; Computing bound for 'k'
	mov rax, [rel const468] ; 980
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1979
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1979:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1980
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1980:
	; Computing bound for 'i'
	mov rax, [rel const248] ; 867
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1981
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1981:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1982: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 296 to rsp 
		mov r10, [rbp - 296 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1982 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1982 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1982 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1982 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1977 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1977 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1977 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump1963
.jump1962:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const469] ; 353
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1983
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1983:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1984
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1984:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1985
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1985:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1986
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1986:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1987: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1987 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1987 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1987 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1987 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1988
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1988:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1989
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1989:
	; Computing bound for 'f'
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1990
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump1990:
	cmp rax, [rsp + 8]
	jl .jump1991
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump1991:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1992
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1992:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by a[b] 
	jno .jump1993
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1993:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump1994
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1994:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[f : b, g : b, h : b, i : (- 353)] h) 
	jno .jump1995
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump1995:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump1996: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1996 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1996 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1996 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump1963:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1997
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump1997:
	; Computing bound for 'g'
	mov rax, [rel const132] ; 693
	push rax
	mov rax, [rel const470] ; 477
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1998
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1998:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const471] ; 547
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1999
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1999:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2000
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2000:
	; Computing bound for 'f'
	mov rax, [rel const296] ; 883
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2001
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2001:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2002: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2002 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2002 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2002 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2003
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2003:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2004: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const472] ; 55.17
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2005
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	jmp .jump2006
.jump2005:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const64] ; 54
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2007
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump2007:
	cqo
	idiv r10
	mov rax, rdx
	push rax
.jump2006:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2008
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2008:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump2009: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2009 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2004 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2004 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2004 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const262] ; 47
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2010
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2010:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2011: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2011 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const473] ; 794
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2012
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2012:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 794 
	jno .jump2013
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2013:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2014: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const474] ; 662
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2015
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2015:
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2016
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2016:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2017: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2017 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2018
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2018:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2019
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2019:
	; Computing bound for 'g'
	mov rax, [rel const475] ; 728
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2020
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2020:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2021: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2021 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2021 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2022
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2022:
	; Computing bound for 'g'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2023
	mov rax, [rel const407] ; 705
	push rax
	jmp .jump2024
.jump2023:
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
.jump2024:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2025
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2025:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2026: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2026 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2026 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2026 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2026 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2014 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2027
	mov rax, [rel const476] ; 689
	push rax
	jmp .jump2028
.jump2027:
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2029
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2031
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump2032
.jump2031:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump2032:
	jmp .jump2030
.jump2029:
	mov rax, [rel const166] ; 735
	push rax
	pop rax
	neg rax
	push rax
.jump2030:
.jump2028:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2033
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2033:
	cmp rax, [rsp + 8]
	jl .jump2034
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2034:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2035
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2035:
	cmp rax, [rsp + 24]
	jl .jump2036
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2036:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2037
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2037:
	cmp rax, [rsp + 32]
	jl .jump2038
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2038:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2039
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2039:
	cmp rax, [rsp + 40]
	jl .jump2040
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2040:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2041
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2041:
	; Computing bound for 'g'
	mov rax, [rel const399] ; 129
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2042
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2042:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2043
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump2044
.jump2043:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump2044:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2045
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2045:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	mov rax, [rel const191] ; 283
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2046
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2046:
	cmp rax, [rsp + 8]
	jl .jump2047
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2047:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2048
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2048:
	; Computing bound for 'g'
	mov rax, [rel const279] ; 378
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2049
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2049:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2050
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2050:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2051: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2052
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2052:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump2053: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2053 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2051 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2051 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2051 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2051 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2054
	mov rax, [rel const66] ; 552
	push rax
	jmp .jump2055
.jump2054:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const208] ; 324
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2056
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2056:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2057: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const193] ; 446
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2057 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2058
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump2058:
	cqo
	idiv r10
	mov rax, rdx
	push rax
.jump2055:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2059
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2059:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2060: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2061
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	jmp .jump2062
.jump2061:
	mov rax, [rel const8] ; True
	push rax
.jump2062:
	pop rax
	cmp rax, 0
	je .jump2063
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const477] ; 43
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2065
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2065:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2066
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2066:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2067
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2067:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump2068: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2068 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2068 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2068 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2069
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2069:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[i : f, j : f, k : 43] g) 
	jno .jump2070
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2070:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump2071: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2072
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2072:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2073
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2073:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2074
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2074:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump2075
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2075:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump2076
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2076:
	imul rdi, [rsp + 0 + 16] ; multiply by f 
	jno .jump2077
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2077:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump2078: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2078 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2078 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2078 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2071 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2079
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2079:
	cmp rax, [rsp + 8]
	jl .jump2080
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2080:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump2064
.jump2063:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2081
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2081:
	; Computing bound for 'k'
	mov rax, [rel const478] ; 856
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2082
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2082:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2083
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2083:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2084
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2084:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump2085
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2085:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump2086
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2086:
	imul rdi, [rsp + 0 + 16] ; multiply by 856 
	jno .jump2087
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2087:
	imul rdi, [rsp + 0 + 24] ; multiply by g 
	jno .jump2088
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2088:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump2089: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const94] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2089 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2089 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2089 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2089 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const85] ; 178
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const479] ; 572
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2090
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2090:
	cmp rax, [rsp + 32]
	jl .jump2091
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2091:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2092
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2092:
	cmp rax, [rsp + 40]
	jl .jump2093
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2093:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2094
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2094:
	cmp rax, [rsp + 48]
	jl .jump2095
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2095:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2096
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2096:
	cmp rax, [rsp + 56]
	jl .jump2097
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2097:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2098
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2100
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2100:
	; Computing bound for 'j'
	mov rax, [rel const413] ; 681
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2101
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump2101:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2102
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2102:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2103
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2103:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump2104
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2104:
	imul rdi, [rsp + 0 + 8] ; multiply by (h % 681) 
	jno .jump2105
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2105:
	imul rdi, [rsp + 0 + 16] ; multiply by f 
	jno .jump2106
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2106:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump2107: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const388] ; 195
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2107 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2107 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2107 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump2099
.jump2098:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2108
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2108:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2109
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2109:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2110
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2110:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump2111
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2111:
	imul rdi, [rsp + 0 + 8] ; multiply by (- h) 
	jno .jump2112
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2112:
	imul rdi, [rsp + 0 + 16] ; multiply by (f * g) 
	jno .jump2113
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2113:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump2114: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2114 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2114 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2114 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump2099:
.jump2064:
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const421] ; 486
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2115
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2115:
	cmp rax, [rsp + 24]
	jl .jump2116
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2116:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2117
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2117:
	cmp rax, [rsp + 32]
	jl .jump2118
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2118:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2119
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2119:
	cmp rax, [rsp + 40]
	jl .jump2120
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2120:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2060 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2060 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2060 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump1961:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2121
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2121:
	cmp rax, [rsp + 24]
	jl .jump2122
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2122:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2123
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2123:
	cmp rax, [rsp + 32]
	jl .jump2124
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2124:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2125
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2125:
	cmp rax, [rsp + 40]
	jl .jump2126
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2126:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	lea rdi, [rel const480] ; 'f.png'
	call _write_image
	add rsp, 24
	add rsp, 8 ; Remove alignment
	sub rsp, 8 ; Add alignment
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const481] ; 82.03
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2127
	mov rax, [rel const94] ; False
	push rax
	pop rax
.jump2127:
	push rax
	pop rax
	cmp rax, 0
	je .jump2128
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	jmp .jump2129
.jump2128:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const482] ; 97.32
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2130
	mov rax, [rel const94] ; False
	push rax
	pop rax
.jump2130:
	push rax
.jump2129:
	pop rax
	cmp rax, 0
	je .jump2131
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2133
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump2134
.jump2133:
	mov rax, [rel const483] ; 48.62
	push rax
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
.jump2134:
	jmp .jump2132
.jump2131:
	mov rax, [rel const484] ; 44.4
	push rax
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2135
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump2136
.jump2135:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump2136:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
.jump2132:
	pop rax
	cmp rax, 0
	je .jump2137
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2139
	mov rax, [rel const485] ; 94.85
	push rax
	jmp .jump2140
.jump2139:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump2140:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	jmp .jump2138
.jump2137:
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const486] ; 24.81
	push rax
	mov rax, [rel const487] ; 45.75
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const488] ; 11.68
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const489] ; 77.43
	push rax
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump2138:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2141
	mov rax, [rel const26] ; 312
	push rax
	mov rax, [rel const268] ; 952
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2142
	mov rax, [rel const490] ; 22.54
	push rax
	jmp .jump2143
.jump2142:
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
.jump2143:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2144
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2144:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump2145
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2145:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2146: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2146 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2147
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2147:
	cmp rax, [rsp + 8]
	jl .jump2148
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2148:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	mov rax, [rel const307] ; 59
	push rax
	mov rax, [rel const491] ; 29
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2149
	mov rax, [rel const8] ; True
	push rax
	jmp .jump2150
.jump2149:
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
.jump2150:
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2151
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const492] ; 661
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2153
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2153:
	; Computing bound for 'h'
	mov rax, [rel const351] ; 834
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2154
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2154:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2155
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2155:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const493] ; 658
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2156
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2156:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2157: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2157 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2158
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2158:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const460] ; 709
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2159
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2159:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2160
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2160:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2161: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const353] ; 571
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2161 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2161 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2162
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2162:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2163: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const410] ; 235
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2163 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2164
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2164:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2165: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const8] ; True
	push rax
	mov rax, [rel const8] ; True
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2166
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	jmp .jump2167
.jump2166:
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump2167:
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2165 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2165 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2165 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2165 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	neg rax
	push rax
	jmp .jump2152
.jump2151:
	mov rax, [rel const494] ; 713
	push rax
.jump2152:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const495] ; 868
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2168
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2168:
	; Computing bound for 'g'
	mov rax, [rel const496] ; 274
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2169
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2169:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2170
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2170:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2171: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const182] ; 719
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2171 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2171 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2171 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const91] ; 696
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2172
	mov rax, [rel const94] ; False
	push rax
	pop rax
.jump2172:
	push rax
	mov rax, [rel const497] ; 2.88
	push rax
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump2173
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
.jump2173:
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2174
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump2175
.jump2174:
	mov rax, [rel const409] ; 617
	push rax
.jump2175:
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
.jump2141:
	push rax
	pop rax
	cmp rax, 0
	je .jump2176
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2178
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const498] ; 815
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2180
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2180:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2181: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2182
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump2183
.jump2182:
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
.jump2183:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2181 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2184
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2184:
	; Computing bound for 'h'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2185
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2187
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2187:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const499] ; 982
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2188
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2188:
	; Computing bound for 'f'
	mov rax, [rel const5] ; 18
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2189
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2189:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 18) 
	jno .jump2190
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2190:
	imul rdi, [rsp + 0 + 8] ; multiply by (982 - b) 
	jno .jump2191
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2191:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump2192
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2192:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2193: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const500] ; 780
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2193 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2193 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2193 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump2186
.jump2185:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2194
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2194:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2195
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2195:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2196
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2196:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump2197
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2197:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump2198
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2198:
	imul rdi, [rsp + 0 + 16] ; multiply by (- b) 
	jno .jump2199
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2199:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2200: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2201
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2201:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2202
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2202:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2203
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2203:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump2204: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2204 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2204 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2204 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2200 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2200 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2200 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump2186:
	mov rax, [rel const501] ; 327
	push rax
	mov rax, [rel const502] ; 844
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2205
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump2206
.jump2205:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump2206:
	mov rax, [rel const503] ; 776
	push rax
	mov rax, [rel const245] ; 825
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2207
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2207:
	cmp rax, [rsp + 24]
	jl .jump2208
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2208:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2209
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2209:
	cmp rax, [rsp + 32]
	jl .jump2210
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2210:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2211
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2211:
	cmp rax, [rsp + 40]
	jl .jump2212
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2212:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2213
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2213:
	; Computing bound for 'g'
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const504] ; 232
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2214
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2214:
	cmp rax, [rsp + 8]
	jl .jump2215
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2215:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2216
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2216:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const142] ; 72
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2217
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2217:
	; Computing bound for 'h'
	mov rax, [rel const505] ; 393
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2218
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2218:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2219
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2219:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2220
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2220:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2221: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2221 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2221 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2221 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2221 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2222
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2222:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2223
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2223:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2224
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2224:
	; Computing bound for 'f'
	mov rax, [rel const47] ; 650
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2225
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2225:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2226: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2226 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2226 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2226 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2227
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2227:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2228: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2228 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2229
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2229:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[f : (sum[f : (- (- 650)), g : b, h : (b % (sum[f : b, g : b, h : 393, i : 72] b))] h)] f) 
	jno .jump2230
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2230:
	imul rdi, [rsp + 0 + 8] ; multiply by (b * a[(- 232)]) 
	jno .jump2231
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2231:
imul rdi, [rsp + 0 + 16] ; multiply by (if (! true) then (array[f : (- 18), g : (982 - b), h : b] (g - 780)) else (array[f : b, g : b, h : (- b)] (sum[i : b, j : f, k : f] f)))[(- 825), 776, (if ((- 844) <= 327) then (- (- b)) else b)] 
	jno .jump2232
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2232:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[f : 815] (b + (if (! true) then (- b) else f))) 
	jno .jump2233
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2233:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2234: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const98] ; 710
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2235
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2235:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2236
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2236:
	; Computing bound for 'j'
	mov rax, [rel const292] ; 23
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2237
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2237:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by 23 
	jno .jump2238
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2238:
	imul rdi, [rsp + 0 + 8] ; multiply by (f % 710) 
	jno .jump2239
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2239:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump2240: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2241
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2243
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2243:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2244
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2244:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2245
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2245:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump2246
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2246:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump2247
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2247:
	imul rdi, [rsp + 0 + 16] ; multiply by f 
	jno .jump2248
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2248:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump2249: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2249 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2249 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2249 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump2242
.jump2241:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const506] ; 257
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2250
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2250:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2251
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2251:
	; Computing bound for 'l'
	mov rax, [rel const507] ; 621
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2252
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2252:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by 621 
	jno .jump2253
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2253:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump2254
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2254:
	imul rdi, [rsp + 0 + 16] ; multiply by 257 
	jno .jump2255
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2255:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump2256: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2256 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2256 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2256 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump2242:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2257
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2257:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump2258: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2259
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2259:
	cmp rax, [rsp + 8]
	jl .jump2260
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2260:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2258 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const508] ; 61.55
	push rax
	mov rax, [rel const509] ; 50.13
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2261
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	jmp .jump2262
.jump2261:
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
.jump2262:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2263
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2263:
	cmp rax, [rsp + 24]
	jl .jump2264
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2264:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2265
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2265:
	cmp rax, [rsp + 32]
	jl .jump2266
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2266:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2267
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2267:
	cmp rax, [rsp + 40]
	jl .jump2268
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2268:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2240 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2240 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2234 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2234 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2234 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2234 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2269
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2269:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2270
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2270:
	; Computing bound for 'f'
	mov rax, [rel const510] ; 98
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2271
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2271:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2272: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const511] ; 55
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2272 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2272 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2273
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2273:
	; Computing bound for 'g'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2274
	mov rax, [rel const512] ; 120
	push rax
	jmp .jump2275
.jump2274:
	mov rax, [rel const194] ; 51
	push rax
.jump2275:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2276
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2276:
	; Computing bound for 'f'
	mov rax, [rel const513] ; 421
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2277
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2277:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2278: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2278 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2278 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2278 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2279
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump2279:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2280
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2280:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2281
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2281:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const514] ; 862
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2282
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2282:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2283: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2283 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2284
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2284:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2285: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const515] ; 521
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2285 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2285 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2285 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2285 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const516] ; 381
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2286
	mov rax, [rel const94] ; False
	push rax
	jmp .jump2287
.jump2286:
	mov rax, [rel const8] ; True
	push rax
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2288
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2288:
	cmp rax, [rsp + 8]
	jl .jump2289
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2289:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2287:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2290
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2292
	mov rax, [rel const517] ; 39
	push rax
	jmp .jump2293
.jump2292:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2294
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2294:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2295
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2295:
	; Computing bound for 'g'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2296
	mov rax, [rel const518] ; 545
	push rax
	jmp .jump2297
.jump2296:
	mov rax, [rel const519] ; 529
	push rax
.jump2297:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2298
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2298:
	; Computing bound for 'f'
	mov rax, [rel const520] ; 792
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2299
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2299:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2300: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const521] ; 928
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2300 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2300 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2300 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2300 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
.jump2293:
	jmp .jump2291
.jump2290:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2301
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2301:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2302: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2303
	mov rax, [rel const522] ; 733
	push rax
	jmp .jump2304
.jump2303:
	mov rax, [rel const523] ; 99
	push rax
.jump2304:
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2302 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
.jump2291:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2305
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2305:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2306
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2306:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2307
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2307:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2308: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2308 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2308 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2308 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const524] ; 93.97
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2309
	mov rax, [rel const8] ; True
	push rax
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2311
	mov rax, [rel const438] ; 73
	push rax
	jmp .jump2312
.jump2311:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const525] ; 771
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2313
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2313:
	; Computing bound for 'f'
	mov rax, [rel const178] ; 614
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2314
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2314:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2315: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2315 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2315 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump2312:
	jmp .jump2310
.jump2309:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2316
	mov rax, [rel const526] ; 864
	push rax
	jmp .jump2317
.jump2316:
	mov rax, [rel const527] ; 30
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
.jump2317:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2318
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2318:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2319: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2320
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2320:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2321
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2321:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2322
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2322:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2323: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const528] ; 829
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2323 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2323 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2323 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2319 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump2310:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2324
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2324:
	; Computing bound for 'g'
	mov rax, [rel const529] ; 541
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2325
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2325:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const278] ; 68
	push rax
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2326
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2326:
	cmp rax, [rsp + 8]
	jl .jump2327
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2327:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2328
	mov rax, [rel const530] ; 818
	push rax
	jmp .jump2329
.jump2328:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump2329:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2330
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2330:
	; Computing bound for 'f'
	mov rax, [rel const521] ; 928
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2331
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2331:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2332: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2333
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2333:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2334
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2334:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump2335: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2335 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2335 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2332 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2332 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2336
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2336:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2337: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2338
	mov rax, [rel const531] ; 56.3
	push rax
	mov rax, [rel const532] ; 53.62
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
.jump2338:
	push rax
	pop rax
	cmp rax, 0
	je .jump2339
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	jmp .jump2340
.jump2339:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump2340:
	mov rax, [rel const533] ; 58
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2337 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2337 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2337 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2341
	mov rax, [rel const534] ; 43.51
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const535] ; 788
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2343
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2343:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2344: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2344 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	jmp .jump2342
.jump2341:
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
.jump2342:
	pop rax
	cmp rax, 0
	je .jump2345
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const536] ; 247
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2347
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump2347:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2348
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2348:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2349
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2349:
	; Computing bound for 'g'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2350
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump2351
.jump2350:
	mov rax, [rel const537] ; 217
	push rax
.jump2351:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2352
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2352:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2353
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2353:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2354: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2354 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2354 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2354 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2354 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const29] ; 467
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2355
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump2355:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2356
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump2357
.jump2356:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump2357:
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	jmp .jump2346
.jump2345:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const506] ; 257
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2358
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2358:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2359
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2359:
	; Computing bound for 'f'
	mov rax, [rel const538] ; 416
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2360
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2360:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2361: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2361 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2361 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2361 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2362
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2362:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2363: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const539] ; 85.87
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2364
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump2365
.jump2364:
	mov rax, [rel const540] ; 616
	push rax
.jump2365:
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2363 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2366
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2366:
	cqo
	idiv r10
	push rax
.jump2346:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2367
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2367:
	cmp rax, [rsp + 32]
	jl .jump2368
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2368:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2369
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2369:
	cmp rax, [rsp + 40]
	jl .jump2370
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2370:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2371
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2371:
	cmp rax, [rsp + 48]
	jl .jump2372
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2372:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2373
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2373:
	cmp rax, [rsp + 56]
	jl .jump2374
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2374:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump2179
.jump2178:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2375
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2375:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const369] ; 885
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2376
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2376:
	; Computing bound for 'h'
	mov rax, [rel const48] ; 695
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2377
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2377:
	; Computing bound for 'g'
	mov rax, [rel const230] ; 991
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2378
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2378:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2379
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2379:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2380: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2381
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2381:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump2382: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2382 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2380 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2380 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2380 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2380 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2383
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2383:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2384
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2384:
	; Computing bound for 'f'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2385
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const541] ; 861
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2387
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2387:
	; Computing bound for 'f'
	mov rax, [rel const474] ; 662
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2388
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2388:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2389: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2389 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2389 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump2386
.jump2385:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump2386:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2390
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2390:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (if true then (sum[f : 662, g : 861] f) else (- b)) 
	jno .jump2391
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2391:
	imul rdi, [rsp + 0 + 8] ; multiply by (- b) 
	jno .jump2392
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2392:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[f : b, g : 991, h : 695, i : 885] (sum[j : f] g)) 
	jno .jump2393
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2393:
	imul rdi, [rsp + 0 + 24] ; multiply by (- (- b)) 
	jno .jump2394
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2394:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2395: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2395 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2395 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2395 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2395 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const404] ; 496
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2396
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2396:
	cqo
	idiv r10
	push rax
	mov rax, [rel const71] ; 216
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const542] ; 687
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const543] ; 15.44
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2397
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump2398
.jump2397:
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const544] ; 880
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2399
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2399:
	cmp rax, [rsp + 8]
	jl .jump2400
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2400:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2398:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2401
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2401:
	cmp rax, [rsp + 32]
	jl .jump2402
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2402:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2403
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2403:
	cmp rax, [rsp + 40]
	jl .jump2404
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2404:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2405
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2405:
	cmp rax, [rsp + 48]
	jl .jump2406
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2406:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2407
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2407:
	cmp rax, [rsp + 56]
	jl .jump2408
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2408:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2409
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2409:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
imul rdi, [rsp + 0 + 0] ; multiply by (array[f : (if true then (sum[f : 662, g : 861] f) else (- b)), g : (- b), h : (sum[f : b, g : 991, h : 695, i : 885] (sum[j : f] g)), i : (- (- b))] i)[(if ((- 15.44) != c) then b else a[(- 880)]), 687, (b + 216), ((- b) / (- 496))] 
	jno .jump2410
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2410:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2411: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const45] ; 384
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2412
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2412:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2413
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2413:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2414
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2414:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2415
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2415:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2416
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2416:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2417: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2417 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2417 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2417 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2417 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2418
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2418:
	cmp rax, [rsp + 8]
	jl .jump2419
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2419:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2420
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2420:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2421
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2421:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2422: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2422 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2422 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2423
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const545] ; 729
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2425
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2425:
	; Computing bound for 'g'
	mov rax, [rel const546] ; 63
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2426
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2426:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 63 
	jno .jump2427
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2427:
	imul rdi, [rsp + 0 + 8] ; multiply by 729 
	jno .jump2428
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2428:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2429: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const8] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2429 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2429 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2430
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2430:
	cmp rax, [rsp + 16]
	jl .jump2431
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2431:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2432
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2432:
	cmp rax, [rsp + 24]
	jl .jump2433
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2433:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2434
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2436
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2438
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2438:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2439
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2439:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump2440
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2440:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump2441
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2441:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2442: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2442 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2442 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump2437
.jump2436:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2443
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2443:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2444
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2444:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump2445
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2445:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump2446
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2446:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2447: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2447 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2447 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump2437:
	jmp .jump2435
.jump2434:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2448
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2448:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2449
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2449:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2450
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2450:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2451: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2451 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2451 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2452
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2452:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[g : b, h : b] f) 
	jno .jump2453
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2453:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump2454
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2454:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2455: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2455 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2455 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump2435:
	jmp .jump2424
.jump2423:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2456
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2456:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2457
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2457:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump2458
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2458:
	imul rdi, [rsp + 0 + 8] ; multiply by (- f) 
	jno .jump2459
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2459:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2460: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2461
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	jmp .jump2462
.jump2461:
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
.jump2462:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2460 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2460 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump2424:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2411 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const208] ; 324
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2463
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2463:
	cmp rax, [rsp + 8]
	jl .jump2464
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2464:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2179:
	jmp .jump2177
.jump2176:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const547] ; 81
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2465
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2465:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2466
	mov rax, [rel const94] ; False
	push rax
	jmp .jump2467
.jump2466:
	mov rax, [rel const94] ; False
	push rax
.jump2467:
	pop rax
	cmp rax, 0
	je .jump2468
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const548] ; 304
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2470
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2470:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2471
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2471:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const280] ; 326
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2472
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2472:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2473
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2473:
	; Computing bound for 'f'
	mov rax, [rel const290] ; 804
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2474
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2474:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2475: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2475 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2475 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2475 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2476
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2476:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[f : 804, g : b, h : 326] h) 
	jno .jump2477
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2477:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump2478
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2478:
	imul rdi, [rsp + 0 + 16] ; multiply by 304 
	jno .jump2479
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2479:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2480: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const184] ; 147
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2480 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2480 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2480 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump2469
.jump2468:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2481
	mov rax, [rel const447] ; 692
	push rax
	jmp .jump2482
.jump2481:
	mov rax, [rel const549] ; 351
	push rax
.jump2482:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2483
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2483:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2484
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2484:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2485
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2485:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2486: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2486 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2487
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2487:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[f : b] b) 
	jno .jump2488
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2488:
	imul rdi, [rsp + 0 + 8] ; multiply by (- b) 
	jno .jump2489
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2489:
	imul rdi, [rsp + 0 + 16] ; multiply by (if true then 692 else 351) 
	jno .jump2490
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2490:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2491: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const440] ; 5
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2491 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2491 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2491 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump2469:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const550] ; 266
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2492
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2492:
	; Computing bound for 'g'
	mov rax, [rel const150] ; 301
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2493
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2493:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2494
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2494:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump2495
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2495:
	imul rdi, [rsp + 0 + 8] ; multiply by 301 
	jno .jump2496
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2496:
	imul rdi, [rsp + 0 + 16] ; multiply by 266 
	jno .jump2497
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2497:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2498: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2498 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2498 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2498 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const551] ; 208
	push rax
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2499
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2499:
	cmp rax, [rsp + 8]
	jl .jump2500
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2500:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const275] ; 553
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2501
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2501:
	cmp rax, [rsp + 24]
	jl .jump2502
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2502:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2503
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2503:
	cmp rax, [rsp + 32]
	jl .jump2504
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2504:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2505
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2505:
	cmp rax, [rsp + 40]
	jl .jump2506
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2506:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2507
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump2507:
	cqo
	idiv r10
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2508
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2508:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump2509
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2509:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2510: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const408] ; 797
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2510 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2511
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2511:
	cmp rax, [rsp + 8]
	jl .jump2512
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2512:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2513
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2513:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2514
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2514:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2515: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2515 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2515 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2516
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2516:
	cmp rax, [rsp + 24]
	jl .jump2517
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2517:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2518
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2518:
	cmp rax, [rsp + 32]
	jl .jump2519
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2519:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2520
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2520:
	cmp rax, [rsp + 40]
	jl .jump2521
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2521:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2522
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2522:
	; Computing bound for 'g'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2523
	mov rax, [rel const552] ; 404
	push rax
	jmp .jump2524
.jump2523:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2525
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2525:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2526
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2526:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump2527
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2527:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump2528
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2528:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2529: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2529 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2529 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const553] ; 339
	push rax
	mov rax, [rel const475] ; 728
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2530
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2530:
	cmp rax, [rsp + 16]
	jl .jump2531
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2531:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2532
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2532:
	cmp rax, [rsp + 24]
	jl .jump2533
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2533:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump2524:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2534
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2534:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const554] ; 368
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2535
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const538] ; 416
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2537
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2537:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2538
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2538:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2539: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const88] ; 474
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2539 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2539 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump2536
.jump2535:
	mov rax, [rel const555] ; 300
	push rax
.jump2536:
	mov rax, [rel const515] ; 521
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2540
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2540:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2541
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2541:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by ((521 + (if (b != 368) then (sum[f : b, g : 416] 474) else 300)) % b) 
	jno .jump2542
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2542:
imul rdi, [rsp + 0 + 8] ; multiply by (if (! (! true)) then 404 else (- (array[f : b, g : b] b)[728, 339])) 
	jno .jump2543
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2543:
imul rdi, [rsp + 0 + 16] ; multiply by (if (if (b != b) then false else false) then (array[f : (sum[f : 804, g : b, h : 326] h), g : b, h : 304] 147) else (array[f : (sum[f : b] b), g : (- b), h : (if true then 692 else 351)] 5))[(sum[f : (- b), g : (array[f : b] 797)[b]] (- b)), ((array[f : b, g : 301, h : 266] b)[553, a[b], 208] / b), (b * b)] 
	jno .jump2544
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2544:
	imul rdi, [rsp + 0 + 24] ; multiply by 81 
	jno .jump2545
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2545:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2546: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const556] ; 756
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2547
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2547:
	; Computing bound for 'k'
	mov rax, [rel const557] ; 717
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2548
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2548:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2549
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2549:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump2550
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2550:
	imul rdi, [rsp + 0 + 8] ; multiply by 717 
	jno .jump2551
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2551:
	imul rdi, [rsp + 0 + 16] ; multiply by 756 
	jno .jump2552
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2552:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump2553: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const8] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 16], 1
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2553 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2553 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2553 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2554
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2554:
	; Computing bound for 'l'
	mov rax, [rel const538] ; 416
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2555
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2555:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2556
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2556:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2557
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2557:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump2558: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2558 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2558 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2558 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2558 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2559
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2559:
	cmp rax, [rsp + 24]
	jl .jump2560
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2560:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2561
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2561:
	cmp rax, [rsp + 32]
	jl .jump2562
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2562:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2563
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2563:
	cmp rax, [rsp + 40]
	jl .jump2564
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2564:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2565
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump2566
.jump2565:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2567
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2567:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2568
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2568:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump2569
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2569:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump2570
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2570:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump2571: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const94] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2571 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2571 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2572
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2572:
	cmp rax, [rsp + 16]
	jl .jump2573
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2573:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2574
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2574:
	cmp rax, [rsp + 24]
	jl .jump2575
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2575:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2576
	mov rax, [rel const558] ; 56.47
	push rax
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2578
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump2579
.jump2578:
	mov rax, [rel const559] ; 24.35
	push rax
.jump2579:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	jmp .jump2577
.jump2576:
	mov rax, [rel const560] ; 72.51
	push rax
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
.jump2577:
.jump2566:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2546 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2546 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2546 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2546 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2580
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2580:
	cmp rax, [rsp + 8]
	jl .jump2581
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2581:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2582
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2582:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const561] ; 14
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2583
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2583:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2584
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2584:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2585: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2585 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2585 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2586
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2586:
	; Computing bound for 'g'
	mov rax, [rel const402] ; 630
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2587
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2587:
	; Computing bound for 'f'
	mov rax, [rel const452] ; 93
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2588
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump2589
.jump2588:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump2589:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2590
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2590:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if (b == 93) then b else b) 
	jno .jump2591
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2591:
	imul rdi, [rsp + 0 + 8] ; multiply by (- (- 630)) 
	jno .jump2592
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2592:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[f : b, g : (14 - b)] g) 
	jno .jump2593
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2593:
	imul rdi, [rsp + 0 + 24] ; multiply by a[b] 
	jno .jump2594
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2594:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2595: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2595 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2595 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2595 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2595 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const452] ; 93
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const562] ; 752
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2596
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2596:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const113] ; 161
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2597
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2597:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2598
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2598:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2599: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const563] ; 598
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2599 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2599 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2599 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const564] ; 773
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2600
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2600:
	cmp rax, [rsp + 32]
	jl .jump2601
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2601:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2602
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2602:
	cmp rax, [rsp + 40]
	jl .jump2603
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2603:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2604
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2604:
	cmp rax, [rsp + 48]
	jl .jump2605
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2605:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2606
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2606:
	cmp rax, [rsp + 56]
	jl .jump2607
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2607:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const542] ; 687
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2608
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2608:
	; Computing bound for 'g'
	mov rax, [rel const142] ; 72
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2609
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2609:
	; Computing bound for 'f'
	mov rax, [rel const565] ; 795
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2610
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2610:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2611: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2611 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2611 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2611 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rel const8] ; True
	push rax
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const556] ; 756
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2612
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2612:
	cmp rax, [rsp + 8]
	jl .jump2613
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2613:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2614
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2614:
	cmp rax, [rsp + 8]
	jl .jump2615
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2615:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2616
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2618
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump2619
.jump2618:
	mov rax, [rel const566] ; 517
	push rax
.jump2619:
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2620
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump2620:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	jmp .jump2617
.jump2616:
	mov rax, [rel const567] ; 314
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2621
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump2621:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
.jump2617:
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const568] ; 456
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2622
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump2622:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2623
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const86] ; 575
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	jmp .jump2624
.jump2623:
	mov rax, [rel const8] ; True
	push rax
.jump2624:
	pop rax
	cmp rax, 0
	je .jump2625
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump2626
.jump2625:
	mov rax, [rel const125] ; 504
	push rax
.jump2626:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2627
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2627:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2628
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2628:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2629: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const569] ; 204
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2629 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2629 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2630
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump2630:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2631
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2631:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2632: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2633
	mov rax, [rel const570] ; 202
	push rax
	jmp .jump2634
.jump2633:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const571] ; 348
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2635
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2637
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump2638
.jump2637:
	mov rax, [rel const390] ; 516
	push rax
.jump2638:
	mov rax, [rel const457] ; 555
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2639
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump2639:
	cqo
	idiv r10
	push rax
	jmp .jump2636
.jump2635:
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2640
	mov rax, [rel const217] ; 830
	push rax
	jmp .jump2641
.jump2640:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const84] ; 299
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2642
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2642:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2643: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const141] ; 398
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2643 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump2641:
.jump2636:
.jump2634:
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2632 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2644
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2644:
	cmp rax, [rsp + 32]
	jl .jump2645
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2645:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2646
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2646:
	cmp rax, [rsp + 40]
	jl .jump2647
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2647:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2648
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2648:
	cmp rax, [rsp + 48]
	jl .jump2649
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2649:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2650
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2650:
	cmp rax, [rsp + 56]
	jl .jump2651
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2651:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2652
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const417] ; 957
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2654
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2654:
	; Computing bound for 'f'
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2655
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const190] ; 448
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2657
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2657:
	; Computing bound for 'g'
	mov rax, [rel const95] ; 513
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2658
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2658:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const572] ; 422
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2659
	mov rax, [rel const17] ; 252
	push rax
	jmp .jump2660
.jump2659:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump2660:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2661
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2661:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if (422 < b) then 252 else b) 
	jno .jump2662
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2662:
	imul rdi, [rsp + 0 + 8] ; multiply by (b - 513) 
	jno .jump2663
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2663:
	imul rdi, [rsp + 0 + 16] ; multiply by 448 
	jno .jump2664
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2664:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2665: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2666
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump2666:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rel const325] ; 346
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2665 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2665 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2665 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump2656
.jump2655:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2667
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2667:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2668
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2668:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2669
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2669:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- b) 
	jno .jump2670
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2670:
	imul rdi, [rsp + 0 + 8] ; multiply by (- b) 
	jno .jump2671
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2671:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump2672
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2672:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2673: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2673 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2673 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2673 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump2656:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2674
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2674:
	; Computing bound for 'f'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2675
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2677
	mov rax, [rel const573] ; 564
	push rax
	jmp .jump2678
.jump2677:
	mov rax, [rel const574] ; 321
	push rax
.jump2678:
	jmp .jump2676
.jump2675:
	mov rax, [rel const575] ; 7
	push rax
.jump2676:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2679
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2679:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2680: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2681
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2683
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	jmp .jump2684
.jump2683:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump2684:
	jmp .jump2682
.jump2681:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2685
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2685:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump2686: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const422] ; 810
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2686 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump2682:
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2680 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2680 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rel const576] ; 424
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const435] ; 114
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2687
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump2688
.jump2687:
	mov rax, [rel const577] ; 35.75
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2689
	mov rax, [rel const578] ; 992
	push rax
	mov rax, [rel const500] ; 780
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2691
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump2692
.jump2691:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2693
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump2693:
	cqo
	idiv r10
	mov rax, rdx
	push rax
.jump2692:
	jmp .jump2690
.jump2689:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2694
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2694:
	; Computing bound for 'g'
	mov rax, [rel const533] ; 58
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2695
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2695:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2696
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2696:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump2697
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2697:
	imul rdi, [rsp + 0 + 8] ; multiply by 58 
	jno .jump2698
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2698:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump2699
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2699:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2700: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2700 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2700 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2700 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const557] ; 717
	push rax
	mov rax, [rel const499] ; 982
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2701
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump2701:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2702
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2702:
	cmp rax, [rsp + 24]
	jl .jump2703
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2703:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2704
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2704:
	cmp rax, [rsp + 32]
	jl .jump2705
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2705:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2706
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2706:
	cmp rax, [rsp + 40]
	jl .jump2707
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2707:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2690:
.jump2688:
	mov rax, [rel const269] ; 472
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2708
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2708:
	cmp rax, [rsp + 24]
	jl .jump2709
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2709:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2710
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2710:
	cmp rax, [rsp + 32]
	jl .jump2711
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2711:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2712
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2712:
	cmp rax, [rsp + 40]
	jl .jump2713
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2713:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2714
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2714:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
imul rdi, [rsp + 0 + 0] ; multiply by (if (! (c == d.b)) then (array[f : (if (422 < b) then 252 else b), g : (b - 513), h : 448] (346 - (f % g))) else (array[f : (- b), g : (- b), h : b] g))[472, (if ((114 - b) != 424) then b else (if (e.a > (c / 35.75)) then (if (780 != 992) then (- b) else (b % b)) else (array[f : b, g : 58, h : b] g)[(b % b), (- 982), 717])), (- (sum[f : (if true then (if true then 564 else 321) else 7), g : b] (if (! false) then (if true then g else b) else (sum[h : g] 810))))] 
	jno .jump2715
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2715:
	imul rdi, [rsp + 0 + 8] ; multiply by 957 
	jno .jump2716
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2716:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2717: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2717 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2717 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump2653
.jump2652:
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2718
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const579] ; 751
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2720
	mov rax, [rel const580] ; 125
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump2721
.jump2720:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump2721:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2722
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2724
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump2725
.jump2724:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump2725:
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2726
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump2726:
	cqo
	idiv r10
	push rax
	jmp .jump2723
.jump2722:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump2723:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2727
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2727:
	; Computing bound for 'f'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const581] ; 908
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const34] ; 112
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2728
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2728:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (112 - (- 908)) 
	jno .jump2729
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2729:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2730: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2731
	mov rax, [rel const575] ; 7
	push rax
	jmp .jump2732
.jump2731:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump2732:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2733
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2733:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2734
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2734:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2735
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2735:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2736
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2736:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2737: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2737 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2737 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2737 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2737 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2730 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2738
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2738:
	cmp rax, [rsp + 8]
	jl .jump2739
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2739:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2740
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2740:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2741
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2741:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2742: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const582] ; 497
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2742 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2742 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2743
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2743:
	cmp rax, [rsp + 8]
	jl .jump2744
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2744:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2745
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2745:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
imul rdi, [rsp + 0 + 0] ; multiply by (array[f : (112 - (- 908))] (sum[g : f, h : f, i : (b * b), j : (if false then 7 else b)] f))[(sum[f : (- (- b)), g : a[b]] 497)] 
	jno .jump2746
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2746:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (b < (if (b == 751) then (- 125) else b)) then ((- (if true then b else b)) / (- (- b))) else b) 
	jno .jump2747
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2747:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2748: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2749
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump2750
.jump2749:
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
.jump2750:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2748 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2748 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump2719
.jump2718:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2751
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2751:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2752
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2752:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump2753
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2753:
	imul rdi, [rsp + 0 + 8] ; multiply by ((- (b + b)) + b) 
	jno .jump2754
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2754:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2755: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const583] ; 201
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2756
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2756:
	cmp rax, [rsp + 8]
	jl .jump2757
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2757:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2758
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2758:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2759
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2759:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by (- (- f)) 
	jno .jump2760
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2760:
	imul rdi, [rsp + 0 + 8] ; multiply by a[201] 
	jno .jump2761
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2761:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump2762: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2762 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2762 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2755 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2755 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const246] ; 231
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const584] ; 721
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2763
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2763:
	; Computing bound for 'f'
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2764
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2764:
	cmp rax, [rsp + 8]
	jl .jump2765
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2765:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2766
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2766:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2767: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2767 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2767 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2768
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2768:
	cmp rax, [rsp + 8]
	jl .jump2769
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2769:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2770
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2770:
	cmp rax, [rsp + 16]
	jl .jump2771
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2771:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2772
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2772:
	cmp rax, [rsp + 24]
	jl .jump2773
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2773:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2719:
.jump2653:
.jump2177:
	lea rdi, [rel const480] ; 'f.png'
	call _write_image
	add rsp, 24
	add rsp, 8 ; Remove alignment
	lea rdi, [rel const585] ; 'f'
	call _print
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2774
	mov rax, [rel const94] ; False
	push rax
	jmp .jump2775
.jump2774:
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
.jump2775:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2776
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2778
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2778:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2779
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2779:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2780: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2780 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2780 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const586] ; 97
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2781
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2781:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2782: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2782 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2783
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const190] ; 448
	push rax
	mov rax, [rel const270] ; 821
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2785
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2785:
	; Computing bound for 'f'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2786
	mov rax, [rel const26] ; 312
	push rax
	jmp .jump2787
.jump2786:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump2787:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2788
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2788:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2789: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const587] ; 722
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2790
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2790:
	cmp rax, [rsp + 8]
	jl .jump2791
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2791:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2789 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2789 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump2784
.jump2783:
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump2792
	mov rax, [rel const8] ; True
	push rax
	pop rax
.jump2792:
	push rax
	pop rax
	cmp rax, 0
	je .jump2793
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump2794
.jump2793:
	mov rax, [rel const588] ; 255
	push rax
.jump2794:
.jump2784:
	jmp .jump2777
.jump2776:
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2795
	mov rax, [rel const304] ; 940
	push rax
	jmp .jump2796
.jump2795:
	mov rax, [rel const589] ; 884
	push rax
.jump2796:
	pop rax
	neg rax
	push rax
.jump2777:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2797
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2797:
	; Computing bound for 'g'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2798
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2798:
	; Computing bound for 'g'
	mov rax, [rel const590] ; 222
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2799
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2799:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const110] ; 635
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2800
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2800:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (635 - b) 
	jno .jump2801
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2801:
	imul rdi, [rsp + 0 + 8] ; multiply by (- (- 222)) 
	jno .jump2802
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2802:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump2803
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2803:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2804: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2805
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2807
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2807:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2808
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2808:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2809
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2809:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2810
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2810:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump2811
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2811:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump2812
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2812:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump2813
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2813:
	imul rdi, [rsp + 0 + 24] ; multiply by g 
	jno .jump2814
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2814:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump2815: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2815 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2815 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2815 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2815 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump2806
.jump2805:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2816
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2816:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2817
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2817:
	; Computing bound for 'j'
	mov rax, [rel const591] ; 808
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2818
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2818:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2819
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2819:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump2820
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2820:
	imul rdi, [rsp + 0 + 8] ; multiply by 808 
	jno .jump2821
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2821:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump2822
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2822:
	imul rdi, [rsp + 0 + 24] ; multiply by f 
	jno .jump2823
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2823:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump2824: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2824 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2824 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2824 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2824 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump2806:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2804 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2804 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2804 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const592] ; 934
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2825
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2825:
	cmp rax, [rsp + 24]
	jl .jump2826
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2826:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2827
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2827:
	cmp rax, [rsp + 32]
	jl .jump2828
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2828:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2829
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2829:
	cmp rax, [rsp + 40]
	jl .jump2830
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2830:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2831
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2831:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2832
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2832:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2833: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2833 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2834
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2834:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const63] ; 220
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2835
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2835:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2836
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2836:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump2837
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2837:
	imul rdi, [rsp + 0 + 8] ; multiply by (220 - b) 
	jno .jump2838
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2838:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[f : b] b) 
	jno .jump2839
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2839:
	imul rdi, [rsp + 0 + 24] ; multiply by b 
	jno .jump2840
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2840:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2841: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2842
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2842:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2843
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2843:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2844
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2844:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2845
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2845:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump2846
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2846:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump2847
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2847:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump2848
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2848:
	imul rdi, [rsp + 0 + 24] ; multiply by i 
	jno .jump2849
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2849:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump2850: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const593] ; 435
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2850 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2850 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2850 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2850 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2841 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2841 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2841 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2841 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const594] ; 512
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const595] ; 768
	push rax
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2851
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump2852
.jump2851:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump2852:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2853
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2853:
	cmp rax, [rsp + 32]
	jl .jump2854
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2854:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2855
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2855:
	cmp rax, [rsp + 40]
	jl .jump2856
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2856:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2857
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2857:
	cmp rax, [rsp + 48]
	jl .jump2858
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2858:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2859
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2859:
	cmp rax, [rsp + 56]
	jl .jump2860
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2860:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const475] ; 728
	push rax
	mov rax, [rel const239] ; 391
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rel const274] ; 737
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2861
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2861:
	; Computing bound for 'g'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const270] ; 821
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2862
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2862:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 821 
	jno .jump2863
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2863:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2864: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2864 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2865
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2865:
	cmp rax, [rsp + 8]
	jl .jump2866
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2866:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2867
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2867:
	; Computing bound for 'f'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2868
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump2869
.jump2868:
	mov rax, [rel const596] ; 519
	push rax
.jump2869:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2870
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2870:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2871: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump2872
	mov rax, [rel const8] ; True
	push rax
	pop rax
.jump2872:
	push rax
	pop rax
	cmp rax, 0
	je .jump2873
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	jmp .jump2874
.jump2873:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump2874:
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2871 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2871 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2871 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2875
	mov rax, [rel const94] ; False
	push rax
	jmp .jump2876
.jump2875:
	mov rax, [rel const8] ; True
	push rax
.jump2876:
	pop rax
	cmp rax, 0
	je .jump2877
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump2878
.jump2877:
	mov rax, [rel const597] ; 328
	push rax
.jump2878:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2879
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2879:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2880: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2880 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2881
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2881:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2882
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2882:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2883: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2884
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2884:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2885
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2885:
	; Computing bound for 'h'
	mov rax, [rel const598] ; 976
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2886
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2886:
	; Computing bound for 'g'
	mov rax, [rel const599] ; 878
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2887
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2887:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2888: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2888 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2888 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2888 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2888 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2883 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2889
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2889:
	; Computing bound for 'g'
	mov rax, [rel const506] ; 257
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2890
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2890:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2891
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2891:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2892: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 296 to rsp 
		mov r10, [rbp - 296 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2893
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2893:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 304 to rsp 
		mov r10, [rbp - 304 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2894
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2894:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump2895: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2896
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump2896:
	cqo
	idiv r10
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2895 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2895 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2892 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2892 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2892 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2892 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2897
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2897:
	cmp rax, [rsp + 32]
	jl .jump2898
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2898:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2899
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2899:
	cmp rax, [rsp + 40]
	jl .jump2900
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2900:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2901
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2901:
	cmp rax, [rsp + 48]
	jl .jump2902
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2902:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2903
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2903:
	cmp rax, [rsp + 56]
	jl .jump2904
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2904:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const522] ; 733
	push rax
	mov rax, [rel const600] ; 342
	push rax
	mov rax, [rel const33] ; 219
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2905
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2905:
	cmp rax, [rsp + 32]
	jl .jump2906
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2906:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2907
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2907:
	cmp rax, [rsp + 40]
	jl .jump2908
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2908:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2909
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2909:
	cmp rax, [rsp + 48]
	jl .jump2910
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2910:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2911
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump2911:
	cmp rax, [rsp + 56]
	jl .jump2912
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump2912:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2913
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2913:
	; Computing bound for 'f'
	mov rax, [rel const350] ; 506
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2914
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2914:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 506 
	jno .jump2915
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2915:
imul rdi, [rsp + 0 + 8] ; multiply by (array[f : (635 - b), g : (- (- 222)), h : b] (if (! true) then (array[i : b, j : h, k : h, l : g] h) else (array[i : f, j : 808, k : g, l : f] b)))[(- b), 934, b][219, 342, 733, (array[f : b, g : (220 - b), h : (sum[f : b] b), i : b] (array[j : f, k : h, l : b, m : i] 435))[(if false then b else b), 768, b, 512][(sum[f : b, g : (- 257), h : (sum[f : b] (sum[g : 878, h : 976, i : f, j : b] b)), i : (sum[f : (- b)] b)] (sum[j : g, k : (- h)] (i / i))), (if (if (! false) then false else true) then b else 328), b, (sum[f : (if (! true) then b else 519), g : (array[f : 821] b)[b], h : ((- 737) - (391 - 728))] (if (false || true) then f else b))]] 
	jno .jump2916
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2916:
imul rdi, [rsp + 0 + 16] ; multiply by (- (if (! (if true then false else (! false))) then (if ((sum[f : 97] b) >= (sum[f : b, g : b] g)) then (sum[f : (if true then 312 else b), g : (821 + 448)] a[722]) else (if (true || true) then b else 255)) else (- (if true then 940 else 884)))) 
	jno .jump2917
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2917:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump2918: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2919
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2921
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2921:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2922
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2922:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2923
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2923:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump2924: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2924 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2924 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2924 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2925
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2925:
	; Computing bound for 'i'
	mov rax, [rel const601] ; 395
	push rax
	mov rax, [rel const223] ; 184
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2926
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2926:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (184 + 395) 
	jno .jump2927
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2927:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[i : h, j : h, k : f] g) 
	jno .jump2928
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2928:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump2929: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2930
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2930:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2931
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2931:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2932
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2932:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2933
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2933:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump2934
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2934:
	imul rdi, [rsp + 0 + 8] ; multiply by j 
	jno .jump2935
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2935:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump2936
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2936:
	imul rdi, [rsp + 0 + 24] ; multiply by b 
	jno .jump2937
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2937:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump2938: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 24], 1
	; Compare n to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2938 ; If n < bound, next iter
	mov qword [rsp + 24], 0 ; n = 0
	add qword [rsp + 16], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2938 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2938 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2938 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2929 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2929 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump2920
.jump2919:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2939
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2939:
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2940
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2940:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump2941: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2941 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2942
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2942:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[i : b] f) 
	jno .jump2943
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2943:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump2944
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2944:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump2945: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2946
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2946:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2947
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2947:
	; Computing bound for 'l'
	mov rax, [rel const602] ; 551
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2948
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2948:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2949
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2949:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump2950
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2950:
	imul rdi, [rsp + 0 + 8] ; multiply by 551 
	jno .jump2951
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2951:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump2952
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2952:
	imul rdi, [rsp + 0 + 24] ; multiply by j 
	jno .jump2953
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump2953:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump2954: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 24], 1
	; Compare n to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2954 ; If n < bound, next iter
	mov qword [rsp + 24], 0 ; n = 0
	add qword [rsp + 16], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2954 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2954 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2954 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2945 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2945 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump2920:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const479] ; 572
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2955
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2955:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2956
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2956:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2957
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2957:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2958
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2958:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- b) 
	jno .jump2959
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2959:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump2960
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2960:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump2961
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2961:
	imul rdi, [rsp + 0 + 24] ; multiply by 572 
	jno .jump2962
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2962:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump2963: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2963 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2963 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2963 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2963 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const603] ; 632
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2964
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2964:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const222] ; 291
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2965
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2965:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump2966: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2966 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2966 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2967
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2967:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2968
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2968:
	; Computing bound for 'i'
	mov rax, [rel const604] ; 10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2969
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2969:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump2970: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 320 to rsp 
		mov r10, [rbp - 320 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2970 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2970 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2970 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	add rax, r10
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2971
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2971:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2972
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2972:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2973
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2973:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump2974: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2974 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2974 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2974 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2975
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2975:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump2976: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2976 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2977
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2977:
	cmp rax, [rsp + 32]
	jl .jump2978
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2978:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2979
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2979:
	cmp rax, [rsp + 40]
	jl .jump2980
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2980:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2981
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2981:
	cmp rax, [rsp + 48]
	jl .jump2982
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2982:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2983
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2983:
	cmp rax, [rsp + 56]
	jl .jump2984
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2984:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2985
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2985:
	cmp rax, [rsp + 16]
	jl .jump2986
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2986:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2987
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2987:
	cmp rax, [rsp + 24]
	jl .jump2988
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2988:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 40
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const605] ; 60.09
	push rax
	mov rax, [rel const606] ; 54.87
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2989
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump2990
.jump2989:
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
.jump2990:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2991
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2991:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2992
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2992:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2993
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump2993:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump2994: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2994 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2994 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2994 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2995
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2995:
	cmp rax, [rsp + 32]
	jl .jump2996
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2996:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2997
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2997:
	cmp rax, [rsp + 40]
	jl .jump2998
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2998:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2999
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2999:
	cmp rax, [rsp + 48]
	jl .jump3000
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3000:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3001
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3001:
	cmp rax, [rsp + 56]
	jl .jump3002
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3002:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2918 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2918 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2918 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const600] ; 342
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3003
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3003:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3004
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3004:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const607] ; 745
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3005
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3005:
	; Computing bound for 'g'
	mov rax, [rel const608] ; 387
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3006
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3006:
	; Computing bound for 'f'
	mov rax, [rel const609] ; 872
	push rax
	mov rax, [rel const149] ; 268
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3007
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3007:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3008
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3008:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3009: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3009 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3009 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3009 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3010
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3010:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[][,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[f : (268 / 872), g : 387, h : 745] (- f)) 
	jno .jump3011
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3011:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump3012
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3012:
	imul rdi, [rsp + 0 + 16] ; multiply by (- 342) 
	jno .jump3013
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3013:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3014: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const610] ; 947
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3015
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3015:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3016
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3016:
	; Computing bound for 'i'
	mov rax, [rel const611] ; 892
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3017
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3017:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by 892 
	jno .jump3018
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3018:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump3019
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3019:
	imul rdi, [rsp + 0 + 16] ; multiply by 947 
	jno .jump3020
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3020:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump3021: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3021 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3021 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3021 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3014 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3014 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3014 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const100] ; 469
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3022
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3022:
	cmp rax, [rsp + 24]
	jl .jump3023
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3023:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3024
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3024:
	cmp rax, [rsp + 32]
	jl .jump3025
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3025:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3026
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3026:
	cmp rax, [rsp + 40]
	jl .jump3027
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3027:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const394] ; 162
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3028
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3028:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3029: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3029 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const612] ; 51.49
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const613] ; 84.97
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3030
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3032
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	jmp .jump3033
.jump3032:
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
.jump3033:
	jmp .jump3031
.jump3030:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3034
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3034:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3035
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3035:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump3036
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3036:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump3037
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3037:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3038: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const94] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3038 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3038 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const376] ; 37
	push rax
	mov rax, [rel const228] ; 812
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3039
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3039:
	cmp rax, [rsp + 16]
	jl .jump3040
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3040:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3041
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3041:
	cmp rax, [rsp + 24]
	jl .jump3042
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3042:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump3031:
	pop rax
	cmp rax, 0
	je .jump3043
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump3044
.jump3043:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3045
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3045:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3046: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const416] ; 260
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3046 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump3044:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3047
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3047:
	cmp rax, [rsp + 24]
	jl .jump3048
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3048:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3049
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3049:
	cmp rax, [rsp + 32]
	jl .jump3050
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3050:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3051
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3051:
	cmp rax, [rsp + 40]
	jl .jump3052
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3052:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const601] ; 395
	push rax
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3053
	mov rax, [rel const308] ; 52
	push rax
	jmp .jump3054
.jump3053:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const614] ; 150
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3055
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3055:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3056
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3056:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump3057
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3057:
	imul rdi, [rsp + 0 + 8] ; multiply by 150 
	jno .jump3058
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3058:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3059: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const615] ; 881
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3059 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3059 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const376] ; 37
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3060
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3060:
	cmp rax, [rsp + 16]
	jl .jump3061
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3061:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3062
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3062:
	cmp rax, [rsp + 24]
	jl .jump3063
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3063:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump3054:
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3064
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3064:
	cmp rax, [rsp + 8]
	jl .jump3065
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3065:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const8] ; True
	push rax
	sub rsp, 8 ; Add alignment
	mov rax, [rel const616] ; 29.16
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3066
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const294] ; 264
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3068
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3068:
	; Computing bound for 'h'
	mov rax, [rel const617] ; 648
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3069
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3069:
	; Computing bound for 'g'
	mov rax, [rel const159] ; 248
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3070
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3070:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3071
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3071:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump3072
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3072:
	imul rdi, [rsp + 0 + 8] ; multiply by (b - 248) 
	jno .jump3073
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3073:
	imul rdi, [rsp + 0 + 16] ; multiply by 648 
	jno .jump3074
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3074:
	imul rdi, [rsp + 0 + 24] ; multiply by 264 
	jno .jump3075
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3075:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3076: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3076 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3076 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3076 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3076 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const302] ; 19
	push rax
	mov rax, [rel const618] ; 475
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3077
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3077:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3078
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3078:
	; Computing bound for 'f'
	mov rax, [rel const173] ; 655
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3079
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3079:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3080: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3080 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3080 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3080 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3081
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3081:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const491] ; 29
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3082
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3082:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3083: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3083 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3084
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3084:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3085
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3085:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3086: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const619] ; 882
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3086 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3087
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3087:
	; Computing bound for 'f'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3088
	mov rax, [rel const620] ; 16
	push rax
	jmp .jump3089
.jump3088:
	mov rax, [rel const621] ; 901
	push rax
.jump3089:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3090
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3090:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3091: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3092
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3092:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump3093: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 312 to rsp 
		mov r10, [rbp - 312 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3093 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3091 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3091 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3091 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3091 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const622] ; 49
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3094
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump3094:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3095
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3095:
	cmp rax, [rsp + 32]
	jl .jump3096
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3096:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3097
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3097:
	cmp rax, [rsp + 40]
	jl .jump3098
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3098:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3099
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3099:
	cmp rax, [rsp + 48]
	jl .jump3100
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3100:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3101
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3101:
	cmp rax, [rsp + 56]
	jl .jump3102
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3102:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3067
.jump3066:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump3067:
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3103
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump3104
.jump3103:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump3104:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const623] ; 325
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3105
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3105:
	; Computing bound for 'g'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3106
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump3107
.jump3106:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3108
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3108:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3109: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3109 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump3107:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3110
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3110:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3111
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3111:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3112: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3112 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3112 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3112 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3113
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3113:
	; Computing bound for 'h'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3114
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3114:
	; Computing bound for 'f'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3115
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3115:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump3116
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3116:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3117: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3117 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const109] ; 669
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3118
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3118:
	cmp rax, [rsp + 8]
	jl .jump3119
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3119:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3120
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3120:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (array[f : b] f)[669] 
	jno .jump3121
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3121:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump3122
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3122:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3123: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 8], 1
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3123 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3123 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3124
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3124:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3125: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3125 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3126
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump3126:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3127
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3127:
	; Computing bound for 'g'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3128
	mov rax, [rel const624] ; 698
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	jmp .jump3129
.jump3128:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3130
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3130:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3131: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3131 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump3129:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3132
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3132:
	; Computing bound for 'f'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3133
	mov rax, [rel const192] ; 642
	push rax
	jmp .jump3134
.jump3133:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump3134:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3135
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3135:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3136: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3137
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	jmp .jump3138
.jump3137:
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const568] ; 456
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
.jump3138:
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3136 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3136 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3136 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3139
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3139:
	cmp rax, [rsp + 16]
	jl .jump3140
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3140:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3141
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3141:
	cmp rax, [rsp + 24]
	jl .jump3142
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3142:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3143
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3143:
	; Computing bound for 'g'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3144
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump3146
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
.jump3146:
	push rax
	pop rax
	cmp rax, 0
	je .jump3147
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump3148
.jump3147:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const381] ; 807
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3149
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3149:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3150: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3150 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump3148:
	jmp .jump3145
.jump3144:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3151
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump3152
.jump3151:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump3152:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3153
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump3153:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
.jump3145:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3154
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3154:
	; Computing bound for 'f'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3155
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3155:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump3156
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3156:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3157: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const8] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3157 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3158
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3158:
	cmp rax, [rsp + 8]
	jl .jump3159
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3159:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3160
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const101] ; 445
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3162
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump3162:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3163
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3163:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3164: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 0], 1
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3164 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump3161
.jump3160:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump3161:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3165
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3165:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump3166: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const114] ; 371
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3166 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3166 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3166 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3166 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const202] ; 724
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3167
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3167:
	cmp rax, [rsp + 24]
	jl .jump3168
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3168:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3169
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3169:
	cmp rax, [rsp + 32]
	jl .jump3170
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3170:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3171
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3171:
	cmp rax, [rsp + 40]
	jl .jump3172
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3172:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3173
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3175
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	jmp .jump3176
.jump3175:
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump3177
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const625] ; 94.94
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
.jump3177:
	push rax
.jump3176:
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const626] ; 249
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3178
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3178:
	; Computing bound for 'h'
	mov rax, [rel const627] ; 354
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3179
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3179:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3180
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3180:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3181: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const53] ; 524
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3181 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3181 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3181 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3182
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3182:
	cmp rax, [rsp + 8]
	jl .jump3183
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3183:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump3184
	mov rax, [rel const628] ; 59.58
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3185
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump3186
.jump3185:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const388] ; 195
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
.jump3186:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3187
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3187:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const629] ; 194
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3188
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3188:
	cqo
	idiv r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3189
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump3189:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3190
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3190:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3191: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3192
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3192:
	; Computing bound for 'i'
	mov rax, [rel const99] ; 601
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3193
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3193:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by 601 
	jno .jump3194
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3194:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump3195
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3195:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump3196: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const630] ; 57.54
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3196 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3196 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const248] ; 867
	push rax
	mov rax, [rel const494] ; 713
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3197
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3197:
	cmp rax, [rsp + 16]
	jl .jump3198
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3198:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3199
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3199:
	cmp rax, [rsp + 24]
	jl .jump3200
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3200:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3191 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3191 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
.jump3184:
	push rax
	jmp .jump3174
.jump3173:
	mov rax, [rel const8] ; True
	push rax
.jump3174:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3201
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const631] ; 215
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3203
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3203:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3204
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3204:
	; Computing bound for 'g'
	mov rax, [rel const334] ; 459
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3205
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3205:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3206: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const632] ; 78.39
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3206 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3206 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3207
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const51] ; 585
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3209
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3209:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3210: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const505] ; 393
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3210 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump3208
.jump3207:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump3208:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3211
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3211:
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const419] ; 383
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3212
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3212:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3213
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3213:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3214: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3215
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump3215:
	cqo
	idiv r10
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3214 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3214 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3216
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3216:
	; Computing bound for 'h'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3217
	mov rax, [rel const439] ; 386
	push rax
	jmp .jump3218
.jump3217:
	mov rax, [rel const633] ; 243
	push rax
.jump3218:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3219
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3219:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if f then 386 else 243) 
	jno .jump3220
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3220:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3221: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3221 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3222
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3222:
	cmp rax, [rsp + 8]
	jl .jump3223
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3223:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3224
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3224:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const290] ; 804
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3225
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump3225:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3226
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3226:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3227: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3227 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const165] ; 811
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3228
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3228:
	; Computing bound for 'g'
	mov rax, [rel const492] ; 661
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3229
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3229:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3230: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3230 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3230 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3231
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3231:
	cmp rax, [rsp + 8]
	jl .jump3232
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3232:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3233
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3233:
	; Computing bound for 'g'
	mov rax, [rel const634] ; 583
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3234
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3234:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3235: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const161] ; 123
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3235 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3235 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3236
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3236:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3237: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3237 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3237 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3237 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3237 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3238
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3238:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[g : ((sum[g : 583, h : a[(sum[g : 661, h : 811] g)]] 123) * (sum[g : ((804 - b) / b)] (- g))), h : (- (array[g : (if f then 386 else 243)] b)[b]), i : (- (sum[g : b, h : 383] (h / h))), j : (if ((sum[g : 459, h : (- b)] 78.39) <= d.b) then (sum[g : 585] ((393 * g) + g)) else b)] b) 
	jno .jump3239
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3239:
	imul rdi, [rsp + 0 + 8] ; multiply by 215 
	jno .jump3240
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3240:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3241: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3242
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3242:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump3243
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3243:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump3244: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3245
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3247
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3247:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3248
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3248:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3249
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3249:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3250
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3250:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump3251
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3251:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump3252
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3252:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump3253
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3253:
	imul rdi, [rsp + 0 + 24] ; multiply by h 
	jno .jump3254
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3254:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump3255: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3255 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3255 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3255 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3255 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump3246
.jump3245:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3256
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3256:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3257
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3257:
	; Computing bound for 'k'
	mov rax, [rel const183] ; 600
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3258
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3258:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3259
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3259:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump3260
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3260:
	imul rdi, [rsp + 0 + 8] ; multiply by 600 
	jno .jump3261
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3261:
	imul rdi, [rsp + 0 + 16] ; multiply by (- i) 
	jno .jump3262
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3262:
	imul rdi, [rsp + 0 + 24] ; multiply by g 
	jno .jump3263
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3263:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump3264: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const635] ; 113
	push rax
	mov rax, [rel const636] ; 702
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3264 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3264 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3264 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3264 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump3246:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3244 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const637] ; 866
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3265
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3265:
	cmp rax, [rsp + 8]
	jl .jump3266
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3266:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3241 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3241 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3267
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3269
	mov rax, [rel const109] ; 669
	push rax
	jmp .jump3270
.jump3269:
	mov rax, [rel const564] ; 773
	push rax
.jump3270:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3271
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3271:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3272
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3272:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump3273
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3273:
	imul rdi, [rsp + 0 + 8] ; multiply by (if false then 669 else 773) 
	jno .jump3274
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3274:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3275: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3275 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3275 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3276
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3276:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3277
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3277:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3278
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3278:
	; Computing bound for 'g'
	mov rax, [rel const638] ; 978
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3279
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3279:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3280: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3280 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3280 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3280 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3281
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3281:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3282: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3283
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump3283:
	cqo
	idiv r10
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3282 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3282 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3284
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	jmp .jump3285
.jump3284:
	mov rax, [rel const8] ; True
	push rax
.jump3285:
	pop rax
	cmp rax, 0
	je .jump3286
	mov rax, [rel const214] ; 330
	push rax
	jmp .jump3287
.jump3286:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump3287:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3288
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3288:
	cmp rax, [rsp + 16]
	jl .jump3289
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3289:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3290
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3290:
	cmp rax, [rsp + 24]
	jl .jump3291
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3291:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3268
.jump3267:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump3292
	mov rax, [rel const574] ; 321
	push rax
	mov rax, [rel const639] ; 802
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
.jump3292:
	push rax
	pop rax
	cmp rax, 0
	je .jump3293
	mov rax, [rel const8] ; True
	push rax
	pop rax
.jump3293:
	push rax
.jump3268:
	pop rax
	cmp rax, 0
	je .jump3294
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const203] ; 863
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3296
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3296:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- (- 863)) 
	jno .jump3297
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3297:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3298: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3299
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3299:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3300
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3300:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3301
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3301:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3302
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3302:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump3303: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3303 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3303 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3304
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3304:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[h : g, i : b] i) 
	jno .jump3305
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3305:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump3306
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3306:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump3307
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3307:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump3308: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3308 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3308 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3308 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3298 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3309
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3309:
	cmp rax, [rsp + 8]
	jl .jump3310
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3310:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3295
.jump3294:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3311
	mov rax, [rel const640] ; 90
	push rax
	jmp .jump3312
.jump3311:
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const23] ; 341
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3313
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3313:
	cmp rax, [rsp + 8]
	jl .jump3314
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3314:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump3312:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3315
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3315:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3316
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3316:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3317
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3317:
	; Computing bound for 'g'
	mov rax, [rel const641] ; 902
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3318
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3318:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 902 
	jno .jump3319
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3319:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump3320
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3320:
	imul rdi, [rsp + 0 + 16] ; multiply by ((if true then 90 else a[341]) % b) 
	jno .jump3321
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3321:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3322: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3323
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3323:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump3324
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3324:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump3325: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const642] ; 627
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 0], 1
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3325 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const643] ; 320
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3326
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3326:
	cmp rax, [rsp + 8]
	jl .jump3327
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3327:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3322 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3322 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3322 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump3295:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3328
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const644] ; 332
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3330
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3330:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3331
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3331:
	; Computing bound for 'h'
	mov rax, [rel const645] ; 443
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3332
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3332:
	; Computing bound for 'g'
	mov rax, [rel const646] ; 141
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3333
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3333:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3334: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const647] ; 53
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3334 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3334 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3334 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3334 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3335
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3335:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	jmp .jump3329
.jump3328:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump3329:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3336
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3336:
	; Computing bound for 'g'
	mov rax, [rel const111] ; 296
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const8] ; True
	push rax
	mov rax, [rel const8] ; True
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3337
	mov rax, [rel const193] ; 446
	push rax
	jmp .jump3338
.jump3337:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump3338:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3339
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump3339:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3340
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3340:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by ((if (true == true) then 446 else b) % (- 296)) 
	jno .jump3341
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3341:
imul rdi, [rsp + 0 + 8] ; multiply by (if f then ((sum[g : 141, h : 443, i : b, j : 332] 53) % b) else b) 
	jno .jump3342
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3342:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3343: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3344
	mov rax, [rel const610] ; 947
	push rax
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	mov rax, [rel const648] ; 676
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3346
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3346:
	cmp rax, [rsp + 8]
	jl .jump3347
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3347:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3345
.jump3344:
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
.jump3345:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3343 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3343 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const649] ; 203
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3348
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3348:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 203 
	jno .jump3349
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3349:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3350: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3350 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3351
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3351:
	cmp rax, [rsp + 8]
	jl .jump3352
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3352:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3353
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3353:
	cmp rax, [rsp + 8]
	jl .jump3354
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3354:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3355
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3355:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const650] ; 607
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const621] ; 901
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3356
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3356:
	cqo
	idiv r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3357
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump3357:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const651] ; 470
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const94] ; 0
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3358
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3358:
	; Computing bound for 'g'
	mov rax, [rel const384] ; 657
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3359
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3359:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3360: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3360 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3360 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3361
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump3361:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3362
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump3362:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3363
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3363:
	cmp rax, [rsp + 16]
	jl .jump3364
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3364:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3365
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3365:
	cmp rax, [rsp + 24]
	jl .jump3366
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3366:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const306] ; 887
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3367
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3367:
	; Computing bound for 'i'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3368
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump3369
.jump3368:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump3369:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3370
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3370:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3371
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3371:
	; Computing bound for 'g'
	mov rax, [rel const652] ; 21
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3372
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3372:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3373: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3374
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3374:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3373 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3373 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3373 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3373 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const653] ; 720
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3375
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3375:
	cmp rax, [rsp + 24]
	jl .jump3376
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3376:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3377
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3377:
	cmp rax, [rsp + 32]
	jl .jump3378
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3378:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3379
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3379:
	cmp rax, [rsp + 40]
	jl .jump3380
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3380:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const510] ; 98
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3381
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3381:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3382
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump3382:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3383
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3383:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (b % b) 
	jno .jump3384
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3384:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump3385
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3385:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3386: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3386 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3386 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const654] ; 13
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3387
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3387:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const655] ; 789
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rel const308] ; 52
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3388
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3388:
	cmp rax, [rsp + 16]
	jl .jump3389
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3389:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3390
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3390:
	cmp rax, [rsp + 24]
	jl .jump3391
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3391:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3392
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const182] ; 719
	push rax
	mov rax, [rel const656] ; 520
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3394
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3394:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3395
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3395:
	; Computing bound for 'h'
	mov rax, [rel const657] ; 581
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3396
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3396:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3397
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3397:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump3398
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3398:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 581) 
	jno .jump3399
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3399:
	imul rdi, [rsp + 0 + 16] ; multiply by (520 / 719) 
	jno .jump3400
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3400:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3401: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3402
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3402:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3403
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3403:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump3404: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3404 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3404 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3401 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3401 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3401 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const308] ; 52
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3405
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3405:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3406
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3406:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3407: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const658] ; 95
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3407 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3407 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const659] ; 464
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3408
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3408:
	cmp rax, [rsp + 24]
	jl .jump3409
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3409:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3410
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3410:
	cmp rax, [rsp + 32]
	jl .jump3411
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3411:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3412
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3412:
	cmp rax, [rsp + 40]
	jl .jump3413
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3413:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3393
.jump3392:
	mov rax, [rel const151] ; 766
	push rax
	pop rax
	neg rax
	push rax
.jump3393:
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3414
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3414:
	cmp rax, [rsp + 16]
	jl .jump3415
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3415:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3416
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3416:
	cmp rax, [rsp + 24]
	jl .jump3417
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3417:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 40
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3202
.jump3201:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3418
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3418:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const660] ; 588
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3419
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3419:
	; Computing bound for 'h'
	mov rax, [rel const157] ; 151
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3420
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3420:
	; Computing bound for 'g'
	mov rax, [rel const471] ; 547
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3421
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3421:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 547 
	jno .jump3422
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3422:
	imul rdi, [rsp + 0 + 8] ; multiply by 151 
	jno .jump3423
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3423:
	imul rdi, [rsp + 0 + 16] ; multiply by 588 
	jno .jump3424
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3424:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3425: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3425 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3425 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3425 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const661] ; 441
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const662] ; 78
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3426
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3426:
	cmp rax, [rsp + 24]
	jl .jump3427
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3427:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3428
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3428:
	cmp rax, [rsp + 32]
	jl .jump3429
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3429:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3430
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3430:
	cmp rax, [rsp + 40]
	jl .jump3431
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3431:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3432
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump3432:
	cqo
	idiv r10
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3433
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3433:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3434: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3434 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3434 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3435
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3435:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3436
	mov rax, [rel const312] ; 33.54
	push rax
	jmp .jump3437
.jump3436:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump3437:
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3438
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const651] ; 470
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3440
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3440:
	; Computing bound for 'i'
	mov rax, [rel const89] ; 337
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3441
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3441:
	; Computing bound for 'h'
	mov rax, [rel const448] ; 546
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3442
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3442:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3443
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3443:
	; Computing bound for 'h'
	mov rax, [rel const663] ; 8
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3444
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3444:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3445
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3445:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3446: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3446 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3446 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3446 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3447
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3447:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[g : b, h : 8, i : b] g) 
	jno .jump3448
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3448:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 546) 
	jno .jump3449
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3449:
	imul rdi, [rsp + 0 + 16] ; multiply by 337 
	jno .jump3450
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3450:
	imul rdi, [rsp + 0 + 24] ; multiply by 470 
	jno .jump3451
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3451:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3452: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3452 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3452 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3452 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3452 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump3439
.jump3438:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const190] ; 448
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3453
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3453:
	; Computing bound for 'i'
	mov rax, [rel const189] ; 742
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3454
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3454:
	; Computing bound for 'h'
	mov rax, [rel const664] ; 187
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3455
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3455:
	; Computing bound for 'g'
	mov rax, [rel const665] ; 699
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3456
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3456:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 699 
	jno .jump3457
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3457:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 187) 
	jno .jump3458
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3458:
	imul rdi, [rsp + 0 + 16] ; multiply by 742 
	jno .jump3459
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3459:
	imul rdi, [rsp + 0 + 24] ; multiply by 448 
	jno .jump3460
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3460:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3461: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3461 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3461 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3461 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3461 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump3439:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const8] ; True
	push rax
	mov rax, [rel const94] ; False
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3462
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump3463
.jump3462:
	mov rax, [rel const82] ; 270
	push rax
	mov rax, [rel const428] ; 372
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
.jump3463:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3464
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3464:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3465: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const618] ; 475
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3465 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const198] ; 783
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3466
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3466:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3467: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3467 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3468
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3468:
	; Computing bound for 'h'
	mov rax, [rel const198] ; 783
	push rax
	mov rax, [rel const666] ; 945
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3469
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3469:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3470
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3470:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3471
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3471:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump3472
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3472:
	imul rdi, [rsp + 0 + 8] ; multiply by (945 % 783) 
	jno .jump3473
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3473:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[g : 783] g) 
	jno .jump3474
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3474:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3475: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const588] ; 255
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3475 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3475 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3475 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const667] ; 775
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3476
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3476:
	; Computing bound for 'i'
	mov rax, [rel const95] ; 513
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3477
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3477:
	; Computing bound for 'h'
	mov rax, [rel const668] ; 790
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3478
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3478:
	; Computing bound for 'g'
	mov rax, [rel const380] ; 514
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3479
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3479:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3480: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3480 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3480 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3480 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3480 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3481
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3481:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3482: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3482 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rel const669] ; 473
	push rax
	mov rax, [rel const617] ; 648
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3483
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3483:
	cmp rax, [rsp + 24]
	jl .jump3484
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3484:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3485
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3485:
	cmp rax, [rsp + 32]
	jl .jump3486
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3486:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3487
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3487:
	cmp rax, [rsp + 40]
	jl .jump3488
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3488:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const270] ; 821
	push rax
	mov rax, [rel const415] ; 493
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3489
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump3489:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3490
	mov rax, [rel const670] ; 62.93
	push rax
	mov rax, [rel const671] ; 79.99
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	jmp .jump3491
.jump3490:
	mov rax, [rel const94] ; False
	push rax
.jump3491:
	pop rax
	cmp rax, 0
	je .jump3492
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump3493
.jump3492:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump3493:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3494
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3494:
	cmp rax, [rsp + 32]
	jl .jump3495
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3495:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3496
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3496:
	cmp rax, [rsp + 40]
	jl .jump3497
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3497:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3498
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3498:
	cmp rax, [rsp + 48]
	jl .jump3499
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3499:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3500
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3500:
	cmp rax, [rsp + 56]
	jl .jump3501
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3501:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3502
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const672] ; 322
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump3504
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump3505
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
.jump3505:
	push rax
	pop rax
.jump3504:
	push rax
	pop rax
	cmp rax, 0
	je .jump3506
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const212] ; 105
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3508
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump3508:
	cqo
	idiv r10
	push rax
	jmp .jump3507
.jump3506:
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const8] ; True
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3509
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const293] ; 432
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3511
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3511:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3512
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3512:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3513
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3513:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3514: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3514 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3514 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3514 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump3510
.jump3509:
	mov rax, [rel const673] ; 230
	push rax
.jump3510:
.jump3507:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3515
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3515:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (if ((b <= 322) || (f || f)) then ((- 105) / b) else (if (true != f) then (sum[g : b, h : b, i : 432] g) else 230)) 
	jno .jump3516
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3516:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3517: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3517 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump3503
.jump3502:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const674] ; 860
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3518
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3518:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3519: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const675] ; 79.73
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3519 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const676] ; 78.86
	push rax
	mov rax, [rel const677] ; 56.27
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3520
	mov rax, [rel const5] ; 18
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const678] ; 593
	push rax
	mov rax, [rel const679] ; 22
	push rax
	mov rax, [rel const680] ; 40
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	jmp .jump3521
.jump3520:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const681] ; 167
	push rax
	mov rax, [rel const682] ; 284
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
.jump3521:
.jump3503:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3522
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3522:
	cmp rax, [rsp + 8]
	jl .jump3523
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3523:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3524
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3524:
	; Computing bound for 'h'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const123] ; 533
	push rax
	mov rax, [rel const176] ; 403
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3525
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump3525:
	cqo
	idiv r10
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3526
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3526:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- ((b / 403) - 533)) 
	jno .jump3527
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3527:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3528: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const683] ; 85
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3528 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const370] ; 307
	push rax
	mov rax, [rel const684] ; 402
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3529
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3529:
	; Computing bound for 'h'
	mov rax, [rel const685] ; 192
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3530
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3530:
	; Computing bound for 'g'
	mov rax, [rel const686] ; 193
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3531
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3531:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3532: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const275] ; 553
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3533
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3533:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3534
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3534:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3535
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3535:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3536
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3536:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump3537: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const97] ; 280
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3537 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3537 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3537 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3537 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3532 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3532 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3532 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3538
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3538:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3539
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3539:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const155] ; 336
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3540
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3540:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3541: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3541 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3541 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3541 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3542
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3542:
	cmp rax, [rsp + 8]
	jl .jump3543
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3543:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3544
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3544:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const687] ; 5.04
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const688] ; 53.74
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const689] ; 86.7
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3545
	mov rax, [rel const690] ; 15.13
	push rax
	mov rax, [rel const691] ; 17.29
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3546
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	jmp .jump3547
.jump3546:
	mov rax, [rel const692] ; 11.85
	push rax
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
.jump3547:
	pop rax
.jump3545:
	push rax
	pop rax
	cmp rax, 0
	jne .jump3548
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
.jump3548:
	push rax
	pop rax
	cmp rax, 0
	je .jump3549
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3551
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3553
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	jmp .jump3554
.jump3553:
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
.jump3554:
	pop rax
	cmp rax, 0
	je .jump3555
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump3556
.jump3555:
	mov rax, [rel const679] ; 22
	push rax
.jump3556:
	mov rax, [rel const693] ; 256
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3557
	mov rax, [rel const385] ; 377
	push rax
	jmp .jump3558
.jump3557:
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3559
	mov rax, [rel const278] ; 68
	push rax
	jmp .jump3560
.jump3559:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const82] ; 270
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3561
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3561:
	; Computing bound for 'i'
	mov rax, [rel const694] ; 743
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3562
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3562:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3563
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3563:
	; Computing bound for 'g'
	mov rax, [rel const46] ; 277
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3564
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3564:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3565: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const695] ; 155
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3565 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3565 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3565 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3565 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
.jump3560:
.jump3558:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3566
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3566:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	jmp .jump3552
.jump3551:
	mov rax, [rel const696] ; 287
	push rax
.jump3552:
	jmp .jump3550
.jump3549:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump3550:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3567
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3567:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (if (((rgba {c, 86.7, c, 53.74}.g == (- (5.04 / c))) && (if (! (17.29 > 15.13)) then (f != (b >= b)) else (d.a == 11.85))) || f) then (if ((- c) != d.g) then ((if (b >= (b * 256)) then 377 else (if f then 68 else (sum[g : 277, h : b, i : 743, j : 270] 155))) % (if (if (! true) then f else f) then b else 22)) else 287) else (- b)) 
	jno .jump3568
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3568:
imul rdi, [rsp + 0 + 8] ; multiply by (array[g : (- ((b / 403) - 533))] 85)[(sum[g : (- (336 - b)), h : b, i : (sum[g : 193, h : 192, i : (- (402 * 307))] ((sum[j : (- i), k : g, l : b, m : 553] 280) * g))] (- b))] 
	jno .jump3569
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3569:
imul rdi, [rsp + 0 + 16] ; multiply by (if (if (d.b >= (if f then 33.54 else c)) then (array[g : (sum[g : b, h : 8, i : b] g), h : (- 546), i : 337, j : 470] f) else (array[g : 699, h : (- 187), i : 742, j : 448] (g == g)))[(if (if f then (79.99 == 62.93) else false) then b else b), ((- 493) % 821), (array[g : b, h : (945 % 783), i : (sum[g : 783] g)] 255)[b, ((- 648) * 473), ((sum[g : b] g) * (sum[g : 514, h : 790, i : 513, j : 775] g))], (sum[g : (if (false == true) then b else (372 - 270))] 475)] then (array[g : (if ((b <= 322) || (f || f)) then ((- 105) / b) else (if (true != f) then (sum[g : b, h : b, i : 432] g) else 230))] g) else (if (f != ((56.27 % 78.86) != (sum[g : 860] 79.73))) then [b, ((40 * 22) - 593), (- 18)] else [b, 284, 167, b]))[(- b)] 
	jno .jump3570
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3570:
imul rdi, [rsp + 0 + 24] ; multiply by ((sum[g : ((b / (array[g : 547, h : 151, i : 588] h)[78, b, 441]) - b), h : b] h) - b) 
	jno .jump3571
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3571:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump3572: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3573
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3573:
	; Computing bound for 'm'
	mov rax, [rel const136] ; 462
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3574
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3574:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3575
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3575:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3576
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3576:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump3577: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 24], 1
	; Compare n to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3577 ; If n < bound, next iter
	mov qword [rsp + 24], 0 ; n = 0
	add qword [rsp + 16], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3577 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3577 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3577 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3578
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3578:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3579
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3579:
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3580
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3580:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump3581: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3581 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3582
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3582:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3583
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3583:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump3584
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3584:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[k : i] g) 
	jno .jump3585
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3585:
	imul rdi, [rsp + 0 + 16] ; multiply by j 
	jno .jump3586
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3586:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[k : h, l : b, m : 462, n : j] h) 
	jno .jump3587
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3587:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump3588: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3589
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3589:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3590
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3590:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3591
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3591:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump3592
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3592:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump3593
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3593:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump3594
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3594:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump3595: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3595 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3595 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3595 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'n'
	add qword [rsp + 24], 1
	; Compare n to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3588 ; If n < bound, next iter
	mov qword [rsp + 24], 0 ; n = 0
	add qword [rsp + 16], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3588 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3588 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3588 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3596
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3596:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump3597: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3598
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3598:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3599
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3599:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump3600: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3600 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3600 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3597 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3601
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3601:
	cmp rax, [rsp + 32]
	jl .jump3602
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3602:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3603
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3603:
	cmp rax, [rsp + 40]
	jl .jump3604
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3604:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3605
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3605:
	cmp rax, [rsp + 48]
	jl .jump3606
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3606:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3607
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3607:
	cmp rax, [rsp + 56]
	jl .jump3608
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3608:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3609
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump3610
.jump3609:
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
.jump3610:
	pop rax
	cmp rax, 0
	je .jump3611
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3613
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3613:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump3614: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3615
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump3615:
	cqo
	idiv r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3614 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump3612
.jump3611:
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump3612:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3616
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3616:
	cmp rax, [rsp + 24]
	jl .jump3617
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3617:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3618
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3618:
	cmp rax, [rsp + 32]
	jl .jump3619
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3619:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3620
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3620:
	cmp rax, [rsp + 40]
	jl .jump3621
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3621:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3622
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3622:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3623
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3623:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump3624
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3624:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump3625
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3625:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump3626: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const697] ; 33.22
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3626 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3626 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const67] ; 936
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3627
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3627:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3628
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3628:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3629
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3629:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump3630: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3630 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3630 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3630 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3631
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3631:
	cmp rax, [rsp + 16]
	jl .jump3632
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3632:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3633
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3633:
	cmp rax, [rsp + 24]
	jl .jump3634
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3634:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3572 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3572 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3572 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3572 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump3202:
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3635
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3637
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3637:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3638
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3638:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3639
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3639:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3640
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3640:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump3641: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3642
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3642:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump3643: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3643 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3644
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3644:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3645
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3645:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3646
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3646:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3647
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3647:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump3648
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3648:
	imul rdi, [rsp + 0 + 8] ; multiply by j 
	jno .jump3649
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3649:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump3650
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3650:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[o : m] (- n)) 
	jno .jump3651
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3651:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump3652: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const698] ; 42.59
	push rax
	mov rax, [rel const699] ; 84.85
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3652 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3652 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3652 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3652 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const700] ; 603
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3653
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3653:
	cmp rax, [rsp + 32]
	jl .jump3654
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3654:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3655
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3655:
	cmp rax, [rsp + 40]
	jl .jump3656
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3656:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3657
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3657:
	cmp rax, [rsp + 48]
	jl .jump3658
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3658:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3659
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3659:
	cmp rax, [rsp + 56]
	jl .jump3660
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3660:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3641 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3641 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3641 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump3636
.jump3635:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const634] ; 583
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3661
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3661:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3662
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3662:
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3663
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3663:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3664
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3664:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3665
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3665:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump3666: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3666 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3666 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3666 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3667
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3667:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump3668: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3668 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3668 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3668 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const701] ; 93.01
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3669
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3669:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3670
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3670:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump3671: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3671 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3671 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const541] ; 861
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3672
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3672:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3673
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3673:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3674
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	jmp .jump3675
.jump3674:
	mov rax, [rel const155] ; 336
	push rax
.jump3675:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3676
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3676:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump3677: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3677 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3677 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3677 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3678
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3678:
	; Computing bound for 'l'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const75] ; 466
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3679
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3679:
	; Computing bound for 'n'
	mov rax, [rel const142] ; 72
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3680
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3680:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3681
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3681:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3682
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3682:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by j 
	jno .jump3683
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3683:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump3684
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3684:
	imul rdi, [rsp + 0 + 16] ; multiply by 72 
	jno .jump3685
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3685:
	imul rdi, [rsp + 0 + 24] ; multiply by 466 
	jno .jump3686
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3686:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump3687: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3687 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3687 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3687 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3687 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const162] ; 986
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3688
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3688:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump3689: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3689 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3690
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3690:
	cmp rax, [rsp + 32]
	jl .jump3691
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3691:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3692
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3692:
	cmp rax, [rsp + 40]
	jl .jump3693
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3693:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3694
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3694:
	cmp rax, [rsp + 48]
	jl .jump3695
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3695:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3696
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3696:
	cmp rax, [rsp + 56]
	jl .jump3697
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3697:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3698
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3698:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump3699: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3700
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	jmp .jump3701
.jump3700:
	mov rax, [rel const702] ; 60.17
	push rax
.jump3701:
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3699 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3699 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
.jump3636:
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const94] ; False
	push rax
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3702
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const391] ; 127
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	jmp .jump3703
.jump3702:
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3704
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3706
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3706:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump3707
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3707:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump3708: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3709
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
.jump3709:
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3710
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3710:
	cmp rax, [rsp + 8]
	jl .jump3711
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3711:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 0], 1
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3708 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump3705
.jump3704:
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3712
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3714
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump3714:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3715
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3715:
	; Computing bound for 'p'
	mov rax, [rel const703] ; 96
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3716
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3716:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3717
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3717:
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3718
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3718:
	; Computing bound for 'p'
	mov rax, [rel const704] ; 437
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3719
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3719:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3720
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3720:
	; Computing bound for 'n'
	mov rax, [rel const705] ; 406
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3721
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3721:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump3722: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3722 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3722 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3722 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3722 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3723
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3723:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump3724: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3724 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3724 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3724 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3724 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3725
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3725:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[n : (sum[n : 406, o : i, p : 437, q : i] k), o : (- h), p : 96, q : (k / j)] q) 
	jno .jump3726
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3726:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump3727: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump3728
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump3728:
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 0], 1
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3727 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump3713
.jump3712:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3729
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3729:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3730
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3730:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3731
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3731:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump3732
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3732:
	imul rdi, [rsp + 0 + 8] ; multiply by j 
	jno .jump3733
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3733:
	imul rdi, [rsp + 0 + 16] ; multiply by j 
	jno .jump3734
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3734:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump3735: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3735 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3735 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3735 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3736
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	jmp .jump3737
.jump3736:
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
.jump3737:
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3738
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3738:
	cmp rax, [rsp + 24]
	jl .jump3739
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3739:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3740
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3740:
	cmp rax, [rsp + 32]
	jl .jump3741
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3741:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3742
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3742:
	cmp rax, [rsp + 40]
	jl .jump3743
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3743:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3744
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	jmp .jump3745
.jump3744:
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
.jump3745:
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
.jump3713:
.jump3705:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3746
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3746:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3747
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3747:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3748
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3748:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3749
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3749:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by j 
	jno .jump3750
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3750:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump3751
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3751:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump3752
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3752:
	imul rdi, [rsp + 0 + 24] ; multiply by i 
	jno .jump3753
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3753:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump3754: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const706] ; 12.75
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3754 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3754 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3754 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3754 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3755
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	jmp .jump3756
.jump3755:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump3756:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3757
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3757:
	cmp rax, [rsp + 32]
	jl .jump3758
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3758:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3759
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3759:
	cmp rax, [rsp + 40]
	jl .jump3760
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3760:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3761
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3761:
	cmp rax, [rsp + 48]
	jl .jump3762
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3762:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3763
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3763:
	cmp rax, [rsp + 56]
	jl .jump3764
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3764:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3765
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3767
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	jmp .jump3768
.jump3767:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump3768:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3769
	mov rax, [rel const707] ; 563
	push rax
	jmp .jump3770
.jump3769:
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3771
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	jmp .jump3772
.jump3771:
	mov rax, [rel const209] ; 530
	push rax
.jump3772:
.jump3770:
	jmp .jump3766
.jump3765:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3773
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3773:
	; Computing bound for 'n'
	mov rax, [rel const708] ; 799
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3774
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3774:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 799 
	jno .jump3775
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3775:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump3776
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3776:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump3777: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const293] ; 432
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3778
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump3778:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3777 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3777 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3779
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3779:
	cqo
	idiv r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3780
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3780:
	cmp rax, [rsp + 16]
	jl .jump3781
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3781:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3782
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3782:
	cmp rax, [rsp + 24]
	jl .jump3783
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3783:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3784
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3784:
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3785
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3785:
	; Computing bound for 'p'
	mov rax, [rel const709] ; 61.61
	push rax
	mov rax, [rel const710] ; 94.84
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3786
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3788
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump3788:
	cqo
	idiv r10
	push rax
	jmp .jump3787
.jump3786:
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3789
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump3789:
	cqo
	idiv r10
	mov rax, rdx
	push rax
.jump3787:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3790
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3790:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3791
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3791:
	; Computing bound for 'n'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3792
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3792:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3793
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3793:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3794
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3794:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3795
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3795:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump3796
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3796:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump3797
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3797:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump3798
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3798:
	imul rdi, [rsp + 0 + 24] ; multiply by h 
	jno .jump3799
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3799:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump3800: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3800 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3800 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3800 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3800 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const653] ; 720
	push rax
	mov rax, [rel const46] ; 277
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3801
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3801:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3802
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3802:
	cmp rax, [rsp + 32]
	jl .jump3803
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3803:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3804
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3804:
	cmp rax, [rsp + 40]
	jl .jump3805
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3805:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3806
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3806:
	cmp rax, [rsp + 48]
	jl .jump3807
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3807:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3808
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3808:
	cmp rax, [rsp + 56]
	jl .jump3809
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3809:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3810
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3810:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump3811: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3811 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3811 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3811 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3811 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3812
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3812:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump3813: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3814
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3814:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3815
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3815:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3816
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3816:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3817
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3817:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump3818: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 304 to rsp 
		mov r10, [rbp - 304 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 's'
	add qword [rsp + 24], 1
	; Compare s to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3818 ; If s < bound, next iter
	mov qword [rsp + 24], 0 ; s = 0
	add qword [rsp + 16], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3818 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3818 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3818 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3813 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3813 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump3766:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3819
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3819:
	cmp rax, [rsp + 8]
	jl .jump3820
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3820:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3821
	mov rax, [rel const8] ; True
	push rax
	pop rax
.jump3821:
	push rax
.jump3703:
	pop rax
	cmp rax, 0
	jne .jump3822
	lea rdi, [rel const711] ; 'n'
	call _fail_assertion
.jump3822:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3823
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3823:
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3824
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3824:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3825
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3825:
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3826
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump3827
.jump3826:
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3828
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	jmp .jump3829
.jump3828:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump3829:
.jump3827:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3830
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3830:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump3831: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const712] ; 126
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 0], 1
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3831 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3832
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3832:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3833
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3833:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump3834: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3834 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3834 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3834 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3834 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3835
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3835:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3836
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3836:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump3837: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3837 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3837 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3838
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3838:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (- (sum[n : i, o : (sum[n : k, o : (sum[n : (- (if m then (- h) else (if f then j else b)))] 126), p : b, q : b] h)] k)) 
	jno .jump3839
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3839:
	imul rdi, [rsp + 0 + 8] ; multiply by j 
	jno .jump3840
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3840:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump3841: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const94] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3841 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3841 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3842
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3844
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3846
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3846:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3847
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3847:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3848
	mov rax, [rel const94] ; False
	push rax
	jmp .jump3849
.jump3848:
	mov rax, [rel const8] ; True
	push rax
.jump3849:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3850
	mov rax, [rel const713] ; 589
	push rax
	jmp .jump3851
.jump3850:
	mov rax, [rel const363] ; 450
	push rax
.jump3851:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3852
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3852:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[,,,][] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if (! (if f then false else true)) then 589 else 450) 
	jno .jump3853
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3853:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump3854
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3854:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump3855
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3855:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump3856: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3857
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3859
	sub rsp, 40
	; Moving 40 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 160 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 160 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 160 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 40
	; Moving 40 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 160 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 160 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 160 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rdi, 80
	call _jpl_alloc
	; Moving 80 bytes from rsp to rax 
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 80
	push rax
	mov rax, 2
	push rax
	jmp .jump3860
.jump3859:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3861
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3861:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump3862
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3862:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump3863: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 160 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 160 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 160 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 't'
	add qword [rsp + 0], 1
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3863 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump3860:
	jmp .jump3858
.jump3857:
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3864
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3866
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3866:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump3867
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3867:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump3868: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 160 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 160 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 160 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 't'
	add qword [rsp + 0], 1
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3868 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump3865
.jump3864:
	sub rsp, 40
	; Moving 40 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 160 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 160 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 160 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 40
	; Moving 40 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 160 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 160 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 160 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rdi, 80
	call _jpl_alloc
	; Moving 80 bytes from rsp to rax 
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 80
	push rax
	mov rax, 2
	push rax
.jump3865:
.jump3858:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 's'
	add qword [rsp + 16], 1
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3856 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3856 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3856 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const714] ; 511
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3869
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3869:
	cmp rax, [rsp + 24]
	jl .jump3870
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3870:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3871
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3871:
	cmp rax, [rsp + 32]
	jl .jump3872
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3872:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3873
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3873:
	cmp rax, [rsp + 40]
	jl .jump3874
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3874:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3875
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3875:
	cqo
	idiv r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3876
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3876:
	cmp rax, [rsp + 8]
	jl .jump3877
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3877:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3845
.jump3844:
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3878
	sub rsp, 40
	; Moving 40 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 160 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 160 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 160 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	jmp .jump3879
.jump3878:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3880
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3880:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3881
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3881:
	; Computing bound for 'r'
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3882
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3884
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	jmp .jump3885
.jump3884:
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
.jump3885:
	jmp .jump3883
.jump3882:
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
.jump3883:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3886
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3886:
	; Computing bound for 'q'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	mov rax, [rel const621] ; 901
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3887
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3887:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 901 
	jno .jump3888
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3888:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump3889: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 0], 1
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3889 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3890
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3890:
	cmp rax, [rsp + 8]
	jl .jump3891
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3891:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3892
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3892:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (array[q : 901] (- (- p)))[(- o)] 
	jno .jump3893
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3893:
	imul rdi, [rsp + 0 + 8] ; multiply by (if true then (if m then k else h) else j) 
	jno .jump3894
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3894:
	imul rdi, [rsp + 0 + 16] ; multiply by (b + h) 
	jno .jump3895
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3895:
	imul rdi, [rsp + 0 + 24] ; multiply by o 
	jno .jump3896
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3896:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump3897: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3898
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3898:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3899
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3899:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by (- t) 
	jno .jump3900
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3900:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump3901
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3901:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3902: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3902 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3902 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3903
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3903:
	cmp rax, [rsp + 16]
	jl .jump3904
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3904:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3905
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3905:
	cmp rax, [rsp + 24]
	jl .jump3906
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3906:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3907
	mov rax, [rel const715] ; 80.43
	push rax
	jmp .jump3908
.jump3907:
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump3908:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3909
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3909:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3910
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3910:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3911
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3911:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3912
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3912:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3913: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3914
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3914:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3915
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3915:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 352 to rsp 
		mov r10, [rbp - 352 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3916
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3916:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3917: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'A'
	add qword [rsp + 16], 1
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3917 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3917 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3917 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'x'
	add qword [rsp + 24], 1
	; Compare x to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3913 ; If x < bound, next iter
	mov qword [rsp + 24], 0 ; x = 0
	add qword [rsp + 16], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3913 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3913 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3913 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 't'
	add qword [rsp + 24], 1
	; Compare t to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3897 ; If t < bound, next iter
	mov qword [rsp + 24], 0 ; t = 0
	add qword [rsp + 16], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3897 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3897 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3897 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump3879:
.jump3845:
	jmp .jump3843
.jump3842:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3918
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3918:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3919
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	jmp .jump3920
.jump3919:
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
.jump3920:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3921
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3921:
	; Computing bound for 'r'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3922
	mov rax, [rel const655] ; 789
	push rax
	jmp .jump3923
.jump3922:
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
.jump3923:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3924
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3924:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3925
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3925:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3926
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3926:
	; Computing bound for 'q'
	mov rax, [rel const422] ; 810
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3927
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3927:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump3928: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 't'
	add qword [rsp + 24], 1
	; Compare t to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3928 ; If t < bound, next iter
	mov qword [rsp + 24], 0 ; t = 0
	add qword [rsp + 16], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3928 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3928 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3928 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3929
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3929:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3930
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3930:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump3931
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3931:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[q : 810, r : k, s : j, t : (if f then 789 else k)] k) 
	jno .jump3932
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3932:
	imul rdi, [rsp + 0 + 16] ; multiply by (if f then j else o) 
	jno .jump3933
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3933:
	imul rdi, [rsp + 0 + 24] ; multiply by p 
	jno .jump3934
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3934:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump3935: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3936
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3938
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3938:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3939
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3939:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump3940
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3940:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump3941
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3941:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3942: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3942 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3942 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump3937
.jump3936:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3943
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3943:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3944
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3944:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump3945
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3945:
	imul rdi, [rsp + 0 + 8] ; multiply by t 
	jno .jump3946
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3946:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3947: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3947 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3947 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump3937:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 't'
	add qword [rsp + 24], 1
	; Compare t to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3935 ; If t < bound, next iter
	mov qword [rsp + 24], 0 ; t = 0
	add qword [rsp + 16], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3935 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3935 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3935 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const716] ; 990
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3948
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3948:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump3949: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 0], 1
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3949 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3950
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3950:
	cmp rax, [rsp + 32]
	jl .jump3951
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3951:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3952
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3952:
	cmp rax, [rsp + 40]
	jl .jump3953
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3953:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3954
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3954:
	cmp rax, [rsp + 48]
	jl .jump3955
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3955:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3956
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump3956:
	cmp rax, [rsp + 56]
	jl .jump3957
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump3957:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3958
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3959
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3959:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3960
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3960:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3961
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3961:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump3962
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3962:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump3963
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3963:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump3964
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump3964:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump3965: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const8] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 's'
	add qword [rsp + 16], 1
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3965 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3965 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3965 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3966
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3966:
	cmp rax, [rsp + 24]
	jl .jump3967
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3967:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3968
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3968:
	cmp rax, [rsp + 32]
	jl .jump3969
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3969:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3970
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3970:
	cmp rax, [rsp + 40]
	jl .jump3971
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3971:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
.jump3958:
	push rax
	pop rax
	cmp rax, 0
	je .jump3972
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3974
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3976
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3976:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3977
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3977:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3978
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3978:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3979
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3979:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump3980
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3980:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump3981
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3981:
	imul rdi, [rsp + 0 + 16] ; multiply by o 
	jno .jump3982
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3982:
	imul rdi, [rsp + 0 + 24] ; multiply by i 
	jno .jump3983
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3983:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump3984: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 't'
	add qword [rsp + 24], 1
	; Compare t to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3984 ; If t < bound, next iter
	mov qword [rsp + 24], 0 ; t = 0
	add qword [rsp + 16], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3984 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3984 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3984 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump3975
.jump3974:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3985
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3985:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3986
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3986:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3987
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump3987:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3988
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3988:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump3989
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3989:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump3990
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3990:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump3991
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3991:
	imul rdi, [rsp + 0 + 24] ; multiply by p 
	jno .jump3992
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3992:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump3993: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const717] ; 918
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 't'
	add qword [rsp + 24], 1
	; Compare t to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3993 ; If t < bound, next iter
	mov qword [rsp + 24], 0 ; t = 0
	add qword [rsp + 16], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3993 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3993 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3993 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump3975:
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3994
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	jmp .jump3995
.jump3994:
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
.jump3995:
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3996
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3996:
	cmp rax, [rsp + 32]
	jl .jump3997
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3997:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3998
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3998:
	cmp rax, [rsp + 40]
	jl .jump3999
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3999:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4000
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4000:
	cmp rax, [rsp + 48]
	jl .jump4001
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4001:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4002
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4002:
	cmp rax, [rsp + 56]
	jl .jump4003
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4003:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3973
.jump3972:
	mov rax, [rel const322] ; 781
	push rax
.jump3973:
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4004
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4004:
	cmp rax, [rsp + 16]
	jl .jump4005
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4005:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4006
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4006:
	cmp rax, [rsp + 24]
	jl .jump4007
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4007:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4008
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4008:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4009
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4009:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4010
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump4011
.jump4010:
	mov rax, [rel const367] ; 295
	push rax
.jump4011:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4012
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4012:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4013
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4013:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4014
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4014:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (p % p) 
	jno .jump4015
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4015:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (j != p) then (- b) else 295) 
	jno .jump4016
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4016:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump4017
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4017:
imul rdi, [rsp + 0 + 24] ; multiply by ((array[q : k, r : (sum[q : 810, r : k, s : j, t : (if f then 789 else k)] k), s : (if f then j else o), t : p] (if m then (array[u : k, v : r] b) else (array[u : p, v : t] t)))[(- (- (sum[q : o] p))), (- h), h, (- 990)][p, (if (false && (array[q : i, r : k, s : p] true)[k, b, (- o)]) then (if (p > o) then (array[q : k, r : o, s : o, t : i] j) else (array[q : k, r : k, s : h, t : p] 918))[j, j, k, (if f then h else j)] else 781)] + o) 
	jno .jump4018
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4018:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump4019: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const8] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump4020
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
.jump4020:
	push rax
	pop rax
	cmp rax, 0
	je .jump4021
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4023
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4025
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4025:
	; Computing bound for 'u'
	mov rax, [rel const494] ; 713
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4026
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4026:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump4027: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4027 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4027 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump4024
.jump4023:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump4024:
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const718] ; 3.07
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	jmp .jump4022
.jump4021:
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4028
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	jmp .jump4029
.jump4028:
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
.jump4029:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4030
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4032
	mov rax, [rel const8] ; True
	push rax
	pop rax
.jump4032:
	push rax
	pop rax
	cmp rax, 0
	jne .jump4033
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
.jump4033:
	push rax
	pop rax
	cmp rax, 0
	je .jump4034
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4036
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4036:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4037
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4037:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4038
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4038:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump4039
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4039:
	imul rdi, [rsp + 0 + 8] ; multiply by (- t) 
	jno .jump4040
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4040:
	imul rdi, [rsp + 0 + 16] ; multiply by o 
	jno .jump4041
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4041:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump4042: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 16], 1
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4042 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4042 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4042 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4035
.jump4034:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4043
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4043:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4044
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4044:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4045
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4045:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump4046
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4046:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump4047
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4047:
	imul rdi, [rsp + 0 + 16] ; multiply by r 
	jno .jump4048
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4048:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump4049: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const94] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 16], 1
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4049 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4049 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4049 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4035:
	jmp .jump4031
.jump4030:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4050
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4050:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4051
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
.jump4051:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4052
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4052:
	; Computing bound for 'v'
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4053
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4053:
	cmp rax, [rsp + 8]
	jl .jump4054
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4054:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4055
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4055:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4056
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4056:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump4057
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4057:
	imul rdi, [rsp + 0 + 8] ; multiply by a[j] 
	jno .jump4058
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4058:
	imul rdi, [rsp + 0 + 16] ; multiply by (i % s) 
	jno .jump4059
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4059:
	imul rdi, [rsp + 0 + 24] ; multiply by k 
	jno .jump4060
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4060:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump4061: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4062
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4062:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4063
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4063:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4064
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4064:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump4065
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4065:
	imul rdi, [rsp + 0 + 8] ; multiply by j 
	jno .jump4066
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4066:
	imul rdi, [rsp + 0 + 16] ; multiply by s 
	jno .jump4067
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4067:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump4068: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'A'
	add qword [rsp + 16], 1
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4068 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4068 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4068 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'x'
	add qword [rsp + 24], 1
	; Compare x to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4061 ; If x < bound, next iter
	mov qword [rsp + 24], 0 ; x = 0
	add qword [rsp + 16], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4061 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4061 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4061 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4069
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4069:
	cmp rax, [rsp + 32]
	jl .jump4070
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4070:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4071
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4071:
	cmp rax, [rsp + 40]
	jl .jump4072
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4072:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4073
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4073:
	cmp rax, [rsp + 48]
	jl .jump4074
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4074:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4075
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4075:
	cmp rax, [rsp + 56]
	jl .jump4076
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4076:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4031:
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4077
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4077:
	cmp rax, [rsp + 24]
	jl .jump4078
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4078:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4079
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4079:
	cmp rax, [rsp + 32]
	jl .jump4080
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4080:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4081
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4081:
	cmp rax, [rsp + 40]
	jl .jump4082
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4082:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4022:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 't'
	add qword [rsp + 24], 1
	; Compare t to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4019 ; If t < bound, next iter
	mov qword [rsp + 24], 0 ; t = 0
	add qword [rsp + 16], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4019 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4019 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4019 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump3843:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4083
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4083:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump4084
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4084:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump4085: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4086
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4086:
	; Computing bound for 'x'
	mov rax, [rel const320] ; 396
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4087
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4087:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4088
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const12] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4088:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4089
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4089:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump4090: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'y'
	add qword [rsp + 16], 1
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4090 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4090 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4090 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4091
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4091:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[w : (i % k), x : 396, y : i] i) 
	jno .jump4092
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4092:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump4093: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4094
	mov rax, [rel const719] ; 12.56
	push rax
	jmp .jump4095
.jump4094:
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump4095:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 0], 1
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4093 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 32]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'v'
	add qword [rsp + 0], 1
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4085 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4096
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4096:
	cmp rax, [rsp + 8]
	jl .jump4097
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4097:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4098
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4098:
	cmp rax, [rsp + 8]
	jl .jump4099
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4099:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4100
	mov rax, [rel const720] ; 90.93
	push rax
	jmp .jump4101
.jump4100:
	mov rax, [rel const721] ; 14.25
	push rax
.jump4101:
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4102
	lea rdi, [rel const35] ; 'divide by zero'
	call _fail_assertion
.jump4102:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4103
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4103:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4104
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4104:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4105
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4105:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- i) 
	jno .jump4106
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4106:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump4107
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4107:
	imul rdi, [rsp + 0 + 16] ; multiply by (- (o - (p / (b + s)))) 
	jno .jump4108
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4108:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump4109: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'y'
	add qword [rsp + 16], 1
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4109 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4109 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4109 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const724] ; 36.86
	push rax
	mov rax, [rel const725] ; 49.11
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4397
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4397:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4398
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4398:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4399
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4399:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4400
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4400:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump4401: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const726] ; 94.78
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'E'
	add qword [rsp + 24], 1
	; Compare E to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4401 ; If E < bound, next iter
	mov qword [rsp + 24], 0 ; E = 0
	add qword [rsp + 16], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4401 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4401 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4401 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4402
	sub rsp, 40
	; Moving 40 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 160 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 160 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 160 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4404
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4404:
	cmp rax, [rsp + 32]
	jl .jump4405
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4405:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4406
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4406:
	cmp rax, [rsp + 40]
	jl .jump4407
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4407:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4408
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4408:
	cmp rax, [rsp + 48]
	jl .jump4409
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4409:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4410
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4410:
	cmp rax, [rsp + 56]
	jl .jump4411
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4411:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4412
	sub rsp, 24
	; Moving 24 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 200 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	jmp .jump4413
.jump4412:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4414
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4414:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4415
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4415:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by t 
	jno .jump4416
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4416:
	imul rdi, [rsp + 0 + 8] ; multiply by y 
	jno .jump4417
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4417:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump4418: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'C'
	add qword [rsp + 8], 1
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4418 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4418 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump4413:
	jmp .jump4403
.jump4402:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4419
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4419:
	; Computing bound for 'B'
	mov rax, [rel const727] ; 409
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4420
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4420:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 409 
	jno .jump4421
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4421:
	imul rdi, [rsp + 0 + 8] ; multiply by (- y) 
	jno .jump4422
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4422:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump4423: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'C'
	add qword [rsp + 8], 1
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4423 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4423 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump4403:
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4424
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4424:
	cmp rax, [rsp + 16]
	jl .jump4425
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4425:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4426
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4426:
	cmp rax, [rsp + 24]
	jl .jump4427
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4427:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4428
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4428:
	cmp rax, [rsp + 8]
	jl .jump4429
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4429:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump4430
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump4431
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
.jump4431:
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4432
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	jmp .jump4433
.jump4432:
	mov rax, [rel const8] ; True
	push rax
.jump4433:
	pop rax
.jump4430:
	push rax
	pop rax
	cmp rax, 0
	je .jump4434
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4436
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4436:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4437
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4437:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4438
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4438:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4439
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4439:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof rgba[] 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump4440
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4440:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump4441
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4441:
	imul rdi, [rsp + 0 + 16] ; multiply by r 
	jno .jump4442
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4442:
	imul rdi, [rsp + 0 + 24] ; multiply by o 
	jno .jump4443
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4443:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump4444: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4445
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4447
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4447:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump4448
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4448:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump4449: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'F'
	add qword [rsp + 0], 1
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4449 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump4446
.jump4445:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4450
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4450:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by t 
	jno .jump4451
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4451:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump4452: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'F'
	add qword [rsp + 0], 1
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4452 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump4446:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'E'
	add qword [rsp + 24], 1
	; Compare E to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4444 ; If E < bound, next iter
	mov qword [rsp + 24], 0 ; E = 0
	add qword [rsp + 16], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4444 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4444 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4444 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const728] ; 41.73
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4453
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump4454
.jump4453:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump4454:
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4455
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4457
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4457:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump4458: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4459
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump4460
.jump4459:
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
.jump4460:
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'B'
	add qword [rsp + 0], 1
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4458 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump4456
.jump4455:
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
.jump4456:
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4461
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4461:
	cmp rax, [rsp + 32]
	jl .jump4462
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4462:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4463
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4463:
	cmp rax, [rsp + 40]
	jl .jump4464
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4464:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4465
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4465:
	cmp rax, [rsp + 48]
	jl .jump4466
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4466:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4467
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4467:
	cmp rax, [rsp + 56]
	jl .jump4468
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4468:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4469
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	jmp .jump4470
.jump4469:
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump4470:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4471
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4471:
	cmp rax, [rsp + 8]
	jl .jump4472
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4472:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	jmp .jump4435
.jump4434:
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
.jump4435:
	call _get_time
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 24
	lea rdi, [rsp]
	lea rsi, [rel const729] ; 'C.png'
	call _read_image
	call _get_time
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp + 24]
	subsd xmm0, xmm1
	call _print_time
	sub rsp, 8 ; Add alignment
	mov rax, [rel const8] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4473
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4475
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4477
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4477:
	; Computing bound for 'F'
	sub rsp, 32
	; Moving 32 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 280 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 280 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4478
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4478:
	cmp rax, [rsp + 24]
	jl .jump4479
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4479:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4480
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4480:
	cmp rax, [rsp + 32]
	jl .jump4481
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4481:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4482
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4482:
	cmp rax, [rsp + 40]
	jl .jump4483
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4483:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4484
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4484:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by w[o, u, b] 
	jno .jump4485
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4485:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump4486
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4486:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump4487: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4488
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 368 to rsp 
		mov r10, [rbp - 368 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4490
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4490:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4491
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4491:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4492
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4492:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump4493
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4493:
	imul rdi, [rsp + 0 + 8] ; multiply by j 
	jno .jump4494
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4494:
	imul rdi, [rsp + 0 + 16] ; multiply by G 
	jno .jump4495
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4495:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
.jump4496: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const8] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'J'
	add qword [rsp + 16], 1
	; Compare J to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4496 ; If J < bound, next iter
	mov qword [rsp + 16], 0 ; J = 0
	add qword [rsp + 8], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4496 ; If I < bound, next iter
	mov qword [rsp + 8], 0 ; I = 0
	add qword [rsp + 0], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4496 ; If H < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4489
.jump4488:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4497
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4497:
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4498
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4498:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 368 to rsp 
		mov r10, [rbp - 368 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4499
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4499:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by G 
	jno .jump4500
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4500:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump4501
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4501:
	imul rdi, [rsp + 0 + 16] ; multiply by y 
	jno .jump4502
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4502:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'J' to 0
	mov rax, 0
	push rax
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
.jump4503: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'J'
	add qword [rsp + 16], 1
	; Compare J to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4503 ; If J < bound, next iter
	mov qword [rsp + 16], 0 ; J = 0
	add qword [rsp + 8], 1 ; I++
	; Compare I to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4503 ; If I < bound, next iter
	mov qword [rsp + 8], 0 ; I = 0
	add qword [rsp + 0], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4503 ; If H < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4489:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'G'
	add qword [rsp + 8], 1
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4487 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4487 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4504
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4504:
	cmp rax, [rsp + 16]
	jl .jump4505
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4505:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4506
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4506:
	cmp rax, [rsp + 24]
	jl .jump4507
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4507:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4476
.jump4475:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'I'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4508
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4508:
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4509
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4509:
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4510
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4510:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4511
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4511:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump4512
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4512:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump4513
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4513:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump4514
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4514:
	imul rdi, [rsp + 0 + 24] ; multiply by j 
	jno .jump4515
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4515:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'I' to 0
	mov rax, 0
	push rax
	; Initialize 'H' to 0
	mov rax, 0
	push rax
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump4516: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4517
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4517:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 384 to rsp 
		mov r10, [rbp - 384 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4518
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4518:
	; Computing bound for 'J'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4519
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4519:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump4520
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4520:
	imul rdi, [rsp + 0 + 8] ; multiply by I 
	jno .jump4521
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4521:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump4522
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4522:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
	; Initialize 'J' to 0
	mov rax, 0
	push rax
.jump4523: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'L'
	add qword [rsp + 16], 1
	; Compare L to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4523 ; If L < bound, next iter
	mov qword [rsp + 16], 0 ; L = 0
	add qword [rsp + 8], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4523 ; If K < bound, next iter
	mov qword [rsp + 8], 0 ; K = 0
	add qword [rsp + 0], 1 ; J++
	; Compare J to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4523 ; If J < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'I'
	add qword [rsp + 24], 1
	; Compare I to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4516 ; If I < bound, next iter
	mov qword [rsp + 24], 0 ; I = 0
	add qword [rsp + 16], 1 ; H++
	; Compare H to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4516 ; If H < bound, next iter
	mov qword [rsp + 16], 0 ; H = 0
	add qword [rsp + 8], 1 ; G++
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4516 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4516 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4524
	sub rsp, 8
	; Moving 8 bytes from rbp - 312 to rsp 
		mov r10, [rbp - 312 + 0]
		mov [rsp + 0], r10
	jmp .jump4525
.jump4524:
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
.jump4525:
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4526
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4526:
	cmp rax, [rsp + 32]
	jl .jump4527
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4527:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4528
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4528:
	cmp rax, [rsp + 40]
	jl .jump4529
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4529:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4530
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4530:
	cmp rax, [rsp + 48]
	jl .jump4531
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4531:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4532
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4532:
	cmp rax, [rsp + 56]
	jl .jump4533
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4533:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4476:
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4534
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 200 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4536
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4536:
	cmp rax, [rsp + 16]
	jl .jump4537
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4537:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4538
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4538:
	cmp rax, [rsp + 24]
	jl .jump4539
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4539:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 312 to rsp 
		mov r10, [rbp - 312 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4540
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4540:
	cmp rax, [rsp + 8]
	jl .jump4541
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4541:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4542
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	jmp .jump4543
.jump4542:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4544
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4544:
	; Computing bound for 'F'
	mov rax, [rel const730] ; 278
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4545
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump4545:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 278) 
	jno .jump4546
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4546:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump4547
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump4547:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump4548: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'G'
	add qword [rsp + 8], 1
	; Compare G to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4548 ; If G < bound, next iter
	mov qword [rsp + 8], 0 ; G = 0
	add qword [rsp + 0], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4548 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 320 to rsp 
		mov r10, [rbp - 320 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4549
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4549:
	cmp rax, [rsp + 16]
	jl .jump4550
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4550:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4551
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump4551:
	cmp rax, [rsp + 24]
	jl .jump4552
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump4552:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4543:
	jmp .jump4535
.jump4534:
	sub rsp, 8
	; Moving 8 bytes from rbp - 312 to rsp 
		mov r10, [rbp - 312 + 0]
		mov [rsp + 0], r10
.jump4535:
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4553
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump4554
.jump4553:
	sub rsp, 8
	; Moving 8 bytes from rbp - 320 to rsp 
		mov r10, [rbp - 320 + 0]
		mov [rsp + 0], r10
.jump4554:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4555
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4555:
	cmp rax, [rsp + 24]
	jl .jump4556
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4556:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4557
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4557:
	cmp rax, [rsp + 32]
	jl .jump4558
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4558:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4559
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4559:
	cmp rax, [rsp + 40]
	jl .jump4560
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4560:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	jmp .jump4474
.jump4473:
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
.jump4474:
	lea rdi, [rel const731] ; '(BoolType)'
	lea rsi, [rsp]
	call _show
	add rsp, 8
	add rsp, 8 ; Remove alignment
	sub rsp, 8 ; Add alignment
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5920
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5922
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5922:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5923
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5923:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5924
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	jmp .jump5925
.jump5924:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5926
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5926:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump5927: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'K'
	add qword [rsp + 0], 1
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5927 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump5925:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5928
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5928:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[][] 
imul rdi, [rsp + 0 + 0] ; multiply by (if m then o else (sum[K : t] u)) 
	jno .jump5929
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5929:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump5930
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5930:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump5931
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5931:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump5932: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 312 to rsp 
		mov r10, [rbp - 312 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5933
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5933:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[] 
	imul rdi, [rsp + 0 + 0] ; multiply by E 
	jno .jump5934
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5934:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5935: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 32]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'N'
	add qword [rsp + 0], 1
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5935 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'M'
	add qword [rsp + 16], 1
	; Compare M to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5932 ; If M < bound, next iter
	mov qword [rsp + 16], 0 ; M = 0
	add qword [rsp + 8], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5932 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5932 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5936
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5936:
	cmp rax, [rsp + 8]
	jl .jump5937
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5937:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5938
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5938:
	cmp rax, [rsp + 24]
	jl .jump5939
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5939:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5940
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5940:
	cmp rax, [rsp + 32]
	jl .jump5941
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5941:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5942
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5942:
	cmp rax, [rsp + 40]
	jl .jump5943
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5943:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5944
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump5944:
	cmp rax, [rsp + 8]
	jl .jump5945
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump5945:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5921
.jump5920:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5946
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5946:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump5947
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5947:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump5948: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 160 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 160 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 160 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const94] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5949
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5951
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5951:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5952
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5952:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5953
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5953:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5954
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5954:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by u 
	jno .jump5955
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5955:
	imul rdi, [rsp + 0 + 8] ; multiply by j 
	jno .jump5956
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5956:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump5957
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5957:
	imul rdi, [rsp + 0 + 24] ; multiply by x 
	jno .jump5958
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5958:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump5959: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5959 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5959 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5959 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5959 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump5950
.jump5949:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5960
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5960:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5961
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5961:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 352 to rsp 
		mov r10, [rbp - 352 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5962
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5962:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5963
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5963:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump5964
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5964:
	imul rdi, [rsp + 0 + 8] ; multiply by K 
	jno .jump5965
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5965:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump5966
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5966:
	imul rdi, [rsp + 0 + 24] ; multiply by j 
	jno .jump5967
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5967:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump5968: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5968 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5968 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5968 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5968 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump5950:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5969
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5969:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 352 to rsp 
		mov r10, [rbp - 352 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5970
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5970:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by K 
	jno .jump5971
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5971:
	imul rdi, [rsp + 0 + 8] ; multiply by j 
	jno .jump5972
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5972:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump5973: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 312 to rsp 
		mov r10, [rbp - 312 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5974
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5974:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5975
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5975:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump5976
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5976:
	imul rdi, [rsp + 0 + 8] ; multiply by E 
	jno .jump5977
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5977:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5978: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5978 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5978 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5973 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5973 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 312 to rsp 
		mov r10, [rbp - 312 + 0]
		mov [rsp + 0], r10
	pop rdi
	pop rsi
	call _H
	add rsp, 24
	add rsp, 40
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 312 to rsp 
		mov r10, [rbp - 312 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5979
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5979:
	cmp rax, [rsp + 32]
	jl .jump5980
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5980:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5981
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5981:
	cmp rax, [rsp + 40]
	jl .jump5982
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5982:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5983
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5983:
	cmp rax, [rsp + 48]
	jl .jump5984
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5984:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5985
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5985:
	cmp rax, [rsp + 56]
	jl .jump5986
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5986:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 0], 1
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5948 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump5921:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5987
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5987:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump5988
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5988:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump5989: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5990
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5992
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5992:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5993
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5993:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5994
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump5994:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump5995
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5995:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump5996
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5996:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump5997
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump5997:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump5998: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'N'
	add qword [rsp + 16], 1
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5998 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5998 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5998 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump5991
.jump5990:
	mov rax, [rel const771] ; 53.6
	push rax
	mov rax, [rel const772] ; 41.54
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5999
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6001
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6001:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6002
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6002:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 320 to rsp 
		mov r10, [rbp - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6003
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6003:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by D 
	jno .jump6004
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump6004:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump6005
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump6005:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump6006
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump6006:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6007: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 416 to rsp 
		mov r10, [rbp - 416 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'N'
	add qword [rsp + 16], 1
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6007 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6007 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6007 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump6000
.jump5999:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6008
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6008:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6009
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6009:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 368 to rsp 
		mov r10, [rbp - 368 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6010
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6010:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by K 
	jno .jump6011
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump6011:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump6012
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump6012:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump6013
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump6013:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6014: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'N'
	add qword [rsp + 16], 1
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6014 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6014 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6014 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump6000:
.jump5991:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'K'
	add qword [rsp + 0], 1
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5989 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6015
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump6015:
	cmp rax, [rsp + 8]
	jl .jump6016
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump6016:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 320 to rsp 
		mov r10, [rbp - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6017
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6017:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6018
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6018:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6019
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6019:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6020
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6020:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump6021: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6022
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6022:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6023
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6023:
	; Computing bound for 'O'
	mov rax, [rel const144] ; 646
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6024
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6024:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 646 
	jno .jump6025
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump6025:
	imul rdi, [rsp + 0 + 8] ; multiply by z 
	jno .jump6026
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump6026:
	imul rdi, [rsp + 0 + 16] ; multiply by z 
	jno .jump6027
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump6027:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump6028: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6029
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6029:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6030
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6030:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6031
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6031:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6032
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6032:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump6033
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump6033:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump6034
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump6034:
	imul rdi, [rsp + 0 + 16] ; multiply by j 
	jno .jump6035
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump6035:
	imul rdi, [rsp + 0 + 24] ; multiply by s 
	jno .jump6036
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump6036:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump6037: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 424 to rsp 
		mov r10, [rbp - 424 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'U'
	add qword [rsp + 24], 1
	; Compare U to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6037 ; If U < bound, next iter
	mov qword [rsp + 24], 0 ; U = 0
	add qword [rsp + 16], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6037 ; If T < bound, next iter
	mov qword [rsp + 16], 0 ; T = 0
	add qword [rsp + 8], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6037 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6037 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6028 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6028 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6028 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6038
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6038:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6039
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6039:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6040
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6040:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump6041: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 536 to rsp 
		mov r10, [rbp - 536 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6041 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6041 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6041 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6042
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6042:
	cmp rax, [rsp + 24]
	jl .jump6043
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6043:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6044
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6044:
	cmp rax, [rsp + 32]
	jl .jump6045
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6045:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6046
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6046:
	cmp rax, [rsp + 40]
	jl .jump6047
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6047:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 432 to rsp 
		mov r10, [rbp - 432 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6048
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6048:
	cmp rax, [rsp + 32]
	jl .jump6049
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6049:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6050
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6050:
	cmp rax, [rsp + 40]
	jl .jump6051
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6051:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6052
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6052:
	cmp rax, [rsp + 48]
	jl .jump6053
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6053:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6054
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6054:
	cmp rax, [rsp + 56]
	jl .jump6055
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6055:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'N'
	add qword [rsp + 24], 1
	; Compare N to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6021 ; If N < bound, next iter
	mov qword [rsp + 24], 0 ; N = 0
	add qword [rsp + 16], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6021 ; If M < bound, next iter
	mov qword [rsp + 16], 0 ; M = 0
	add qword [rsp + 8], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6021 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6021 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6056
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump6056:
	cmp rax, [rsp + 24]
	jl .jump6057
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump6057:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6058
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump6058:
	cmp rax, [rsp + 32]
	jl .jump6059
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump6059:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6060
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump6060:
	cmp rax, [rsp + 40]
	jl .jump6061
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump6061:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6062
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump6062:
	cmp rax, [rsp + 8]
	jl .jump6063
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump6063:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6064
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6066
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6068
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6068:
	; Computing bound for 'L'
	mov rax, [rel const634] ; 583
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6069
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6069:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6070
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6070:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump6071: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'M'
	add qword [rsp + 16], 1
	; Compare M to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6071 ; If M < bound, next iter
	mov qword [rsp + 16], 0 ; M = 0
	add qword [rsp + 8], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6071 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6071 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6072
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6072:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6073
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6073:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6074
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6074:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6075
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6075:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump6076
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump6076:
	imul rdi, [rsp + 0 + 8] ; multiply by t 
	jno .jump6077
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump6077:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump6078
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump6078:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[K : z, L : 583, M : z] y) 
	jno .jump6079
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump6079:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump6080: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 320 to rsp 
		mov r10, [rbp - 320 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 320 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 320 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'N'
	add qword [rsp + 24], 1
	; Compare N to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6080 ; If N < bound, next iter
	mov qword [rsp + 24], 0 ; N = 0
	add qword [rsp + 16], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6080 ; If M < bound, next iter
	mov qword [rsp + 16], 0 ; M = 0
	add qword [rsp + 8], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6080 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6080 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const289] ; 180
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 320 to rsp 
		mov r10, [rbp - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6081
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump6081:
	cmp rax, [rsp + 32]
	jl .jump6082
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump6082:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6083
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump6083:
	cmp rax, [rsp + 40]
	jl .jump6084
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump6084:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6085
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump6085:
	cmp rax, [rsp + 48]
	jl .jump6086
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump6086:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6087
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump6087:
	cmp rax, [rsp + 56]
	jl .jump6088
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump6088:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump6067
.jump6066:
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6089
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 312 to rsp 
		mov r10, [rbp - 312 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6091
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6091:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by E 
	jno .jump6092
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6092:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump6093: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'K'
	add qword [rsp + 0], 1
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6093 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump6090
.jump6089:
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
.jump6090:
	mov rax, [rel const76] ; 596
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6094
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump6094:
	cmp rax, [rsp + 8]
	jl .jump6095
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump6095:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const773] ; 267
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6096
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6098
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6098:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6099
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6099:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6100
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6100:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6101
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6101:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by j 
	jno .jump6102
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6102:
	imul rdi, [rsp + 0 + 8] ; multiply by (- z) 
	jno .jump6103
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6103:
	imul rdi, [rsp + 0 + 16] ; multiply by t 
	jno .jump6104
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6104:
	imul rdi, [rsp + 0 + 24] ; multiply by o 
	jno .jump6105
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6105:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump6106: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'N'
	add qword [rsp + 24], 1
	; Compare N to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6106 ; If N < bound, next iter
	mov qword [rsp + 24], 0 ; N = 0
	add qword [rsp + 16], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6106 ; If M < bound, next iter
	mov qword [rsp + 16], 0 ; M = 0
	add qword [rsp + 8], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6106 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6106 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 272 to rsp 
		mov r10, [rbp - 272 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6107
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6107:
	; Computing bound for 'K'
	mov rax, [rel const378] ; 652
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6108
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6108:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 652 
	jno .jump6109
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump6109:
	imul rdi, [rsp + 0 + 8] ; multiply by (y - z) 
	jno .jump6110
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump6110:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump6111: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 320 to rsp 
		mov r10, [rbp - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6112
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6112:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6113
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6113:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump6114
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6114:
	imul rdi, [rsp + 0 + 8] ; multiply by D 
	jno .jump6115
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6115:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump6116: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const611] ; 892
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'N'
	add qword [rsp + 8], 1
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6116 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6116 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'L'
	add qword [rsp + 8], 1
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6111 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6111 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6117
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	jmp .jump6118
.jump6117:
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
.jump6118:
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	pop rdi
	pop rsi
	call _H
	add rsp, 24
	add rsp, 40
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6119
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6119:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6120
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6120:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump6121
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump6121:
imul rdi, [rsp + 0 + 8] ; multiply by H(s, (array[K : 652, L : (y - z)] (array[M : i, N : D] 892)), (array[K : j, L : (- z), M : t, N : o] e), ((f != m) == (if B then f else m))) 
	jno .jump6122
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump6122:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump6123: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6124
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6124:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from rbp - 312 to rsp 
		mov r10, [rbp - 312 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6125
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6125:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by E 
	jno .jump6126
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6126:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump6127
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6127:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump6128: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 72 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'N'
	add qword [rsp + 8], 1
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6128 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6128 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'L'
	add qword [rsp + 8], 1
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6123 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6123 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump6097
.jump6096:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6129
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6129:
	; Computing bound for 'K'
	mov rax, [rel const206] ; 411
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6130
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6130:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 411 
	jno .jump6131
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump6131:
	imul rdi, [rsp + 0 + 8] ; multiply by z 
	jno .jump6132
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump6132:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump6133: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6134
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6134:
	; Computing bound for 'M'
	mov rax, [rel const774] ; 948
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6135
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6135:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by 948 
	jno .jump6136
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6136:
	imul rdi, [rsp + 0 + 8] ; multiply by t 
	jno .jump6137
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6137:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump6138: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'N'
	add qword [rsp + 8], 1
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6138 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6138 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'L'
	add qword [rsp + 8], 1
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6133 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6133 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump6097:
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6139
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6139:
	cmp rax, [rsp + 8]
	jl .jump6140
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6140:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6141
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	jmp .jump6142
.jump6141:
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
.jump6142:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6143
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump6143:
	cmp rax, [rsp + 16]
	jl .jump6144
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump6144:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6145
	lea rdi, [rel const49] ; 'negative array index'
	call _fail_assertion
.jump6145:
	cmp rax, [rsp + 24]
	jl .jump6146
	lea rdi, [rel const50] ; 'index too large'
	call _fail_assertion
.jump6146:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump6067:
	jmp .jump6065
.jump6064:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6147
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6147:
	; Computing bound for 'K'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6148
	lea rdi, [rel const3] ; 'non-positive loop bound'
	call _fail_assertion
.jump6148:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump6149
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump6149:
	imul rdi, [rsp + 0 + 8] ; multiply by x 
	jno .jump6150
	lea rdi, [rel const27] ; 'overflow computing array size'
	call _fail_assertion
.jump6150:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
	; Initialize 'K' to 0
	mov rax, 0
	push rax
.jump6151: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'L'
	add qword [rsp + 8], 1
	; Compare L to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6151 ; If L < bound, next iter
	mov qword [rsp + 8], 0 ; L = 0
	add qword [rsp + 0], 1 ; K++
	; Compare K to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6151 ; If K < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump6065:
	lea rdi, [rel const775] ; 'K.png'
	call _write_image
	add rsp, 24
	add rsp, 8 ; Remove alignment
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	lea rdi, [rel const776] ; '(FloatType)'
	lea rsi, [rsp]
	call _show
	add rsp, 8
	add rsp, 8 ; Remove alignment
	sub rsp, 40
	; Moving 40 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 240 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 240 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 240 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	call _get_time
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	call _get_time
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp + 0]
	subsd xmm0, xmm1
	call _print_time
	add rsp, 360 ; Local variables
	pop r12 ; begin jpl_main postlude
	pop rbp
	ret

