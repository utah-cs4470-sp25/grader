global jpl_main
global _jpl_main
extern _fail_assertion
extern _jpl_alloc
extern _get_time
extern _show
extern _print
extern _print_time
extern _read_image
extern _write_image
extern _fmod
extern _sqrt
extern _exp
extern _sin
extern _cos
extern _tan
extern _asin
extern _acos
extern _atan
extern _log
extern _pow
extern _atan2
extern _to_int
extern _to_float

section .data
const0: dq 680
const1: db `non-positive loop bound`, 0
const2: dq 886
const3: dq 701
const4: dq 641
const5: dq 883
const6: db `negative array index`, 0
const7: db `index too large`, 0
const8: dq 262
const9: dq 294
const10: db `overflow computing array size`, 0
const11: dq 1
const12: dq 11.87
const13: dq 183
const14: dq 573
const15: dq 97.96
const16: dq 21.09
const17: dq 591
const18: dq 160
const19: dq 755
const20: db `divide by zero`, 0
const21: dq 766
const22: dq 172
const23: dq 503
const24: dq 30
const25: dq 569
const26: dq 0
const27: dq 578
const28: dq 346
const29: dq 201
const30: dq 153
const31: dq 891
const32: dq 438
const33: dq 892
const34: dq 59.27
const35: dq 69.15
const36: dq 406
const37: dq 994
const38: dq 726
const39: db `mod by zero`, 0
const40: dq 714
const41: dq 587
const42: dq 858
const43: dq 324
const44: dq 6
const45: dq 453
const46: dq 623
const47: dq 173
const48: dq 812
const49: dq 384
const50: dq 993
const51: dq 191
const52: dq 804
const53: dq 144
const54: dq 728
const55: dq 622
const56: dq 408
const57: dq 925
const58: dq 35
const59: dq 305
const60: dq 837
const61: dq 604
const62: dq 494
const63: dq 266
const64: dq 167
const65: dq 140
const66: dq 896
const67: dq 114
const68: dq 243
const69: dq 921
const70: dq 657
const71: dq 696
const72: dq 512
const73: dq 938
const74: dq 68
const75: dq 237
const76: dq 282
const77: dq 630
const78: dq 465
const79: dq 97
const80: dq 560
const81: dq 312
const82: dq 421
const83: dq 523
const84: dq 743
const85: dq 259
const86: dq 661
const87: dq 343
const88: dq 599
const89: dq 269
const90: dq 320
const91: dq 543
const92: dq 44.69
const93: dq 2.76
const94: dq 85.18
const95: dq 136
const96: dq 56
const97: dq 885
const98: dq 27
const99: dq 482
const100: dq 765
const101: dq 597
const102: dq 276
const103: dq 740
const104: dq 103
const105: dq 644
const106: dq 547
const107: dq 757
const108: dq 724
const109: dq 238
const110: dq 194
const111: dq 980
const112: dq 510
const113: dq 426
const114: dq 899
const115: dq 719
const116: dq 586
const117: dq 612
const118: dq 382
const119: dq 8.46
const120: dq 92.5
const121: dq 5.07
const122: dq 38.47
const123: dq 17.77
const124: dq 65.13
const125: dq 811
const126: dq 22
const127: dq 682
const128: dq 862
const129: dq 593
const130: dq 532
const131: dq 624
const132: dq 517
const133: dq 677
const134: dq 472
const135: dq 7.12
const136: dq 764
const137: dq 473
const138: dq 607
const139: dq 13
const140: dq 911
const141: dq 589
const142: dq 402
const143: dq 162
const144: dq 91
const145: dq 640
const146: dq 281
const147: dq 36
const148: dq 695
const149: dq 581
const150: dq 333
const151: dq 17.46
const152: dq 81.1
const153: dq 21.59
const154: dq 82
const155: dq 83
const156: dq 235
const157: dq 124
const158: dq 112
const159: dq 683
const160: dq 389
const161: dq 824
const162: dq 537
const163: dq 146
const164: dq 66.41
const165: dq 25.52
const166: dq 530
const167: dq 789
const168: dq 11
const169: dq 75.01
const170: dq 63.65
const171: dq 876
const172: dq 250
const173: dq 159
const174: dq 981
const175: dq 888
const176: dq 126
const177: dq 318
const178: dq 475
const179: dq 663
const180: dq 594
const181: dq 288
const182: dq 300
const183: dq 802
const184: dq 975
const185: dq 91.04
const186: dq 99.92
const187: dq 32.17
const188: dq 123
const189: dq 16.17
const190: dq 95.58
const191: dq 78.73
const192: dq 13.72
const193: dq 781
const194: dq 54.11
const195: dq 54.13
const196: dq 9.39
const197: dq 95.72
const198: dq 83.57
const199: dq 98.46
const200: dq 44.19
const201: dq 958
const202: dq 75.02
const203: dq 436
const204: dq 168
const205: dq 959
const206: dq 966
const207: dq 564
const208: dq 9.88
const209: dq 286
const210: dq 97.9
const211: dq 737
const212: dq 428
const213: dq 1000
const214: dq 548
const215: dq 70.14
const216: dq 350
const217: dq 93
const218: dq 749
const219: dq 61
const220: dq 947
const221: dq 904
const222: dq 769
const223: dq 579
const224: dq 514
const225: dq 104
const226: dq 813
const227: dq 378
const228: dq 865
const229: dq 545
const230: dq 817
const231: dq 257
const232: dq 918
const233: dq 62
const234: dq 720
const235: dq 868
const236: dq 889
const237: dq 956
const238: dq 370
const239: dq 880
const240: dq 20
const241: dq 838
const242: dq 354
const243: dq 920
const244: dq 531
const245: dq 792
const246: dq 718
const247: dq 192
const248: dq 358
const249: dq 241
const250: dq 946
const251: dq 460
const252: dq 729
const253: dq 965
const254: dq 664
const255: dq 447
const256: dq 455
const257: dq 855
const258: dq 462
const259: dq 267
const260: dq 618
const261: dq 518
const262: dq 636
const263: dq 485
const264: dq 458
const265: dq 939
const266: dq 738
const267: dq 555
const268: dq 944
const269: dq 392
const270: dq 147
const271: dq 98.74
const272: dq 506
const273: dq 55
const274: dq 600
const275: dq 295
const276: dq 566
const277: dq 987
const278: dq 38
const279: dq 686
const280: dq 848
const281: dq 974
const282: dq 156
const283: dq 135
const284: dq 387
const285: dq 914
const286: dq 598
const287: dq 847
const288: dq 7
const289: dq 675
const290: dq 403
const291: dq 409
const292: dq 28
const293: dq 479
const294: dq 256
const295: dq 806
const296: dq 908
const297: dq 923
const298: dq 643
const299: db `h`, 0
const300: dq 703
const301: dq 207
const302: dq 928
const303: dq 490
const304: dq 487
const305: dq 249
const306: dq 228
const307: dq 308
const308: dq 139
const309: dq 978
const310: dq 498
const311: dq 898
const312: dq 323
const313: dq 122
const314: dq 616
const315: dq 49.5
const316: dq 625
const317: dq 200
const318: dq 585
const319: dq 676
const320: dq 118
const321: dq 383
const322: dq 818
const323: dq 203
const324: dq 665
const325: dq 274
const326: dq 997
const327: dq 739
const328: dq 31
const329: dq 787
const330: dq 759
const331: dq 808
const332: dq 783
const333: dq 723
const334: dq 568
const335: dq 8
const336: dq 952
const337: dq 296
const338: dq 901
const339: dq 63.77
const340: dq 982
const341: dq 773
const342: dq 872
const343: dq 206
const344: dq 25.86
const345: dq 631
const346: dq 271
const347: dq 89
const348: dq 660
const349: dq 310
const350: dq 750
const351: dq 474
const352: dq 60
const353: dq 185
const354: dq 150
const355: dq 14
const356: dq 551
const357: dq 570
const358: dq 290
const359: dq 628
const360: dq 869
const361: dq 317
const362: dq 488
const363: dq 609
const364: dq 744
const365: dq 617
const366: dq 810
const367: dq 845
const368: dq 10
const369: dq 614
const370: dq 335
const371: dq 443
const372: dq 621
const373: dq 486
const374: dq 376
const375: dq 554
const376: dq 770
const377: dq 753
const378: dq 155
const379: dq 357
const380: dq 745
const381: dq 209
const382: dq 567
const383: dq 687
const384: dq 339
const385: dq 504
const386: dq 929
const387: dq 731
const388: dq 121
const389: dq 772
const390: dq 637
const391: dq 534
const392: dq 292
const393: dq 822
const394: dq 825
const395: dq 950
const396: dq 316
const397: dq 261
const398: dq 986
const399: dq 942
const400: dq 176
const401: dq 535
const402: dq 796
const403: dq 297
const404: dq 493
const405: dq 44
const406: dq 32
const407: dq 128
const408: dq 576
const409: dq 245
const410: dq 492
const411: dq 590
const412: dq 877
const413: dq 313
const414: dq 801
const415: dq 496
const416: dq 705
const417: dq 446
const418: dq 797
const419: dq 563
const420: dq 943
const421: dq 542
const422: dq 187
const423: dq 117
const424: dq 647
const425: dq 411
const426: dq 379
const427: dq 741
const428: dq 444
const429: dq 110
const430: dq 791
const431: dq 521
const432: dq 293
const433: dq 359
const434: dq 483
const435: dq 907
const436: dq 442
const437: dq 995
const438: dq 119
const439: dq 843
const440: dq 853
const441: dq 265
const442: dq 809
const443: dq 59
const444: dq 40
const445: dq 552
const446: dq 595
const447: dq 414
const448: dq 602
const449: dq 610
const450: dq 989
const451: db `k`, 0
const452: dq 827
const453: dq 15
const454: dq 143
const455: dq 971
const456: dq 24
const457: dq 633
const458: dq 34
const459: dq 12
const460: dq 972
const461: dq 839
const462: dq 325
const463: dq 807
const464: dq 344
const465: dq 902
const466: dq 219
const467: dq 149
const468: dq 326
const469: dq 42.84
const470: dq 60.96
const471: dq 9.16
const472: dq 10.44
const473: db `(BoolType)`, 0
const474: dq 400
const475: dq 88.19
const476: dq 198
const477: dq 721
const478: dq 440
const479: dq 224
const480: dq 208
const481: dq 800
const482: dq 556
const483: dq 992
const484: dq 873
const485: dq 996
const486: dq 85
const487: dq 178
const488: dq 513
const489: dq 329
const490: dq 583
const491: dq 37
const492: dq 549
const493: dq 216
const494: dq 39
const495: dq 48
const496: dq 645
const497: dq 431
const498: dq 699
const499: dq 710
const500: dq 388
const501: dq 746
const502: dq 502
const503: dq 805
const504: dq 16
const505: dq 21
const506: dq 575
const507: dq 841
const508: dq 507
const509: dq 478
const510: dq 405
const511: dq 211
const512: dq 674
const513: dq 348
const514: dq 819
const515: dq 131
const516: dq 697
const517: dq 255
const518: dq 856
const519: dq 984
const520: dq 164
const521: dq 415
const522: dq 81
const523: dq 611
const524: dq 709
const525: dq 991
const526: dq 233
const527: dq 439
const528: dq 175
const529: dq 968
const530: dq 756
const531: dq 77
const532: dq 671
const533: dq 341
const534: dq 418
const535: dq 214
const536: dq 651
const537: dq 395
const538: dq 174
const539: dq 18
const540: dq 603
const541: dq 424
const542: dq 355
const543: dq 977
const544: dq 330
const545: dq 561
const546: dq 336
const547: dq 69
const548: dq 793
const549: dq 291
const550: dq 481
const551: dq 642
const552: dq 553
const553: dq 248
const554: dq 148
const555: dq 850
const556: dq 62.86
const557: dq 469
const558: dq 231
const559: dq 309
const560: dq 931
const561: dq 736
const562: dq 717
const563: dq 369
const564: dq 304
const565: dq 638
const566: dq 704
const567: dq 713
const568: dq 125
const569: dq 84
const570: dq 398
const571: dq 451
const572: dq 91.18
const573: dq 64.43
const574: dq 19.12
const575: dq 18.16
const576: dq 85.16
const577: dq 23.41
const578: dq 396
const579: dq 23
const580: dq 2.2
const581: dq 239
const582: dq 449
const583: dq 588
const584: dq 299
const585: dq 897
const586: dq 166
const587: dq 558
const588: dq 401
const589: dq 700
const590: dq 768
const591: dq 859
const592: dq 132
const593: dq 107
const594: dq 385
const595: dq 860
const596: dq 51
const597: dq 25
const598: dq 605
const599: dq 445
const600: dq 456
const601: dq 830
const602: dq 955
const603: dq 8.89
const604: dq 31.13
const605: dq 94.56
const606: dq 35.65
const607: dq 68.99
const608: dq 6.41
const609: dq 3.82
const610: dq 18.3
const611: dq 20.06
const612: dq 71.61
const613: dq 277
const614: dq 463
const615: dq 49.24
const616: dq 78.95
const617: dq 33.35
const618: dq 29.3
const619: dq 32.77
const620: dq 229
const621: dq 681
const622: dq 711
const623: dq 733
const624: dq 90.34
const625: dq 47.21
const626: dq 43.44
const627: dq 217
const628: dq 60.78
const629: dq 170
const630: dq 933
const631: dq 979
const632: dq 88
const633: dq 509
const634: dq 63
const635: dq 258
const636: dq 50.75
const637: dq 814
const638: dq 669
const639: dq 88.48
const640: dq 416
const641: dq 648
const642: dq 275
const643: dq 375
const644: dq 49
const645: dq 550
const646: dq 895
const647: dq 528
const648: dq 515
const649: dq 188
const650: dq 452
const651: dq 525
const652: dq 836
const653: dq 366
const654: dq 615
const655: dq 53.41
const656: dq 84.3
const657: dq 76.12
const658: dq 7.93
const659: dq 39.6
const660: dq 21.25
const661: dq 851
const662: dq 197
const663: dq 919
const664: dq 434
const665: dq 338
const666: dq 519
const667: dq 92
const668: dq 954
const669: dq 41
const670: dq 747
const671: db `q`, 0
const672: dq 18.83
const673: dq 834
const674: db `r`, 0
const675: dq 2
const676: dq 113
const677: dq 732
const678: db `s`, 0
const679: dq 43.37
const680: dq 646
const681: dq 70
const682: dq 314
const683: dq 367
const684: dq 33.52
const685: dq 75.79
const686: dq 803
const687: dq 91.43
const688: dq 46.2
const689: dq 73.33
const690: dq 71.4
const691: dq 64.55
const692: dq 79.24
const693: dq 94.5
const694: dq 141
const695: dq 52.5
const696: dq 35.04
const697: dq 572
const698: dq 639
const699: dq 182
const700: dq 60.2
const701: dq 133
const702: dq 98.03
const703: dq 23.87
const704: dq 36.45
const705: dq 59.68
const706: dq 41.45
const707: dq 69.74
const708: dq 31.97
const709: dq 448
const710: db `k.png`, 0
const711: dq 864
const712: dq 189
const713: dq 306
const714: dq 937
const715: dq 90
const716: dq 536
const717: dq 777
const718: dq 75
const719: dq 735
const720: dq 130
const721: dq 340
const722: dq 280
const723: dq 397
const724: dq 596
const725: dq 94
const726: dq 210
const727: dq 706
const728: dq 365
const729: dq 524
const730: dq 4.68
const731: dq 64.27
const732: dq 29.74
const733: dq 45.34
const734: dq 459
const735: dq 349
const736: dq 158
const737: dq 656
const738: dq 28.02
const739: dq 435
const740: dq 679
const741: dq 109
const742: dq 46
const743: dq 91.69
const744: dq 43
const745: dq 659
const746: dq 31.79
const747: dq 53.55
const748: dq 10.13
const749: dq 62.44
const750: dq 967
const751: dq 608
const752: dq 363
const753: dq 960
const754: dq 840
const755: dq 332
const756: dq 78.97
const757: dq 650
const758: dq 961
const759: dq 31.89
const760: dq 22.1
const761: dq 50.47
const762: dq 74.58
const763: dq 425
const764: dq 85.99
const765: dq 776
const766: dq 180
const767: dq 30.36
const768: dq 9.7
const769: dq 205
const770: dq 790
const771: dq 171
const772: dq 54.69
const773: dq 99
const774: dq 287
const775: dq 337
const776: dq 92.51
const777: dq 795
const778: dq 626
const779: dq 927
const780: dq 42
const781: dq 10.54
const782: db `x`, 0
const783: dq 5.22
const784: dq 56.32
const785: dq 82.56
const786: dq 18.5
const787: dq 18.15
const788: dq 941
const789: db `E.png`, 0
const790: dq 56.03
const791: dq 59.4
const792: dq 65.15
const793: dq 21.2
const794: dq 562
const795: dq 15.32
const796: dq 9.84
const797: dq 81.89
const798: dq 97.31
const799: dq 76.36
const800: dq 32.12
const801: db `Y`, 0
const802: dq 33.43
const803: dq 7.58
const804: dq 90.09
const805: dq 35.35
const806: dq 40.55
const807: dq 19.26
const808: db `Q`, 0
const809: dq 199
const810: dq 887
const811: dq 82.03
const812: dq 92.34
const813: dq 99.9
const814: dq 179
const815: dq 592
const816: db `K`, 0
const817: dq 45.74
const818: db `L`, 0
const819: dq 230
const820: dq 177
const821: dq 748
const822: dq 372
const823: dq 99.71
const824: dq 43.06
const825: dq 90.12
const826: dq 88.94
const827: dq 13.67
const828: db `aa`, 0
const829: dq 29.75
const830: dq 45
const831: dq 27.06
const832: dq 16.33
const833: db `ae`, 0
const834: dq 47.7
const835: dq 752
const836: dq 381
const837: db `S.png`, 0

section .text
b:
_b:
	push rbp
	mov rbp, rsp
	push rdi
	push rsi
	mov rax, [rel const154] ; 82
	push rax
	mov rax, [rel const155] ; 83
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const156] ; 235
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump298
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump298:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump299
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump299:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump300
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump300:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump301
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump301:
	; Computing bound for 'g'
	mov rax, [rel const157] ; 124
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump302
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump302:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump303
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump304
.jump303:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump304:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump305
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump305:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump306
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump306:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump307
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump307:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump308: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 16], 1
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump308 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump308 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump308 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump309
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump309:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[f : c, g : c, h : (if false then e else e)] h) 
	jno .jump310
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump310:
	imul rdi, [rsp + 0 + 8] ; multiply by 124 
	jno .jump311
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump311:
	imul rdi, [rsp + 0 + 16] ; multiply by e 
	jno .jump312
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump312:
	imul rdi, [rsp + 0 + 24] ; multiply by ((e % 235) / e) 
	jno .jump313
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump313:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
.jump314: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump315
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump315:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump316
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump316:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump317
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump317:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump318
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump318:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump319
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump319:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump320
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump320:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump321
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump321:
	imul rdi, [rsp + 0 + 24] ; multiply by f 
	jno .jump322
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump322:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump323: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump323 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump323 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump323 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump323 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump324
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump324:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump325
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump325:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump326: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 8], 1
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump326 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump326 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump327
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump327:
	cmp rax, [rsp + 32]
	jl .jump328
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump328:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump329
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump329:
	cmp rax, [rsp + 40]
	jl .jump330
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump330:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump331
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump331:
	cmp rax, [rsp + 48]
	jl .jump332
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump332:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump333
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump333:
	cmp rax, [rsp + 56]
	jl .jump334
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump334:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 24], 1
	; Compare i to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump314 ; If i < bound, next iter
	mov qword [rsp + 24], 0 ; i = 0
	add qword [rsp + 16], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump314 ; If h < bound, next iter
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump314 ; If g < bound, next iter
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump314 ; If f < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const158] ; 112
	push rax
	mov rax, [rel const159] ; 683
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump335
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump335:
	push rax
	pop rax
	cmp rax, 0
	je .jump336
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump337
.jump336:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump338
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump339
.jump338:
	mov rax, [rel const160] ; 389
	push rax
.jump339:
.jump337:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump340
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump340:
	cmp rax, [rsp + 32]
	jl .jump341
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump341:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump342
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump342:
	cmp rax, [rsp + 40]
	jl .jump343
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump343:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump344
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump344:
	cmp rax, [rsp + 48]
	jl .jump345
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump345:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump346
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump346:
	cmp rax, [rsp + 56]
	jl .jump347
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump347:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump348
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump348:
	; Computing bound for 'i'
	mov rax, [rel const161] ; 824
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump349
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump349:
	; Computing bound for 'h'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump350
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump350:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump351
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump351:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump352: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const162] ; 537
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump352 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const163] ; 146
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump353
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump353:
	cmp rax, [rsp + 8]
	jl .jump354
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump354:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump355
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump355:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump356: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const164] ; 66.41
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump356 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump356 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump356 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const165] ; 25.52
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump357
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const166] ; 530
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump358
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump358:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump359
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump359:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump360
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump360:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump361
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump361:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump362: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump363
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump364
.jump363:
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
.jump364:
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump362 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump362 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump362 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump362 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
.jump357:
	push rax
	pop rax
	cmp rax, 0
	je .jump365
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump367
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump368
.jump367:
	mov rax, [rel const167] ; 789
	push rax
.jump368:
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump369
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump369:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump370
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump370:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump371
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump371:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump372
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump372:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump373: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const168] ; 11
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump373 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump373 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const169] ; 75.01
	push rax
	mov rax, [rel const170] ; 63.65
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump374
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump376
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump377
.jump376:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump377:
	jmp .jump375
.jump374:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump375:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump378
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump378:
	cmp rax, [rsp + 16]
	jl .jump379
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump379:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump380
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump380:
	cmp rax, [rsp + 24]
	jl .jump381
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump381:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	jmp .jump366
.jump365:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump382
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump382:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump383
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump383:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump384: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump384 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump384 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump366:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump385
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump385:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (if ((25.52 >= (sum[h : (array[h : g] 537)[146], i : ((- g) - 824), j : c] 66.41)) || (g <= (sum[h : e, i : (- (g - e)), j : e, k : 530] (if a then e else i)))) then ((- (array[h : c, i : e] 11)[(if (63.65 == 75.01) then (if true then g else e) else e), (- c)]) * (- (if true then e else 789))) else (sum[h : g, i : (- c)] c)) 
	jno .jump386
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump386:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump387: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump388
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const171] ; 876
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump390
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump390:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump391: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump391 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump392
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump392:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	mov rax, [rel const36] ; 406
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump393
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump393:
	cmp rax, [rsp + 8]
	jl .jump394
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump394:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump395
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump395:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump396: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const172] ; 250
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump396 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump396 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump397
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump399
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const173] ; 159
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump401
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump402
.jump401:
	mov rax, [rel const174] ; 981
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
.jump402:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump403
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump403:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump404
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump404:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump405
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump405:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump406
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump406:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump407
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump407:
	imul rdi, [rsp + 0 + 16] ; multiply by (if (e <= 159) then e else (c - 981)) 
	jno .jump408
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump408:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump409: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump409 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump409 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump409 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump400
.jump399:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump410
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump411
.jump410:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump411:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump412
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump412:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump413: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const175] ; 888
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump414
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump414:
	cqo
	idiv r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump413 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump415
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump415:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump416
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump416:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump417
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump418
.jump417:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump418:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump419
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump419:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if a then g else e) 
	jno .jump420
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump420:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump421
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump421:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[i : (if false then c else c)] (c / 888)) 
	jno .jump422
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump422:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump423: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump423 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump423 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump423 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump400:
	jmp .jump398
.jump397:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const176] ; 126
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump424
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump425
.jump424:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump425:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump426
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump426:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump427
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump427:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump428
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump428:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump429
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump429:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump430
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump430:
	imul rdi, [rsp + 0 + 16] ; multiply by (if (126 >= e) then (- e) else e) 
	jno .jump431
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump431:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump432: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump433
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump433:
	push rax
	pop rax
	cmp rax, 0
	je .jump434
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump436
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump436:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump437
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump437:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump438
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump438:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump439
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump439:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump440
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump440:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump441
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump441:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump442: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump442 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump442 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump442 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump435
.jump434:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump443
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump443:
	; Computing bound for 'm'
	mov rax, [rel const177] ; 318
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump444
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump444:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump445
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump445:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump446
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump446:
	imul rdi, [rsp + 0 + 8] ; multiply by 318 
	jno .jump447
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump447:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump448
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump448:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump449: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump449 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump449 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump449 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump435:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump432 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump432 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump432 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump450
	mov rax, [rel const26] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump451
.jump450:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
.jump451:
	pop rax
	cmp rax, 0
	je .jump452
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump454
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump455
.jump454:
	mov rax, [rel const178] ; 475
	push rax
.jump455:
	jmp .jump453
.jump452:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump456
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump457
.jump456:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump457:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump458
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump458:
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const179] ; 663
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump459
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump459:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump460
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump460:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump461: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump461 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump461 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump462
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump462:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump463: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump463 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump463 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump453:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump464
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump465
.jump464:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump465:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump466
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump466:
	cmp rax, [rsp + 24]
	jl .jump467
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump467:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump468
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump468:
	cmp rax, [rsp + 32]
	jl .jump469
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump469:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump470
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump470:
	cmp rax, [rsp + 40]
	jl .jump471
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump471:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump398:
	jmp .jump389
.jump388:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const180] ; 594
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump472
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump472:
	; Computing bound for 'j'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump473
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump475
	mov rax, [rel const181] ; 288
	push rax
	jmp .jump476
.jump475:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump476:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump477
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump477:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump478
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump478:
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump479
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump479:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump480
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump480:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump481
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump481:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump482: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump482 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump482 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump482 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump483
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump483:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump484
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump484:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump485
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump485:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[i : c, j : h, k : h] g) 
	jno .jump486
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump486:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump487
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump487:
	imul rdi, [rsp + 0 + 24] ; multiply by (if true then 288 else c) 
	jno .jump488
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump488:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump489: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump490
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump490:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump491
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump491:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump492
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump492:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump493: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump493 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump493 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump493 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump489 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump489 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump489 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump489 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump474
.jump473:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const107] ; 757
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump494
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump494:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump495
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump495:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump496
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump496:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump497
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump497:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump498
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump498:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump499
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump499:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump500
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump500:
	imul rdi, [rsp + 0 + 24] ; multiply by (- 757) 
	jno .jump501
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump501:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump502: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump503
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump503:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump504
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump504:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump505
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump505:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump506: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const182] ; 300
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump506 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump506 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump506 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump502 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump502 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump502 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump502 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump474:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump507
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump508
.jump507:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump508:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump509
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump511
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump511:
	; Computing bound for 'j'
	mov rax, [rel const155] ; 83
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump512
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump512:
	; Computing bound for 'i'
	mov rax, [rel const183] ; 802
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump513
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump513:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump514: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const184] ; 975
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump514 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump514 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump514 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump510
.jump509:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump510:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump515
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump515:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump516
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump516:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump517: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump517 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump517 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8 ; Add alignment
	mov rax, [rel const185] ; 91.04
	push rax
	mov rax, [rel const186] ; 99.92
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const187] ; 32.17
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump518
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump520
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump520:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump519
.jump518:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump519:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump521
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump521:
	cmp rax, [rsp + 32]
	jl .jump522
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump522:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump523
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump523:
	cmp rax, [rsp + 40]
	jl .jump524
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump524:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump525
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump525:
	cmp rax, [rsp + 48]
	jl .jump526
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump526:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump527
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump527:
	cmp rax, [rsp + 56]
	jl .jump528
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump528:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump529
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump529:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump530
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump530:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- g) 
	jno .jump531
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump531:
imul rdi, [rsp + 0 + 8] ; multiply by (if false then (array[i : c, j : (sum[i : c, j : h, k : h] g), k : g, l : (if true then 288 else c)] (sum[m : i, n : g, o : k] i)) else (array[i : e, j : g, k : h, l : (- 757)] (sum[m : h, n : k, o : c] 300)))[(if ((- 32.17) == (99.92 % 91.04)) then (- (g / e)) else e), (sum[i : c, j : (if false then (sum[i : 802, j : 83, k : h] 975) else h)] h), e, (if (h >= (c * g)) then e else c)] 
	jno .jump532
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump532:
	imul rdi, [rsp + 0 + 16] ; multiply by 594 
	jno .jump533
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump533:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump534: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump535
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump536
.jump535:
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
.jump536:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump534 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump534 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump534 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump389:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump387 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump537
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump537:
	cmp rax, [rsp + 8]
	jl .jump538
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump538:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const188] ; 123
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump539
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump539:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump540
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump540:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump541
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump541:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump542: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump542 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump542 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump542 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump543
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump543:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump544
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump544:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by c 
	jno .jump545
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump545:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[l : (- g), m : g, n : 123] i) 
	jno .jump546
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump546:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump547: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump548
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump548:
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump547 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump547 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump549
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump550
.jump549:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
.jump550:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump551
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump551:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump552
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump552:
	cmp rax, [rsp + 16]
	jl .jump553
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump553:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump554
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump554:
	cmp rax, [rsp + 24]
	jl .jump555
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump555:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump556
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump558
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump559
.jump558:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump560
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump560:
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump561
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump561:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump562
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump562:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump563
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump563:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump564: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump564 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump564 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump564 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump565
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump565:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump566
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump566:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump567: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump568
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump568:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump569: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const189] ; 16.17
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump569 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump567 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump567 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump567 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const190] ; 95.58
	push rax
	sub rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rsi
	lea rdi, [rsp + 16]
	call _b
	add rsp, 16
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump570
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump572
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump572:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump573
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump573:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump574
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump574:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump575: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const191] ; 78.73
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump575 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump575 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump575 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump571
.jump570:
	mov rax, [rel const192] ; 13.72
	push rax
.jump571:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump576
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump576:
	; Computing bound for 'l'
	sub rsp, 32
	; Moving 32 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 64 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 64 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const193] ; 781
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump577
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump577:
	cmp rax, [rsp + 24]
	jl .jump578
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump578:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump579
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump579:
	cmp rax, [rsp + 32]
	jl .jump580
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump580:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump581
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump581:
	cmp rax, [rsp + 40]
	jl .jump582
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump582:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump583
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump583:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump584: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const194] ; 54.11
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump584 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump584 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
.jump559:
	jmp .jump557
.jump556:
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump557:
	sub rsp, 32
	; Moving 32 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 64 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 64 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump585
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump585:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump586
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump586:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump587
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump587:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump588: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump589
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump590
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump592
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump592:
	push rax
	jmp .jump591
.jump590:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump593
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump594
.jump593:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump594:
.jump591:
	pop rax
.jump589:
	push rax
	pop rax
	cmp rax, 0
	je .jump595
	mov rax, [rel const195] ; 54.13
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump596
.jump595:
	mov rax, [rel const196] ; 9.39
	push rax
	mov rax, [rel const197] ; 95.72
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump596:
	mov rax, [rel const198] ; 83.57
	push rax
	mov rax, [rel const199] ; 98.46
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump597
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump597:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump598
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump598:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by e 
	jno .jump599
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump599:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump600
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump600:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump601: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const200] ; 44.19
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 8], 1
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump601 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump601 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const201] ; 958
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump602
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump603
.jump602:
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
.jump603:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump604
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump604:
	cmp rax, [rsp + 16]
	jl .jump605
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump605:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump606
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump606:
	cmp rax, [rsp + 24]
	jl .jump607
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump607:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump608
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump608:
	cmp rax, [rsp + 8]
	jl .jump609
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump609:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 's'
	add qword [rsp + 16], 1
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump588 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump588 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump588 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump610
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump610:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump611
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump611:
	; Computing bound for 'q'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump612
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	jmp .jump613
.jump612:
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
.jump613:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump614
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump614:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump615: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const202] ; 75.02
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 's'
	add qword [rsp + 16], 1
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump615 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump615 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump615 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 't'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump616
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump616:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump617
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump617:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump618
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump618:
	; Computing bound for 'q'
	mov rax, [rel const203] ; 436
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump619
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump619:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 436 
	jno .jump620
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump620:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump621
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump621:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump622
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump622:
	imul rdi, [rsp + 0 + 24] ; multiply by g 
	jno .jump623
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump623:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump624: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 't'
	add qword [rsp + 24], 1
	; Compare t to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump624 ; If t < bound, next iter
	mov qword [rsp + 24], 0 ; t = 0
	add qword [rsp + 16], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump624 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump624 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump624 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const204] ; 168
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump625
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump625:
	cmp rax, [rsp + 32]
	jl .jump626
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump626:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump627
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump627:
	cmp rax, [rsp + 40]
	jl .jump628
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump628:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump629
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump629:
	cmp rax, [rsp + 48]
	jl .jump630
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump630:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump631
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump631:
	cmp rax, [rsp + 56]
	jl .jump632
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump632:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump633
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump633:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump634
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump634:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump635: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump636
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump636:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump637
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump637:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump638: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 't'
	add qword [rsp + 8], 1
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump638 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump638 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 8], 1
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump635 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump635 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump639
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump639:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump640
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump640:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump641
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump641:
	; Computing bound for 'q'
	mov rax, [rel const205] ; 959
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump642
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump642:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump643: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	sub rsp, 8 ; Add alignment
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rsi
	lea rdi, [rsp + 24]
	call _b
	add rsp, 16
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 't'
	add qword [rsp + 24], 1
	; Compare t to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump643 ; If t < bound, next iter
	mov qword [rsp + 24], 0 ; t = 0
	add qword [rsp + 16], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump643 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump643 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump643 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const206] ; 966
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump644
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump646
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump646:
	; Computing bound for 'r'
	mov rax, [rel const207] ; 564
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump647
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump647:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump648
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump648:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump649
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump649:
	imul rdi, [rsp + 0 + 8] ; multiply by 564 
	jno .jump650
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump650:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump651
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump651:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump652: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump653
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump653:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump654
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump654:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump655
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump655:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump656: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const208] ; 9.88
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'v'
	add qword [rsp + 16], 1
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump656 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump656 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump656 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 's'
	add qword [rsp + 16], 1
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump652 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump652 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump652 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump645
.jump644:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump657
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump657:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump658
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump658:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump659
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump659:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump660
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump660:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump661: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const209] ; 286
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 't'
	add qword [rsp + 24], 1
	; Compare t to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump661 ; If t < bound, next iter
	mov qword [rsp + 24], 0 ; t = 0
	add qword [rsp + 16], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump661 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump661 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump661 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump662
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump662:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump663
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump663:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump664
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump664:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump665
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump665:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump666
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump666:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[q : m, r : i, s : p, t : m] 286) 
	jno .jump667
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump667:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump668: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const210] ; 97.9
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 's'
	add qword [rsp + 16], 1
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump668 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump668 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump668 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump645:
	sub rsp, 32
	; Moving 32 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 64 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 64 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump669
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump669:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump670
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump670:
	cmp rax, [rsp + 24]
	jl .jump671
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump671:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump672
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump672:
	cmp rax, [rsp + 32]
	jl .jump673
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump673:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump674
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump674:
	cmp rax, [rsp + 40]
	jl .jump675
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump675:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump676
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump676:
	cmp rax, [rsp + 24]
	jl .jump677
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump677:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump678
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump678:
	cmp rax, [rsp + 32]
	jl .jump679
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump679:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump680
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump680:
	cmp rax, [rsp + 40]
	jl .jump681
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump681:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rsi
	lea rdi, [rsp + 16]
	call _b
	add rsp, 16
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 160 ; Local variables
	pop rbp
	ret
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump682
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump682:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by g 
	jno .jump683
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump683:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump684: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	sub rsp, 8 ; Add alignment
	sub rsp, 16
	; Moving 16 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump685
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump685:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump686
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump686:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump687
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump687:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump688
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump688:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump689
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump689:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump690
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump690:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump691
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump691:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump692: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 344 to rsp 
		mov r10, [rbp - 344 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'u'
	add qword [rsp + 24], 1
	; Compare u to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump692 ; If u < bound, next iter
	mov qword [rsp + 24], 0 ; u = 0
	add qword [rsp + 16], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump692 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump692 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump692 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump693
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump693:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump694
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump694:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump695: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'u'
	add qword [rsp + 24], 1
	; Compare u to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump695 ; If u < bound, next iter
	mov qword [rsp + 24], 0 ; u = 0
	add qword [rsp + 16], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump695 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump695 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump695 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump696
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump696:
	; Computing bound for 't'
	mov rax, [rel const211] ; 737
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump697
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump697:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump698
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump698:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump699
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump699:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump700: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 328 to rsp 
		mov r10, [rbp - 328 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'u'
	add qword [rsp + 24], 1
	; Compare u to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump700 ; If u < bound, next iter
	mov qword [rsp + 24], 0 ; u = 0
	add qword [rsp + 16], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump700 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump700 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump700 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump701
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump701:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump702
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump702:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump703
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump703:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump704
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump704:
	imul rdi, [rsp + 0 + 8] ; multiply by e 
	jno .jump705
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump705:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[r : e, s : c, t : 737, u : p] r) 
	jno .jump706
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump706:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump707: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 't'
	add qword [rsp + 16], 1
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump707 ; If t < bound, next iter
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump707 ; If s < bound, next iter
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump707 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump708
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump708:
	cmp rax, [rsp + 24]
	jl .jump709
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump709:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump710
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump710:
	cmp rax, [rsp + 32]
	jl .jump711
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump711:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump712
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump712:
	cmp rax, [rsp + 40]
	jl .jump713
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump713:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump714
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump715
.jump714:
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const212] ; 428
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump716
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump716:
	cmp rax, [rsp + 24]
	jl .jump717
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump717:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump718
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump718:
	cmp rax, [rsp + 32]
	jl .jump719
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump719:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump720
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump720:
	cmp rax, [rsp + 40]
	jl .jump721
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump721:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump722
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump722:
	cmp rax, [rsp + 8]
	jl .jump723
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump723:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump715:
	pop rsi
	lea rdi, [rsp + 24]
	call _b
	add rsp, 16
	add rsp, 8 ; Remove alignment
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'q'
	add qword [rsp + 0], 1
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump684 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump724
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump725
.jump724:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump726
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump726:
	; Computing bound for 's'
	mov rax, [rel const213] ; 1000
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump727
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump727:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump728
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump728:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump729
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump729:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump730: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 't'
	add qword [rsp + 24], 1
	; Compare t to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump730 ; If t < bound, next iter
	mov qword [rsp + 24], 0 ; t = 0
	add qword [rsp + 16], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump730 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump730 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump730 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
.jump725:
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump731
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump732
.jump731:
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
.jump732:
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump733
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	jmp .jump734
.jump733:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump734:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump735
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump735:
	cmp rax, [rsp + 8]
	jl .jump736
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump736:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 192 ; Local variables
	pop rbp
	ret
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump737
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump738
.jump737:
	mov rax, [rel const26] ; False
	push rax
.jump738:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump739
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump741
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump741:
	cmp rax, [rsp + 24]
	jl .jump742
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump742:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump743
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump743:
	cmp rax, [rsp + 32]
	jl .jump744
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump744:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump745
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump745:
	cmp rax, [rsp + 40]
	jl .jump746
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump746:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	jmp .jump740
.jump739:
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump747
	mov rax, [rel const11] ; True
	push rax
	jmp .jump748
.jump747:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump748:
.jump740:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump749
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump751
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump751:
	; Computing bound for 'r'
	mov rax, [rel const87] ; 343
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump752
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump752:
	; Computing bound for 'q'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump753
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump753:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump754
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump754:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump755
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump755:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump756
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump756:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump757: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 8], 1
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump757 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump757 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump758
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump758:
	cmp rax, [rsp + 16]
	jl .jump759
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump759:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump760
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump760:
	cmp rax, [rsp + 24]
	jl .jump761
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump761:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump762
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump762:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba[,,][,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (- (array[q : m, r : c] m)[(- g), e]) 
	jno .jump763
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump763:
	imul rdi, [rsp + 0 + 8] ; multiply by 343 
	jno .jump764
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump764:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump765
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump765:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump766: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump767
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump767:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump768
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump768:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump769
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump770
.jump769:
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
.jump770:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump771
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump771:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (c + (if a then g else r)) 
	jno .jump772
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump772:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump773
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump773:
	imul rdi, [rsp + 0 + 16] ; multiply by q 
	jno .jump774
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump774:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump775: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump776
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump776:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump777
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump777:
	; Computing bound for 'w'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump778
	sub rsp, 8
	; Moving 8 bytes from rbp - 296 to rsp 
		mov r10, [rbp - 296 + 0]
		mov [rsp + 0], r10
	jmp .jump779
.jump778:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump779:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump780
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump780:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by (if true then u else e) 
	jno .jump781
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump781:
	imul rdi, [rsp + 0 + 8] ; multiply by v 
	jno .jump782
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump782:
	imul rdi, [rsp + 0 + 16] ; multiply by j 
	jno .jump783
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump783:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump784: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	sub rsp, 8 ; Add alignment
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rsi
	lea rdi, [rsp + 24]
	call _b
	add rsp, 16
	add rsp, 8 ; Remove alignment
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'y'
	add qword [rsp + 16], 1
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump784 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump784 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump784 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'v'
	add qword [rsp + 16], 1
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump775 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump775 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump775 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 's'
	add qword [rsp + 16], 1
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump766 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump766 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump766 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump750
.jump749:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump785
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump785:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump786
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump786:
	; Computing bound for 'q'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump787
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump787:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump788
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump788:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump789
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump789:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump790: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump791
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump791:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump792
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump792:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump793
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump793:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump794
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump794:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump795: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 320 to rsp 
		mov r10, [rbp - 320 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'w'
	add qword [rsp + 24], 1
	; Compare w to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump795 ; If w < bound, next iter
	mov qword [rsp + 24], 0 ; w = 0
	add qword [rsp + 16], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump795 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump795 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump795 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 's'
	add qword [rsp + 16], 1
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump790 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump790 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump790 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump796
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump796:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba[,,][,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (g + (sum[q : k, r : (- e), s : c] (sum[t : g, u : j, v : r, w : r] w))) 
	jno .jump797
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump797:
	imul rdi, [rsp + 0 + 8] ; multiply by (g + c) 
	jno .jump798
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump798:
	imul rdi, [rsp + 0 + 16] ; multiply by j 
	jno .jump799
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump799:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump800: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump801
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump801:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump802
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump802:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump803
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump803:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- (- m)) 
	jno .jump804
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump804:
	imul rdi, [rsp + 0 + 8] ; multiply by p 
	jno .jump805
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump805:
	imul rdi, [rsp + 0 + 16] ; multiply by i 
	jno .jump806
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump806:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump807: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump808
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump808:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump809
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump809:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump810
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump810:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by j 
	jno .jump811
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump811:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump812
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump812:
	imul rdi, [rsp + 0 + 16] ; multiply by j 
	jno .jump813
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump813:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump814: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	sub rsp, 8 ; Add alignment
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	pop rsi
	lea rdi, [rsp + 24]
	call _b
	add rsp, 16
	add rsp, 8 ; Remove alignment
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'y'
	add qword [rsp + 16], 1
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump814 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump814 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump814 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'v'
	add qword [rsp + 16], 1
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump807 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump807 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump807 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 's'
	add qword [rsp + 16], 1
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump800 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump800 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump800 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump750:
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump815
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump815:
	cmp rax, [rsp + 24]
	jl .jump816
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump816:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump817
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump817:
	cmp rax, [rsp + 32]
	jl .jump818
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump818:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump819
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump819:
	cmp rax, [rsp + 40]
	jl .jump820
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump820:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump821
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump821:
	cmp rax, [rsp + 24]
	jl .jump822
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump822:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump823
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump823:
	cmp rax, [rsp + 32]
	jl .jump824
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump824:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump825
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump825:
	cmp rax, [rsp + 40]
	jl .jump826
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump826:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const214] ; 548
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump827
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump827:
	cmp rax, [rsp + 24]
	jl .jump828
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump828:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump829
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump829:
	cmp rax, [rsp + 32]
	jl .jump830
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump830:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump831
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump831:
	cmp rax, [rsp + 40]
	jl .jump832
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump832:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump833
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump833:
	cmp rax, [rsp + 24]
	jl .jump834
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump834:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump835
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump835:
	cmp rax, [rsp + 32]
	jl .jump836
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump836:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump837
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump837:
	cmp rax, [rsp + 40]
	jl .jump838
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump838:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 224 ; Local variables
	pop rbp
	ret

d:
_d:
	push rbp
	mov rbp, rsp
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump839
	mov rax, [rel const216] ; 350
	push rax
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	mov rax, [rel const217] ; 93
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump841
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump841:
	cmp rax, [rsp + 8]
	jl .jump842
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump842:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump840
.jump839:
	mov rax, [rel const218] ; 749
	push rax
	mov rax, [rel const219] ; 61
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
.jump840:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump843
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump843:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const220] ; 947
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump844
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump844:
	; Computing bound for 'i'
	mov rax, [rel const221] ; 904
	push rax
	mov rax, [rel const222] ; 769
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump845
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump847
	mov rax, [rel const223] ; 579
	push rax
	jmp .jump848
.jump847:
	mov rax, [rel const224] ; 514
	push rax
.jump848:
	jmp .jump846
.jump845:
	mov rax, [rel const225] ; 104
	push rax
.jump846:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump849
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump849:
	; Computing bound for 'h'
	mov rax, [rel const226] ; 813
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump850
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump850:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump851: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump851 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump851 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump851 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const31] ; 891
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump852
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump852:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump853
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump853:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump854: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump854 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump854 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump855
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump855:
	; Computing bound for 'i'
	mov rax, [rel const227] ; 378
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump856
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump856:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump857
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const228] ; 865
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump859
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump859:
	; Computing bound for 'i'
	mov rax, [rel const229] ; 545
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump860
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump860:
	; Computing bound for 'h'
	mov rax, [rel const230] ; 817
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump861
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump861:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump862: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump862 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump862 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump862 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump858
.jump857:
	mov rax, [rel const231] ; 257
	push rax
.jump858:
	mov rax, [rel const182] ; 300
	push rax
	mov rax, [rel const232] ; 918
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump863
	mov rax, [rel const233] ; 62
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump864
.jump863:
	mov rax, [rel const234] ; 720
	push rax
	pop rax
	neg rax
	push rax
.jump864:
	pop rax
	pop r10
	imul rax, r10
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const235] ; 868
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump865
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump865:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump866
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const236] ; 889
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump868
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump868:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump869: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump869 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump867
.jump866:
	mov rax, [rel const237] ; 956
	push rax
	pop rax
	neg rax
	push rax
.jump867:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump870
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump870:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump871: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump871 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump871 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump872
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump872:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump873
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump873:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump874: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump875
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump875:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump876
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump876:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump877: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump878
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump878:
	; Computing bound for 'm'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump879
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	jmp .jump880
.jump879:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
.jump880:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump881
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump881:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump882
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump882:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump883: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump883 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump883 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump883 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump877 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump884
	mov rax, [rel const238] ; 370
	push rax
	jmp .jump885
.jump884:
	mov rax, [rel const239] ; 880
	push rax
.jump885:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump886
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump886:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump887
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump887:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump888
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump888:
	; Computing bound for 'k'
	mov rax, [rel const240] ; 20
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump889
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump889:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump890: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const240] ; 20
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 24], 1
	; Compare n to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump890 ; If n < bound, next iter
	mov qword [rsp + 24], 0 ; n = 0
	add qword [rsp + 16], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump890 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump890 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump890 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump891
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump891:
	cmp rax, [rsp + 8]
	jl .jump892
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump892:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump893
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump893:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump894
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump894:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump895
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump895:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump896
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump896:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump897: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump898
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump898:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump899
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump899:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump900
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump900:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump901
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump901:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump902
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump902:
	imul rdi, [rsp + 0 + 16] ; multiply by l 
	jno .jump903
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump903:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump904: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump904 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump904 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump904 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump897 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump897 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const38] ; 726
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump905
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump905:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump906
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump906:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump907
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump907:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump908
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump908:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump909: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 24], 1
	; Compare n to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump909 ; If n < bound, next iter
	mov qword [rsp + 24], 0 ; n = 0
	add qword [rsp + 16], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump909 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump909 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump909 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const241] ; 838
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump910
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump910:
	cmp rax, [rsp + 16]
	jl .jump911
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump911:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump912
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump912:
	cmp rax, [rsp + 24]
	jl .jump913
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump913:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const242] ; 354
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump914
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump916
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump916:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump917
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump917:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump918: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump918 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump915
.jump914:
	mov rax, [rel const243] ; 920
	push rax
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
.jump915:
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump919
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump919:
	cmp rax, [rsp + 8]
	jl .jump920
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump920:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump921
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump921:
	cmp rax, [rsp + 24]
	jl .jump922
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump922:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump923
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump923:
	cmp rax, [rsp + 32]
	jl .jump924
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump924:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump925
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump925:
	cmp rax, [rsp + 40]
	jl .jump926
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump926:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump874 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump874 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump874 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 24
	; Moving 24 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	sub rsp, 24
	; Moving 24 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _d
	add rsp, 8
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump927
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump929
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump930
.jump929:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump930:
	jmp .jump928
.jump927:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump928:
	call _d
	add rsp, 8
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump931
	mov rax, [rel const26] ; False
	push rax
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump932
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump932:
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
.jump931:
	push rax
	pop rax
	cmp rax, 0
	je .jump933
	mov rax, [rel const244] ; 531
	push rax
	jmp .jump934
.jump933:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const245] ; 792
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump935
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump935:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump936: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump937
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump937:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump938
	mov rax, [rel const246] ; 718
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump939
.jump938:
	mov rax, [rel const247] ; 192
	push rax
.jump939:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump940
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump940:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if a then (- 718) else 192) 
	jno .jump941
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump941:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump942
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump942:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump943: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump943 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump943 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const248] ; 358
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump944
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump945
.jump944:
	mov rax, [rel const249] ; 241
	push rax
.jump945:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump946
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump946:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump947
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump947:
	; Computing bound for 'j'
	mov rax, [rel const250] ; 946
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump948
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump948:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump949
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump949:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump950: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump951
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump951:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump952
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump952:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump953
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump953:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump954: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump954 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump954 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump954 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump950 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump950 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump950 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump950 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump955
	mov rax, [rel const130] ; 532
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump956
.jump955:
	mov rax, [rel const251] ; 460
	push rax
.jump956:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump957
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump957:
	cmp rax, [rsp + 16]
	jl .jump958
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump958:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump959
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump959:
	cmp rax, [rsp + 24]
	jl .jump960
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump960:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump936 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump934:
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump961
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const252] ; 729
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump963
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump963:
	; Computing bound for 'i'
	mov rax, [rel const253] ; 965
	push rax
	mov rax, [rel const254] ; 664
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump964
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump964:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump965
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump965:
	; Computing bound for 'h'
	mov rax, [rel const255] ; 447
	push rax
	mov rax, [rel const256] ; 455
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump966
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump966:
	cqo
	idiv r10
	push rax
	mov rax, [rel const257] ; 855
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump967
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump967:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump968: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump969
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	jmp .jump970
.jump969:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
.jump970:
	mov rax, [rel const258] ; 462
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump971
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump971:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump968 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump968 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump968 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rel const259] ; 267
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const260] ; 618
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump972
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump972:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump973: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const261] ; 518
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump973 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump974
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump974:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[h : 618] 518) 
	jno .jump975
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump975:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump976: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump976 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const262] ; 636
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump977
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump977:
	cmp rax, [rsp + 8]
	jl .jump978
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump978:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump979
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump979:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump980
	mov rax, [rel const263] ; 485
	push rax
	mov rax, [rel const264] ; 458
	push rax
	mov rax, [rel const265] ; 939
	push rax
	mov rax, [rel const266] ; 738
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump982
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump982:
	cqo
	idiv r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump983
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump983:
	cqo
	idiv r10
	push rax
	mov rax, [rel const267] ; 555
	push rax
	mov rax, [rel const268] ; 944
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump984
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump984:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rel const269] ; 392
	push rax
	pop rax
	neg rax
	push rax
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	mov rax, [rel const270] ; 147
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump985
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump985:
	cmp rax, [rsp + 8]
	jl .jump986
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump986:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump987
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump987:
	cqo
	idiv r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	jmp .jump981
.jump980:
	mov rax, [rel const11] ; True
	push rax
	sub rsp, 24
	; Moving 24 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const271] ; 98.74
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump988
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump990
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump991
.jump990:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump991:
	jmp .jump989
.jump988:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump989:
	call _d
	add rsp, 8
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump992
	mov rax, [rel const26] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump994
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	jmp .jump995
.jump994:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
.jump995:
	jmp .jump993
.jump992:
	mov rax, [rel const11] ; True
	push rax
.jump993:
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
.jump981:
	pop rax
	cmp rax, 0
	je .jump996
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump998
	sub rsp, 8 ; Add alignment
	sub rsp, 24
	; Moving 24 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump999
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump999:
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1000
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump1001
.jump1000:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump1001:
	call _d
	add rsp, 8
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
.jump998:
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const217] ; 93
	push rax
	mov rax, [rel const272] ; 506
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rel const273] ; 55
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1002
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1002:
	; Computing bound for 'h'
	mov rax, [rel const274] ; 600
	push rax
	mov rax, [rel const166] ; 530
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1003
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1003:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (530 - 600) 
	jno .jump1004
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1004:
	imul rdi, [rsp + 0 + 8] ; multiply by (55 * (506 - 93)) 
	jno .jump1005
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1005:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1006: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1007
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1007:
	; Computing bound for 'l'
	mov rax, [rel const275] ; 295
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1008
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1008:
	; Computing bound for 'k'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1009
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	jmp .jump1010
.jump1009:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump1010:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1011
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1011:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1012
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1012:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump1013
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1013:
	imul rdi, [rsp + 0 + 8] ; multiply by (if true then i else h) 
	jno .jump1014
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1014:
	imul rdi, [rsp + 0 + 16] ; multiply by 295 
	jno .jump1015
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1015:
	imul rdi, [rsp + 0 + 24] ; multiply by h 
	jno .jump1016
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1016:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
.jump1017: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const26] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 24], 1
	; Compare m to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1017 ; If m < bound, next iter
	mov qword [rsp + 24], 0 ; m = 0
	add qword [rsp + 16], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1017 ; If l < bound, next iter
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1017 ; If k < bound, next iter
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1017 ; If j < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1006 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1006 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const276] ; 566
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const277] ; 987
	push rax
	mov rax, [rel const138] ; 607
	push rax
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	mov rax, [rel const278] ; 38
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1018
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1018:
	cmp rax, [rsp + 8]
	jl .jump1019
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1019:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1020
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1020:
	cqo
	idiv r10
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1021
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	jmp .jump1022
.jump1021:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
.jump1022:
	pop rax
	cmp rax, 0
	je .jump1023
	mov rax, [rel const279] ; 686
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump1024
.jump1023:
	mov rax, [rel const280] ; 848
	push rax
.jump1024:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1025
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1025:
	cmp rax, [rsp + 16]
	jl .jump1026
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1026:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1027
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1027:
	cmp rax, [rsp + 24]
	jl .jump1028
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1028:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 40
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1029
	mov rax, [rel const281] ; 974
	push rax
	jmp .jump1030
.jump1029:
	mov rax, [rel const282] ; 156
	push rax
.jump1030:
	mov rax, [rel const217] ; 93
	push rax
	mov rax, [rel const283] ; 135
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 24
	; Moving 24 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1031
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump1032
.jump1031:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump1032:
	call _d
	add rsp, 8
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump1033
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const96] ; 56
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1035
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1035:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1036: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const284] ; 387
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1036 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1037
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1037:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1038: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const285] ; 914
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1038 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const286] ; 598
	push rax
	mov rax, [rel const287] ; 847
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1039
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump1039:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1040
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1040:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1041: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1041 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	add rax, r10
	push rax
	jmp .jump1034
.jump1033:
	mov rax, [rel const288] ; 7
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const289] ; 675
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rel const290] ; 403
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1042
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump1042:
	cqo
	idiv r10
	push rax
.jump1034:
	mov rax, [rel const291] ; 409
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const146] ; 281
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1043
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1043:
	cmp rax, [rsp + 32]
	jl .jump1044
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1044:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1045
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1045:
	cmp rax, [rsp + 40]
	jl .jump1046
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1046:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1047
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1047:
	cmp rax, [rsp + 48]
	jl .jump1048
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1048:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1049
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1049:
	cmp rax, [rsp + 56]
	jl .jump1050
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1050:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	jmp .jump997
.jump996:
	mov rax, [rel const95] ; 136
	push rax
	mov rax, [rel const116] ; 586
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const145] ; 640
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1051
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1051:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1052: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const292] ; 28
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1052 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const293] ; 479
	push rax
	mov rax, [rel const294] ; 256
	push rax
	mov rax, [rel const295] ; 806
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1053
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1053:
	; Computing bound for 'h'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1054
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump1054:
	push rax
	pop rax
	cmp rax, 0
	je .jump1055
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const296] ; 908
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1057
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1057:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1058: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const297] ; 923
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1058 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump1056
.jump1055:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1059
	mov rax, [rel const298] ; 643
	push rax
	jmp .jump1060
.jump1059:
	mov rax, [rel const268] ; 944
	push rax
.jump1060:
.jump1056:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1061
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1061:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1062: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1062 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1062 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
.jump997:
	jmp .jump962
.jump961:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
.jump962:
	pop rax
	cmp rax, 0
	jne .jump1063
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const299] ; 'h'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1063:
	mov rax, [rel const184] ; 975
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const300] ; 703
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const301] ; 207
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1064
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1064:
	; Computing bound for 'j'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const302] ; 928
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1065
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1065:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1066: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1067
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump1068
.jump1067:
	mov rax, [rel const303] ; 490
	push rax
.jump1068:
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1066 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1069
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1069:
	; Computing bound for 'j'
	mov rax, [rel const304] ; 487
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1070
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1070:
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1071
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const305] ; 249
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1073
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1073:
	; Computing bound for 'h'
	mov rax, [rel const306] ; 228
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1074
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1074:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1075: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1075 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1075 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump1072
.jump1071:
	mov rax, [rel const307] ; 308
	push rax
	mov rax, [rel const259] ; 267
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
.jump1072:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1076
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1076:
	; Computing bound for 'h'
	mov rax, [rel const308] ; 139
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1077
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1077:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1078: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const309] ; 978
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1078 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1078 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1079
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1079:
	; Computing bound for 'h'
	mov rax, [rel const310] ; 498
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1080
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1080:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 498 
	jno .jump1081
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1081:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[h : 139, i : (if a then (sum[h : 228, i : 249] i) else (267 * 308))] 978) 
	jno .jump1082
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1082:
	imul rdi, [rsp + 0 + 16] ; multiply by 487 
	jno .jump1083
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1083:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[h : 928] (if a then (- h) else 490)) 
	jno .jump1084
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1084:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1085: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1085 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1085 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1085 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1085 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const156] ; 235
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1086
	sub rsp, 24
	; Moving 24 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _d
	add rsp, 8
	add rsp, 24
	push rax
	jmp .jump1087
.jump1086:
	sub rsp, 24
	; Moving 24 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _d
	add rsp, 8
	add rsp, 24
	push rax
.jump1087:
	pop rax
	cmp rax, 0
	je .jump1088
	mov rax, [rel const311] ; 898
	push rax
	mov rax, [rel const312] ; 323
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump1089
.jump1088:
	mov rax, [rel const313] ; 122
	push rax
.jump1089:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1090
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1090:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1091
	mov rax, [rel const314] ; 616
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump1092
.jump1091:
	mov rax, [rel const315] ; 49.5
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1093
	mov rax, [rel const24] ; 30
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const316] ; 625
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	jmp .jump1094
.jump1093:
	mov rax, [rel const193] ; 781
	push rax
.jump1094:
.jump1092:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const317] ; 200
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1095
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1095:
	; Computing bound for 'h'
	mov rax, [rel const318] ; 585
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1096
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1096:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 585) 
	jno .jump1097
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1097:
	imul rdi, [rsp + 0 + 8] ; multiply by 200 
	jno .jump1098
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1098:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1099: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const141] ; 589
	push rax
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1099 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1099 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const319] ; 676
	push rax
	mov rax, [rel const320] ; 118
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const321] ; 383
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1100
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1100:
	; Computing bound for 'j'
	mov rax, [rel const322] ; 818
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1101
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1101:
	; Computing bound for 'i'
	mov rax, [rel const323] ; 203
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1102
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1102:
	; Computing bound for 'h'
	mov rax, [rel const324] ; 665
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1103
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1103:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1104: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1104 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1104 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1104 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1104 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1105
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1105:
	cmp rax, [rsp + 16]
	jl .jump1106
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1106:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1107
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1107:
	cmp rax, [rsp + 24]
	jl .jump1108
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1108:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1109
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1109:
	; Computing bound for 'h'
	mov rax, [rel const325] ; 274
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1110
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1110:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1111: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const326] ; 997
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1111 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1111 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1112
	mov rax, [rel const327] ; 739
	push rax
	jmp .jump1113
.jump1112:
	mov rax, [rel const128] ; 862
	push rax
.jump1113:
	mov rax, [rel const50] ; 993
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const328] ; 31
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1114
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1114:
	; Computing bound for 'h'
	mov rax, [rel const247] ; 192
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1115
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1115:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1116: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1116 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1116 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1117
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1117:
	; Computing bound for 'j'
	mov rax, [rel const329] ; 787
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1118
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1118:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1119
	mov rax, [rel const11] ; True
	push rax
	pop rax
.jump1119:
	push rax
	pop rax
	cmp rax, 0
	je .jump1120
	mov rax, [rel const330] ; 759
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump1121
.jump1120:
	mov rax, [rel const331] ; 808
	push rax
.jump1121:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1122
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1122:
	; Computing bound for 'h'
	mov rax, [rel const332] ; 783
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1123
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1123:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1124: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const333] ; 723
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1124 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1124 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1124 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1124 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1125
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1125:
	cmp rax, [rsp + 32]
	jl .jump1126
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1126:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1127
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1127:
	cmp rax, [rsp + 40]
	jl .jump1128
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1128:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1129
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1129:
	cmp rax, [rsp + 48]
	jl .jump1130
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1130:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1131
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1131:
	cmp rax, [rsp + 56]
	jl .jump1132
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1132:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1133
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1133:
	; Computing bound for 'i'
	mov rax, [rel const334] ; 568
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1134
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1134:
	; Computing bound for 'h'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const335] ; 8
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1135
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1135:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1136: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const336] ; 952
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1136 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1137
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1137:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[h : 8] 952) 
	jno .jump1138
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1138:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1139: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1139 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const26] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1140
	mov rax, [rel const337] ; 296
	push rax
	jmp .jump1141
.jump1140:
	mov rax, [rel const338] ; 901
	push rax
	pop rax
	neg rax
	push rax
.jump1141:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1142
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1142:
	cmp rax, [rsp + 8]
	jl .jump1143
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1143:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const339] ; 63.77
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump1144
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1145
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
.jump1145:
	push rax
	pop rax
.jump1144:
	push rax
	pop rax
	cmp rax, 0
	je .jump1146
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const340] ; 982
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1148
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1148:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1149: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1149 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	jmp .jump1147
.jump1146:
	mov rax, [rel const47] ; 173
	push rax
	pop rax
	neg rax
	push rax
.jump1147:
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1150
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1150:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1151: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1152
	mov rax, [rel const341] ; 773
	push rax
	jmp .jump1153
.jump1152:
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
.jump1153:
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1151 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1151 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1151 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1151 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1154
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const342] ; 872
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1156
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1156:
	; Computing bound for 'i'
	mov rax, [rel const343] ; 206
	push rax
	mov rax, [rel const157] ; 124
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1157
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1157:
	; Computing bound for 'h'
	mov rax, [rel const21] ; 766
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1158
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1158:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1159: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1159 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1159 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1159 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const344] ; 25.86
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1160
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const345] ; 631
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1162
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1162:
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const346] ; 271
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1163
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1163:
	; Computing bound for 'h'
	mov rax, [rel const347] ; 89
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1164
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1164:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1165: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1165 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1165 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1166
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1166:
	; Computing bound for 'h'
	mov rax, [rel const348] ; 660
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1167
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1167:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1168: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const349] ; 310
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1168 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1168 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1169
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1169:
	; Computing bound for 'h'
	mov rax, [rel const87] ; 343
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const350] ; 750
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1170
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump1170:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1171
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1171:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[][,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (750 % (- (- 343))) 
	jno .jump1172
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1172:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[h : (- 660), i : (sum[h : 89, i : 271] (- h))] (310 * h)) 
	jno .jump1173
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1173:
	imul rdi, [rsp + 0 + 16] ; multiply by 631 
	jno .jump1174
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1174:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1175: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1176
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1176:
	; Computing bound for 'k'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1177
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1177:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1178: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1178 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1179
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1179:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof void[] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[k : (- j)] j) 
	jno .jump1180
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1180:
	imul rdi, [rsp + 0 + 8] ; multiply by j 
	jno .jump1181
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1181:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1182: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const351] ; 474
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1183
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1183:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by 474 
	jno .jump1184
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1184:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1185: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 0], 1
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1185 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1182 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1182 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1175 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1175 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1175 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump1161
.jump1160:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const352] ; 60
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1186
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1186:
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1187
	mov rax, [rel const26] ; False
	push rax
	jmp .jump1188
.jump1187:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
.jump1188:
	pop rax
	cmp rax, 0
	je .jump1189
	mov rax, [rel const353] ; 185
	push rax
	jmp .jump1190
.jump1189:
	mov rax, [rel const297] ; 923
	push rax
	pop rax
	neg rax
	push rax
.jump1190:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1191
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1191:
	; Computing bound for 'i'
	mov rax, [rel const9] ; 294
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const354] ; 150
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1192
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1192:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1193
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1193:
	; Computing bound for 'h'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1194
	mov rax, [rel const355] ; 14
	push rax
	jmp .jump1195
.jump1194:
	mov rax, [rel const356] ; 551
	push rax
.jump1195:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1196
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1196:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1197: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1197 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1197 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1197 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1198
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1198:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const25] ; 569
	push rax
	mov rax, [rel const357] ; 570
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1199
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1199:
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const358] ; 290
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1200
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1200:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const359] ; 628
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1201
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1201:
	; Computing bound for 'h'
	mov rax, [rel const360] ; 869
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1202
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1202:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1203: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1203 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1203 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1204
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1204:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1205: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const168] ; 11
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1205 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1205 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1206
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1206:
	; Computing bound for 'h'
	mov rax, [rel const361] ; 317
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1207
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1207:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1208: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1208 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1208 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1208 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1209
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1209:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[][,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[h : (- 317), i : (sum[h : (sum[h : 869, i : 628] i), i : 290] 11), j : (570 * 569)] j) 
	jno .jump1210
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1210:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[h : (if false then 14 else 551), i : (150 % (- 294)), j : (if (if false then false else g) then 185 else (- 923))] i) 
	jno .jump1211
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1211:
	imul rdi, [rsp + 0 + 16] ; multiply by 60 
	jno .jump1212
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1212:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1213: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1214
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump1215
.jump1214:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
.jump1215:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1216
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1216:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const362] ; 488
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1217
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump1217:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1218
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1218:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof void[] 
	imul rdi, [rsp + 0 + 0] ; multiply by (j % (488 - j)) 
	jno .jump1219
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1219:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (h >= h) then (- i) else j) 
	jno .jump1220
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1220:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1221: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1221 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1221 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1213 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1213 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1213 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump1161:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1222
	mov rax, [rel const363] ; 609
	push rax
	jmp .jump1223
.jump1222:
	mov rax, [rel const364] ; 744
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1224
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump1224:
	push rax
	pop rax
	cmp rax, 0
	je .jump1225
	mov rax, [rel const290] ; 403
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump1226
.jump1225:
	mov rax, [rel const365] ; 617
	push rax
	pop rax
	neg rax
	push rax
.jump1226:
	pop rax
	pop r10
	sub rax, r10
	push rax
.jump1223:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const366] ; 810
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1227
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1227:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1228: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1228 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const367] ; 845
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1229
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1229:
	; Computing bound for 'i'
	mov rax, [rel const29] ; 201
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1230
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1230:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const368] ; 10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1231
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1231:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1232: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const369] ; 614
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1232 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const370] ; 335
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1233
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1233:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1234: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const371] ; 443
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1234 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1234 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1234 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1235
	mov rax, [rel const372] ; 621
	push rax
	jmp .jump1236
.jump1235:
	mov rax, [rel const53] ; 144
	push rax
.jump1236:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1237
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1237:
	; Computing bound for 'h'
	mov rax, [rel const373] ; 486
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1238
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1238:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 486) 
	jno .jump1239
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1239:
	imul rdi, [rsp + 0 + 8] ; multiply by (if a then 621 else 144) 
	jno .jump1240
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1240:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1241: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1242
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	jmp .jump1243
.jump1242:
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
.jump1243:
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1241 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1241 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1244
	mov rax, [rel const374] ; 376
	push rax
	jmp .jump1245
.jump1244:
	mov rax, [rel const375] ; 554
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const275] ; 295
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
.jump1245:
	mov rax, [rel const90] ; 320
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1246
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1246:
	cmp rax, [rsp + 16]
	jl .jump1247
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1247:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1248
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1248:
	cmp rax, [rsp + 24]
	jl .jump1249
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1249:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1250
	mov rax, [rel const211] ; 737
	push rax
	jmp .jump1251
.jump1250:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const266] ; 738
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1252
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1252:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1253: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const46] ; 623
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1253 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump1251:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1254
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1254:
	; Computing bound for 'i'
	mov rax, [rel const376] ; 770
	push rax
	mov rax, [rel const377] ; 753
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1255
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1255:
	; Computing bound for 'h'
	mov rax, [rel const378] ; 155
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1256
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1256:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1257: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1258
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	jmp .jump1259
.jump1258:
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
.jump1259:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1260
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1260:
	; Computing bound for 'k'
	mov rax, [rel const379] ; 357
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1261
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1261:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1262: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1262 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1262 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1257 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1257 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1257 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	sub rax, r10
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1263
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const270] ; 147
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1265
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1265:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1266: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1266 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump1264
.jump1263:
	mov rax, [rel const380] ; 745
	push rax
.jump1264:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1267
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1267:
	; Computing bound for 'j'
	mov rax, [rel const365] ; 617
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1268
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1268:
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const381] ; 209
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1269
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1269:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1270: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1270 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1271
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1271:
	; Computing bound for 'h'
	mov rax, [rel const382] ; 567
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1272
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1272:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1273: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1273 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1273 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1273 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1273 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1274
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1274:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1275
	mov rax, [rel const127] ; 682
	push rax
	jmp .jump1276
.jump1275:
	mov rax, [rel const383] ; 687
	push rax
.jump1276:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1277
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1277:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1278: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1278 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1279
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1279:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (- (sum[h : (if g then 682 else 687)] h)) 
	jno .jump1280
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1280:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[h : 567, i : (- (sum[h : 209] h)), j : 617, k : (if g then (sum[h : 147] h) else 745)] j) 
	jno .jump1281
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1281:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1282: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const136] ; 764
	push rax
	mov rax, [rel const384] ; 339
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1282 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1282 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const372] ; 621
	push rax
	mov rax, [rel const385] ; 504
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1283
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump1283:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const386] ; 929
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1284
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1284:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1285: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1285 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1286
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1288
	mov rax, [rel const387] ; 731
	push rax
	jmp .jump1289
.jump1288:
	mov rax, [rel const388] ; 121
	push rax
.jump1289:
	jmp .jump1287
.jump1286:
	mov rax, [rel const389] ; 772
	push rax
.jump1287:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1290
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1290:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1291
	mov rax, [rel const99] ; 482
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump1292
.jump1291:
	mov rax, [rel const390] ; 637
	push rax
.jump1292:
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1293
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1293:
	cmp rax, [rsp + 16]
	jl .jump1294
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1294:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1295
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1295:
	cmp rax, [rsp + 24]
	jl .jump1296
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1296:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1297
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1297:
	cmp rax, [rsp + 24]
	jl .jump1298
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1298:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1299
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1299:
	cmp rax, [rsp + 32]
	jl .jump1300
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1300:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1301
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1301:
	cmp rax, [rsp + 40]
	jl .jump1302
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1302:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const391] ; 534
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1303
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1303:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1304: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1304 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const348] ; 660
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1305
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1307
	mov rax, [rel const392] ; 292
	push rax
	jmp .jump1308
.jump1307:
	mov rax, [rel const231] ; 257
	push rax
.jump1308:
	jmp .jump1306
.jump1305:
	mov rax, [rel const393] ; 822
	push rax
.jump1306:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1309
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1309:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1310: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const394] ; 825
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1311
	mov rax, [rel const395] ; 950
	push rax
	jmp .jump1312
.jump1311:
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
.jump1312:
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1310 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1313
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1313:
	; Computing bound for 'i'
	mov rax, [rel const396] ; 316
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1314
	mov rax, [rel const397] ; 261
	push rax
	jmp .jump1315
.jump1314:
	mov rax, [rel const148] ; 695
	push rax
.jump1315:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1316
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump1316:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1317
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1317:
	; Computing bound for 'h'
	mov rax, [rel const398] ; 986
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1318
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1318:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 986 
	jno .jump1319
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1319:
	imul rdi, [rsp + 0 + 8] ; multiply by ((if true then 261 else 695) / 316) 
	jno .jump1320
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1320:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[h : (if g then (if a then 292 else 257) else 822)] ((if g then 950 else h) + (- 825))) 
	jno .jump1321
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1321:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1322: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1322 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1322 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1322 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const133] ; 677
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1323
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1323:
	; Computing bound for 'h'
	mov rax, [rel const399] ; 942
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1324
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1324:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1325: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const400] ; 176
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1325 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1325 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1326
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1326:
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const401] ; 535
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1327
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1327:
	; Computing bound for 'h'
	mov rax, [rel const390] ; 637
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1328
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1328:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1329: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1329 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1329 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1330
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1330:
	; Computing bound for 'h'
	mov rax, [rel const402] ; 796
	push rax
	mov rax, [rel const403] ; 297
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1331
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump1331:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1332
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1332:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1333: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1333 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1333 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1333 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1334
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1334:
	; Computing bound for 'i'
	mov rax, [rel const404] ; 493
	push rax
	mov rax, [rel const405] ; 44
	push rax
	mov rax, [rel const76] ; 282
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1335
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1335:
	; Computing bound for 'h'
	mov rax, [rel const156] ; 235
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1336
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1336:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 235 
	jno .jump1337
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1337:
	imul rdi, [rsp + 0 + 8] ; multiply by ((282 - 44) + 493) 
	jno .jump1338
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1338:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[h : (297 / 796), i : (sum[h : 637, i : 535] i), j : (sum[h : 942, i : 677] 176)] h) 
	jno .jump1339
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1339:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1340: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const406] ; 32
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1340 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1340 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1340 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1341
	mov rax, [rel const386] ; 929
	push rax
	jmp .jump1342
.jump1341:
	mov rax, [rel const407] ; 128
	push rax
.jump1342:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1343
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1343:
	; Computing bound for 'i'
	mov rax, [rel const408] ; 576
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1344
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1344:
	; Computing bound for 'h'
	mov rax, [rel const409] ; 245
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1345
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1345:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 245) 
	jno .jump1346
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1346:
	imul rdi, [rsp + 0 + 8] ; multiply by 576 
	jno .jump1347
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1347:
	imul rdi, [rsp + 0 + 16] ; multiply by (if g then 929 else 128) 
	jno .jump1348
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1348:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1349: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1349 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1349 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1349 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const54] ; 728
	push rax
	mov rax, [rel const410] ; 492
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const411] ; 590
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1350
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1350:
	; Computing bound for 'h'
	mov rax, [rel const412] ; 877
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1351
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1351:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1352: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1352 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1352 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1353
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1353:
	cmp rax, [rsp + 24]
	jl .jump1354
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1354:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1355
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1355:
	cmp rax, [rsp + 32]
	jl .jump1356
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1356:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1357
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1357:
	cmp rax, [rsp + 40]
	jl .jump1358
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1358:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const413] ; 313
	push rax
	mov rax, [rel const325] ; 274
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1359
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1359:
	cmp rax, [rsp + 24]
	jl .jump1360
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1360:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1361
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1361:
	cmp rax, [rsp + 32]
	jl .jump1362
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1362:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1363
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1363:
	cmp rax, [rsp + 40]
	jl .jump1364
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1364:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1365
	sub rsp, 8 ; Add alignment
	sub rsp, 24
	; Moving 24 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _d
	add rsp, 8
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump1367
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1369
	mov rax, [rel const388] ; 121
	push rax
	jmp .jump1370
.jump1369:
	mov rax, [rel const414] ; 801
	push rax
	pop rax
	neg rax
	push rax
.jump1370:
	jmp .jump1368
.jump1367:
	mov rax, [rel const350] ; 750
	push rax
	mov rax, [rel const415] ; 496
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
.jump1368:
	jmp .jump1366
.jump1365:
	mov rax, [rel const416] ; 705
	push rax
	mov rax, [rel const417] ; 446
	push rax
	mov rax, [rel const311] ; 898
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1371
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1371:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
.jump1366:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1372
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1374
	mov rax, [rel const26] ; False
	push rax
	pop rax
.jump1374:
	push rax
	pop rax
	cmp rax, 0
	je .jump1375
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1377
	mov rax, [rel const418] ; 797
	push rax
	jmp .jump1378
.jump1377:
	mov rax, [rel const419] ; 563
	push rax
.jump1378:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1379
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1379:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1380: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const419] ; 563
	push rax
	mov rax, [rel const420] ; 943
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1380 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump1376
.jump1375:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1381
	mov rax, [rel const421] ; 542
	push rax
	jmp .jump1382
.jump1381:
	mov rax, [rel const96] ; 56
	push rax
.jump1382:
.jump1376:
	jmp .jump1373
.jump1372:
	mov rax, [rel const422] ; 187
	push rax
.jump1373:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1383
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1383:
	cmp rax, [rsp + 24]
	jl .jump1384
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1384:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1385
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1385:
	cmp rax, [rsp + 32]
	jl .jump1386
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1386:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1387
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1387:
	cmp rax, [rsp + 40]
	jl .jump1388
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1388:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1389
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1389:
	cmp rax, [rsp + 16]
	jl .jump1390
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1390:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1391
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1391:
	cmp rax, [rsp + 24]
	jl .jump1392
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1392:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 16
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1155
.jump1154:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const320] ; 118
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1393
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1393:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by 118 
	jno .jump1394
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1394:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump1395: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1396
	sub rsp, 24
	; Moving 24 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _d
	add rsp, 8
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump1398
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const423] ; 117
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1400
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1400:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,][,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 117 
	jno .jump1401
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1401:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1402: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1402 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const424] ; 647
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1403
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1403:
	cmp rax, [rsp + 8]
	jl .jump1404
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1404:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1399
.jump1398:
	sub rsp, 24
	; Moving 24 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
.jump1399:
	jmp .jump1397
.jump1396:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const425] ; 411
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1405
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1405:
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1406
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1406:
	; Computing bound for 'j'
	mov rax, [rel const426] ; 379
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1407
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1407:
	; Computing bound for 'i'
	mov rax, [rel const409] ; 245
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1408
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1408:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1409: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1409 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1409 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1409 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1410
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1410:
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1411
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1411:
	; Computing bound for 'i'
	mov rax, [rel const136] ; 764
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1412
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1412:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1413: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1413 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1413 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1414
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1414:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,][,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[i : 764, j : h] i) 
	jno .jump1415
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1415:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[i : 245, j : 379, k : h] k) 
	jno .jump1416
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1416:
	imul rdi, [rsp + 0 + 16] ; multiply by 411 
	jno .jump1417
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1417:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1418: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1418 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1418 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1418 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const396] ; 316
	push rax
	mov rax, [rel const414] ; 801
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1419
	mov rax, [rel const150] ; 333
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump1420
.jump1419:
	mov rax, [rel const427] ; 741
	push rax
.jump1420:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const173] ; 159
	push rax
	mov rax, [rel const428] ; 444
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1421
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1421:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1422
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1422:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1423
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1423:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1424: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const429] ; 110
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1424 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1424 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1425
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1425:
	cmp rax, [rsp + 24]
	jl .jump1426
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1426:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1427
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1427:
	cmp rax, [rsp + 32]
	jl .jump1428
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1428:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1429
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1429:
	cmp rax, [rsp + 40]
	jl .jump1430
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1430:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump1397:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1431
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump1431:
	push rax
	pop rax
	cmp rax, 0
	je .jump1432
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1434
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump1435
.jump1434:
	mov rax, [rel const269] ; 392
	push rax
.jump1435:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1436
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1436:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by (if a then h else 392) 
	jno .jump1437
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1437:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1438: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1438 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump1433
.jump1432:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1439
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	jmp .jump1440
.jump1439:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1441
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1441:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump1442
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1442:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1443: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1443 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump1440:
.jump1433:
	mov rax, [rel const430] ; 791
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1444
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1444:
	cmp rax, [rsp + 8]
	jl .jump1445
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1445:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _d
	add rsp, 8
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump1446
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump1447
.jump1446:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const431] ; 521
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1448
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1448:
	; Computing bound for 'j'
	mov rax, [rel const432] ; 293
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1449
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1449:
	; Computing bound for 'i'
	mov rax, [rel const433] ; 359
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1450
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1450:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 359) 
	jno .jump1451
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1451:
	imul rdi, [rsp + 0 + 8] ; multiply by (h - 293) 
	jno .jump1452
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1452:
	imul rdi, [rsp + 0 + 16] ; multiply by 521 
	jno .jump1453
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1453:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1454: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1454 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1454 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1454 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const434] ; 483
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1455
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1455:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1456
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1456:
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const137] ; 473
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1457
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1457:
	; Computing bound for 'j'
	mov rax, [rel const435] ; 907
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1458
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1458:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1459
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1459:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1460: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1460 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1460 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1460 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1461
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1461:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[i : h, j : 907, k : 473] k) 
	jno .jump1462
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1462:
	imul rdi, [rsp + 0 + 8] ; multiply by (h + h) 
	jno .jump1463
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1463:
	imul rdi, [rsp + 0 + 16] ; multiply by 483 
	jno .jump1464
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1464:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1465: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1465 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1465 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1465 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rdi, 64
	call _jpl_alloc
	; Moving 64 bytes from rsp to rax 
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 64
	push rax
	mov rax, 2
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const436] ; 442
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1466
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1466:
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1467
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1467:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1468: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1468 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1469
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1469:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1470
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1470:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1471: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1472
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1472:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1473: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1473 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1471 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1471 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1471 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1474
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1474:
	cmp rax, [rsp + 8]
	jl .jump1475
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1475:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const437] ; 995
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1476
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump1476:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1477
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1477:
	; Computing bound for 'i'
	mov rax, [rel const51] ; 191
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1478
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1478:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 191 
	jno .jump1479
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1479:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump1480
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1480:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1481: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1481 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1481 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1482
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1482:
	cmp rax, [rsp + 16]
	jl .jump1483
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1483:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1484
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1484:
	cmp rax, [rsp + 24]
	jl .jump1485
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1485:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1486
	mov rax, [rel const279] ; 686
	push rax
	mov rax, [rel const129] ; 593
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	jmp .jump1487
.jump1486:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const438] ; 119
	push rax
	mov rax, [rel const439] ; 843
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1488
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1488:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1489
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1489:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1490: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const440] ; 853
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1490 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1490 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump1487:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1491
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1491:
	; Computing bound for 'k'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1492
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump1492:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1493
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1493:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1494
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1494:
	; Computing bound for 'j'
	mov rax, [rel const226] ; 813
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1495
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1495:
	; Computing bound for 'i'
	mov rax, [rel const441] ; 265
	push rax
	mov rax, [rel const442] ; 809
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1496
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1496:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (809 * 265) 
	jno .jump1497
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1497:
	imul rdi, [rsp + 0 + 8] ; multiply by 813 
	jno .jump1498
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1498:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump1499
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1499:
	imul rdi, [rsp + 0 + 24] ; multiply by (h / h) 
	jno .jump1500
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1500:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1501: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1502
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1502:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1503
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1503:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1504
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1504:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1505: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1505 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1505 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1505 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1501 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1501 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1501 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1501 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const443] ; 59
	push rax
	mov rax, [rel const400] ; 176
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1506
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
.jump1506:
	push rax
	pop rax
	cmp rax, 0
	je .jump1507
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1509
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump1510
.jump1509:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump1510:
	jmp .jump1508
.jump1507:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1511
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump1512
.jump1511:
	mov rax, [rel const400] ; 176
	push rax
.jump1512:
.jump1508:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rel const444] ; 40
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1513
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1513:
	cmp rax, [rsp + 32]
	jl .jump1514
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1514:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1515
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1515:
	cmp rax, [rsp + 40]
	jl .jump1516
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1516:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1517
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1517:
	cmp rax, [rsp + 48]
	jl .jump1518
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1518:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1519
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1519:
	cmp rax, [rsp + 56]
	jl .jump1520
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1520:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1521
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1521:
	; Computing bound for 'j'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1522
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1522:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump1523
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1523:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1524: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1524 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1525
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1525:
	; Computing bound for 'i'
	mov rax, [rel const128] ; 862
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1526
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1526:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1527: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1528
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1528:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1529
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1529:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1530: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const174] ; 981
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 8], 1
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1530 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1530 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 8], 1
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1527 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1527 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1531
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1531:
	cmp rax, [rsp + 8]
	jl .jump1532
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1532:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1533
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1533:
	; Computing bound for 'i'
	mov rax, [rel const445] ; 552
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1534
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1534:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1535: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1536
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1536:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1537
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump1538
.jump1537:
	mov rax, [rel const351] ; 474
	push rax
.jump1538:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1539
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1539:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1540
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1540:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1541: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1541 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1541 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1541 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 24], 1
	; Compare l to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1535 ; If l < bound, next iter
	mov qword [rsp + 24], 0 ; l = 0
	add qword [rsp + 16], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1535 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1535 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1535 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1542
	mov rax, [rel const446] ; 595
	push rax
	jmp .jump1543
.jump1542:
	mov rax, [rel const447] ; 414
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
.jump1543:
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1544
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1546
	mov rax, [rel const239] ; 880
	push rax
	jmp .jump1547
.jump1546:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1548
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const448] ; 602
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1550
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1550:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1551: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const100] ; 765
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1551 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump1549
.jump1548:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump1549:
.jump1547:
	jmp .jump1545
.jump1544:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1552
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	jmp .jump1553
.jump1552:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
.jump1553:
	pop rax
	cmp rax, 0
	je .jump1554
	mov rax, [rel const449] ; 610
	push rax
	jmp .jump1555
.jump1554:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1556
	mov rax, [rel const83] ; 523
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	jmp .jump1557
.jump1556:
	mov rax, [rel const450] ; 989
	push rax
.jump1557:
.jump1555:
.jump1545:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1558
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1558:
	cmp rax, [rsp + 24]
	jl .jump1559
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1559:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1560
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1560:
	cmp rax, [rsp + 32]
	jl .jump1561
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1561:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1562
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1562:
	cmp rax, [rsp + 40]
	jl .jump1563
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1563:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump1447:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1395 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump1155:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump1564
	lea rdi, [rel const451] ; 'k'
	call _fail_assertion
.jump1564:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1565
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1565:
	; Computing bound for 'l'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1566
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump1567
.jump1566:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump1567:
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1568
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1568:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1569
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1569:
	; Computing bound for 'l'
	mov rax, [rel const5] ; 883
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1570
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1570:
	; Computing bound for 'k'
	mov rax, [rel const452] ; 827
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1571
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1571:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1572: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 24], 1
	; Compare n to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1572 ; If n < bound, next iter
	mov qword [rsp + 24], 0 ; n = 0
	add qword [rsp + 16], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1572 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1572 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1572 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const128] ; 862
	push rax
	mov rax, [rel const453] ; 15
	push rax
	mov rax, [rel const454] ; 143
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1573
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1573:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1574
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const240] ; 20
	push rax
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	mov rax, [rel const265] ; 939
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1576
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1576:
	cmp rax, [rsp + 8]
	jl .jump1577
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1577:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1575
.jump1574:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump1575:
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1578
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1578:
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1579
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump1580
.jump1579:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump1580:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1581
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1581:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump1582: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 16], 1
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1582 ; If m < bound, next iter
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1582 ; If l < bound, next iter
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1582 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1583
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1585
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1585:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1586
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1586:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump1587
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1587:
	imul rdi, [rsp + 0 + 8] ; multiply by i 
	jno .jump1588
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1588:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1589: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1589 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1589 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const455] ; 971
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1590
	mov rax, [rel const11] ; True
	push rax
	jmp .jump1591
.jump1590:
	mov rax, [rel const26] ; False
	push rax
.jump1591:
	pop rax
	cmp rax, 0
	je .jump1592
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump1593
.jump1592:
	mov rax, [rel const456] ; 24
	push rax
.jump1593:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1594
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1594:
	cmp rax, [rsp + 16]
	jl .jump1595
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1595:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1596
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1596:
	cmp rax, [rsp + 24]
	jl .jump1597
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1597:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1598
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump1599
.jump1598:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump1599:
	call _d
	add rsp, 8
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump1600
	sub rsp, 24
	; Moving 24 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	call _d
	add rsp, 8
	add rsp, 24
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
.jump1600:
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1601
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const60] ; 837
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1603
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1603:
	; Computing bound for 'l'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1604
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump1605
.jump1604:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump1605:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1606
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1606:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (- (if false then k else i)) 
	jno .jump1607
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1607:
	imul rdi, [rsp + 0 + 8] ; multiply by 837 
	jno .jump1608
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1608:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1609: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1609 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1609 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1610
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1610:
	; Computing bound for 'l'
	mov rax, [rel const457] ; 633
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1611
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1611:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1612: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1613
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump1613:
	cqo
	idiv r10
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1612 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1612 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1614
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1614:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1615: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1615 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1616
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1616:
	cmp rax, [rsp + 16]
	jl .jump1617
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1617:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1618
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1618:
	cmp rax, [rsp + 24]
	jl .jump1619
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1619:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1620
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1622
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump1623
.jump1622:
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1624
	mov rax, [rel const399] ; 942
	push rax
	jmp .jump1625
.jump1624:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1626
	mov rax, [rel const458] ; 34
	push rax
	jmp .jump1627
.jump1626:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump1627:
.jump1625:
.jump1623:
	pop rax
	neg rax
	push rax
	jmp .jump1621
.jump1620:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1628
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1628:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const459] ; 12
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1629
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump1630
.jump1629:
	mov rax, [rel const460] ; 972
	push rax
.jump1630:
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1631
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1631:
	cmp rax, [rsp + 8]
	jl .jump1632
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1632:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1633
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1633:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1634: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1634 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1634 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump1621:
	jmp .jump1602
.jump1601:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1635
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1635:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1636
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1636:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1637
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1637:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump1638: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1639
	mov rax, [rel const435] ; 907
	push rax
	jmp .jump1640
.jump1639:
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
.jump1640:
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1638 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1638 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1638 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	neg rax
	push rax
.jump1602:
	jmp .jump1584
.jump1583:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump1584:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1641
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1641:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1642
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1642:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1643: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 0], 1
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1643 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1644
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1644:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1645
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1645:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by i 
	jno .jump1646
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1646:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[m : k] m) 
	jno .jump1647
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1647:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump1648: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1649
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1649:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1650
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1650:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1651
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1651:
	; Computing bound for 'o'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1652
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1652:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1653
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1653:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1654: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1654 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1654 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1655
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1655:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[o : (l + l), p : l] l) 
	jno .jump1656
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1656:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1657: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1657 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1658
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1658:
	cmp rax, [rsp + 8]
	jl .jump1659
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1659:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1660
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1660:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1661: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1661 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1661 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1661 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1661 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1662
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1662:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1663
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1663:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by (- i) 
	jno .jump1664
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1664:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[o : (array[o : (sum[o : (l + l), p : l] l)] m)[i], p : l, q : (- l), r : l] (- r)) 
	jno .jump1665
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1665:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump1666: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1667
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1667:
	; Computing bound for 's'
	mov rax, [rel const461] ; 839
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1668
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1668:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1669
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1669:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const293] ; 479
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1670
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	jmp .jump1671
.jump1670:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump1671:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1672
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1672:
	cqo
	idiv r10
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1673
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1673:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by (((if false then p else k) / (- 479)) - k) 
	jno .jump1674
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1674:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump1675
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1675:
	imul rdi, [rsp + 0 + 16] ; multiply by 839 
	jno .jump1676
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1676:
	imul rdi, [rsp + 0 + 24] ; multiply by m 
	jno .jump1677
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1677:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump1678: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 't'
	add qword [rsp + 24], 1
	; Compare t to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1678 ; If t < bound, next iter
	mov qword [rsp + 24], 0 ; t = 0
	add qword [rsp + 16], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1678 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1678 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1678 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const325] ; 274
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1679
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1679:
	cmp rax, [rsp + 32]
	jl .jump1680
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1680:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1681
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1681:
	cmp rax, [rsp + 40]
	jl .jump1682
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1682:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1683
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1683:
	cmp rax, [rsp + 48]
	jl .jump1684
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1684:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1685
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1685:
	cmp rax, [rsp + 56]
	jl .jump1686
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1686:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1666 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1666 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1648 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1648 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _d
	add rsp, 8
	add rsp, 24
	push rax
	pop rax
	add rsp, 48 ; Local variables
	pop rbp
	ret

i:
_i:
	push rbp
	mov rbp, rsp
	mov rax, [rel const612] ; 71.61
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 0 ; Local variables
	pop rbp
	ret
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump2367
	mov rax, [rel const26] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump2367:
	push rax
	pop rax
	cmp rax, 0
	je .jump2368
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2370
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2372
	sub rsp, 16
	; Moving 16 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2374
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2374:
	cmp rax, [rsp + 8]
	jl .jump2375
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2375:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump2373
.jump2372:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
.jump2373:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2376
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2376:
	; Computing bound for 'o'
	mov rax, [rel const65] ; 140
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2377
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2377:
	; Computing bound for 'n'
	mov rax, [rel const613] ; 277
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2378
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2378:
	; Computing bound for 'm'
	mov rax, [rel const614] ; 463
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2379
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2379:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2380: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2381
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2381:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump2382
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2382:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump2383: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 0], 1
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2383 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2384
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2384:
	cmp rax, [rsp + 8]
	jl .jump2385
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2385:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2380 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2380 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2380 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2380 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2386
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2386:
	; Computing bound for 'o'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	mov rax, [rel const615] ; 49.24
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2387
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump2388
.jump2387:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2389
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2391
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2391:
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2392
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2392:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2393: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 0], 1
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2393 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2394
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2394:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2395: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2396
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2396:
	cqo
	idiv r10
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2395 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2395 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump2390
.jump2389:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
.jump2390:
.jump2388:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2397
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2397:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2398
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2398:
	; Computing bound for 'm'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2399
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2401
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2401:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2402
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2402:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2403
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2403:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2404: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2404 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2404 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2404 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump2400
.jump2399:
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2405
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump2406
.jump2405:
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
.jump2406:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
.jump2400:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2407
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2407:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
imul rdi, [rsp + 0 + 0] ; multiply by (- (if (! false) then (sum[m : f, n : h, o : k] h) else (f - (if false then k else h)))) 
	jno .jump2408
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2408:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump2409
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2409:
imul rdi, [rsp + 0 + 16] ; multiply by (if ((! (c <= 49.24)) == (! (! false))) then (- k) else (if a then (sum[m : (sum[m : f] m), n : h] (f / f)) else f)) 
	jno .jump2410
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2410:
imul rdi, [rsp + 0 + 24] ; multiply by (- (sum[m : (- 463), n : 277, o : 140, p : (if a then e[h] else f)] (array[q : k] m)[f])) 
	jno .jump2411
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2411:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2412: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2413
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2415
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump2416
.jump2415:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump2416:
	jmp .jump2414
.jump2413:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump2414:
	pop rax
	cmp rax, 0
	je .jump2417
	sub rsp, 32
	; Moving 32 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	jmp .jump2418
.jump2417:
	mov rax, [rel const616] ; 78.95
	push rax
	mov rax, [rel const617] ; 33.35
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump2418:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2412 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2412 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2412 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2412 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump2371
.jump2370:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2419
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	mov rax, [rel const85] ; 259
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2421
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2421:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2422
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2422:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2423
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2423:
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const549] ; 291
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2424
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2424:
	; Computing bound for 'n'
	mov rax, [rel const342] ; 872
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2425
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2425:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2426
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2426:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2427: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2427 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2427 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2427 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2428
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2428:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2429: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2430
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2430:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2431
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2431:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2432
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2432:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump2433: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const618] ; 29.3
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 's'
	add qword [rsp + 16], 1
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2433 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2433 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2433 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2429 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2429 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2429 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2429 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2434
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2436
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2436:
	; Computing bound for 'm'
	mov rax, [rel const401] ; 535
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2437
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump2437:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2438
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2438:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof float[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (f / 535) 
	jno .jump2439
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2439:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump2440
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2440:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2441: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2442
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2442:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2443
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2443:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2444
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2444:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2445
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2445:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump2446
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2446:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump2447
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2447:
	imul rdi, [rsp + 0 + 16] ; multiply by f 
	jno .jump2448
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2448:
	imul rdi, [rsp + 0 + 24] ; multiply by n 
	jno .jump2449
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2449:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump2450: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2450 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2450 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2450 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2450 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2441 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2441 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2451
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2451:
	cmp rax, [rsp + 16]
	jl .jump2452
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2452:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2453
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2453:
	cmp rax, [rsp + 24]
	jl .jump2454
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2454:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 40
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump2435
.jump2434:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2455
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump2456
.jump2455:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
.jump2456:
	pop rax
	cmp rax, 0
	je .jump2457
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	mov rax, [rel const60] ; 837
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2459
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2459:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2460
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2460:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2461
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump2462
.jump2461:
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
.jump2462:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2463
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2463:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2464
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2464:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump2465
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2465:
	imul rdi, [rsp + 0 + 8] ; multiply by (if a then f else h) 
	jno .jump2466
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2466:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump2467
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2467:
	imul rdi, [rsp + 0 + 24] ; multiply by 837 
	jno .jump2468
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2468:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2469: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const619] ; 32.77
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2469 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2469 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2469 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2469 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump2458
.jump2457:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	mov rax, [rel const401] ; 535
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2470
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2470:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2471
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2471:
	; Computing bound for 'n'
	mov rax, [rel const128] ; 862
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2472
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2472:
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const620] ; 229
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2473
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2473:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2474
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2474:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2475
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2475:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2476: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2476 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2476 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2476 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2477
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2477:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[m : k, n : k, o : 229] n) 
	jno .jump2478
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2478:
	imul rdi, [rsp + 0 + 8] ; multiply by 862 
	jno .jump2479
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2479:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump2480
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2480:
	imul rdi, [rsp + 0 + 24] ; multiply by 535 
	jno .jump2481
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2481:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2482: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2482 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2482 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2482 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2482 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump2458:
.jump2435:
	jmp .jump2420
.jump2419:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2483
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2483:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2484
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2484:
	; Computing bound for 'n'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2485
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2485:
	; Computing bound for 'o'
	mov rax, [rel const621] ; 681
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2486
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2486:
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2487
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2487:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2488: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 0], 1
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2488 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2489
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2489:
	; Computing bound for 'm'
	mov rax, [rel const583] ; 588
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2490
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2490:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 588 
	jno .jump2491
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2491:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[m : f] m) 
	jno .jump2492
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2492:
	imul rdi, [rsp + 0 + 16] ; multiply by 681 
	jno .jump2493
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2493:
	imul rdi, [rsp + 0 + 24] ; multiply by h 
	jno .jump2494
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2494:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2495: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2495 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2495 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2495 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2495 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2496
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump2497
.jump2496:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
.jump2497:
	mov rax, [rel const622] ; 711
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2498
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2498:
	cmp rax, [rsp + 32]
	jl .jump2499
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2499:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2500
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2500:
	cmp rax, [rsp + 40]
	jl .jump2501
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2501:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2502
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2502:
	cmp rax, [rsp + 48]
	jl .jump2503
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2503:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2504
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2504:
	cmp rax, [rsp + 56]
	jl .jump2505
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2505:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2506
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2506:
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2507
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2507:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2508: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2509
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump2510
.jump2509:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump2510:
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 0], 1
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2508 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2511
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2511:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[m : h] (if (! a) then (- h) else m)) 
	jno .jump2512
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2512:
imul rdi, [rsp + 0 + 8] ; multiply by (array[m : 588, n : (sum[m : f] m), o : 681, p : h] m)[(- (- h)), 711, (if true then k else (k * k)), h] 
	jno .jump2513
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2513:
	imul rdi, [rsp + 0 + 16] ; multiply by (- k) 
	jno .jump2514
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2514:
	imul rdi, [rsp + 0 + 24] ; multiply by f 
	jno .jump2515
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2515:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2516: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2517
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	jmp .jump2518
.jump2517:
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
.jump2518:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2519
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2519:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2520
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2520:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2521
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2521:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2522
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2522:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump2523: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 't'
	add qword [rsp + 24], 1
	; Compare t to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2523 ; If t < bound, next iter
	mov qword [rsp + 24], 0 ; t = 0
	add qword [rsp + 16], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2523 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2523 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2523 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2516 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2516 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2516 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2516 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump2420:
.jump2371:
	jmp .jump2369
.jump2368:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2524
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2524:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2525
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2525:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2526
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2526:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (- h) 
	jno .jump2527
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2527:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump2528
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2528:
	imul rdi, [rsp + 0 + 16] ; multiply by (- k) 
	jno .jump2529
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2529:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2530: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const26] ; False
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2530 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2530 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2530 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const480] ; 208
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2531
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2531:
	; Computing bound for 'n'
	mov rax, [rel const144] ; 91
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2532
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2532:
	; Computing bound for 'm'
	mov rax, [rel const623] ; 733
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2533
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2533:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2534: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2534 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2534 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2534 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2535
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2535:
	cmp rax, [rsp + 24]
	jl .jump2536
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2536:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2537
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2537:
	cmp rax, [rsp + 32]
	jl .jump2538
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2538:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2539
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2539:
	cmp rax, [rsp + 40]
	jl .jump2540
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2540:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2541
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2543
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2545
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2545:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2546
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2546:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2547: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const624] ; 90.34
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2547 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2547 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump2544
.jump2543:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2548
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2548:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2549
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2549:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2550
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2550:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2551: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const625] ; 47.21
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2551 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2551 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2551 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump2544:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2552
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2552:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2553
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2553:
	; Computing bound for 'm'
	mov rax, [rel const280] ; 848
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2554
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2554:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2555: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2555 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2555 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2555 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2556
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2556:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2557: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const626] ; 43.44
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'm'
	add qword [rsp + 0], 1
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2557 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2558
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const627] ; 217
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2560
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2560:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof float[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 217 
	jno .jump2561
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2561:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2562: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	mov rax, [rel const417] ; 446
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2563
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2563:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2564
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2564:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2565
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2565:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2566
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2566:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by (- h) 
	jno .jump2567
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2567:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump2568
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2568:
	imul rdi, [rsp + 0 + 16] ; multiply by (- f) 
	jno .jump2569
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2569:
	imul rdi, [rsp + 0 + 24] ; multiply by 446 
	jno .jump2570
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2570:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2571: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const628] ; 60.78
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2571 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2571 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2571 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2571 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'm'
	add qword [rsp + 0], 1
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2562 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2572
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2572:
	cmp rax, [rsp + 8]
	jl .jump2573
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2573:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump2559
.jump2558:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	mov rax, [rel const629] ; 170
	push rax
	mov rax, [rel const347] ; 89
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2574
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2574:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2575
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2575:
	; Computing bound for 'o'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2576
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2576:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2577
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2577:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2578
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2578:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2579
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2579:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump2580
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2580:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump2581
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2581:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump2582
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2582:
	imul rdi, [rsp + 0 + 24] ; multiply by f 
	jno .jump2583
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2583:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2584: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2584 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2584 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2584 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2584 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const134] ; 472
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2585
	mov rax, [rel const602] ; 955
	push rax
	jmp .jump2586
.jump2585:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
.jump2586:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2587
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2587:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const178] ; 475
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2588
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2588:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2589: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2590
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump2590:
	cqo
	idiv r10
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2589 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2589 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const630] ; 933
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2591
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2591:
	cmp rax, [rsp + 32]
	jl .jump2592
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2592:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2593
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2593:
	cmp rax, [rsp + 40]
	jl .jump2594
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2594:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2595
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2595:
	cmp rax, [rsp + 48]
	jl .jump2596
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2596:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2597
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2597:
	cmp rax, [rsp + 56]
	jl .jump2598
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2598:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2599
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2599:
	; Computing bound for 'n'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const631] ; 979
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2600
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2600:
	; Computing bound for 'n'
	mov rax, [rel const632] ; 88
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2601
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2601:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2602
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2602:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump2603
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2603:
	imul rdi, [rsp + 0 + 8] ; multiply by 88 
	jno .jump2604
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2604:
	imul rdi, [rsp + 0 + 16] ; multiply by 979 
	jno .jump2605
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2605:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2606: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2606 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2606 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2606 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2607
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2607:
	; Computing bound for 'm'
	mov rax, [rel const633] ; 509
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2608
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2608:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2609: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2609 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2609 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2610
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2610:
	cmp rax, [rsp + 24]
	jl .jump2611
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2611:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2612
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2612:
	cmp rax, [rsp + 32]
	jl .jump2613
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2613:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2614
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2614:
	cmp rax, [rsp + 40]
	jl .jump2615
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2615:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2616
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2616:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2617
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2617:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump2618
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2618:
imul rdi, [rsp + 0 + 8] ; multiply by (array[m : f, n : 88, o : 979] (- k))[h, (sum[m : 509, n : f] f), f] 
	jno .jump2619
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2619:
imul rdi, [rsp + 0 + 16] ; multiply by (array[m : h, n : f, o : h, p : f] p)[933, (sum[m : (475 + k), n : (if false then 955 else f)] (m / f)), (- f), (472 - k)] 
	jno .jump2620
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2620:
	imul rdi, [rsp + 0 + 24] ; multiply by (89 % 170) 
	jno .jump2621
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2621:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2622: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 't'
	mov rax, [rel const634] ; 63
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2623
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2623:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2624
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2624:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2625
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2625:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump2626: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 's'
	add qword [rsp + 16], 1
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2626 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2626 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2626 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2627
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2627:
	; Computing bound for 's'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2628
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2628:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2629
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2629:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2630
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2630:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2631
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2631:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump2632
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2632:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump2633
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2633:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump2634
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2634:
	imul rdi, [rsp + 0 + 24] ; multiply by n 
	jno .jump2635
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2635:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump2636: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 't'
	add qword [rsp + 24], 1
	; Compare t to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2636 ; If t < bound, next iter
	mov qword [rsp + 24], 0 ; t = 0
	add qword [rsp + 16], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2636 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2636 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2636 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2637
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2637:
	; Computing bound for 'r'
	mov rax, [rel const635] ; 258
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2638
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2638:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2639
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2639:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump2640: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 's'
	add qword [rsp + 16], 1
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2640 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2640 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2640 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const221] ; 904
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2641
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2641:
	cmp rax, [rsp + 32]
	jl .jump2642
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2642:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2643
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2643:
	cmp rax, [rsp + 40]
	jl .jump2644
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2644:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2645
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2645:
	cmp rax, [rsp + 48]
	jl .jump2646
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2646:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2647
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2647:
	cmp rax, [rsp + 56]
	jl .jump2648
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2648:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2649
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2649:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2650
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2650:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2651
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2651:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump2652: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 't'
	add qword [rsp + 24], 1
	; Compare t to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2652 ; If t < bound, next iter
	mov qword [rsp + 24], 0 ; t = 0
	add qword [rsp + 16], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2652 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2652 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2652 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2622 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2622 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2622 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2622 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump2559:
	jmp .jump2542
.jump2541:
	sub rsp, 32
	; Moving 32 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _i
	add rsp, 16
	add rsp, 32
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2653
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2653:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2654
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2654:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2655
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2655:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2656: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2657
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2657:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2658
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2658:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2659
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2659:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump2660: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2660 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2660 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2660 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2656 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2656 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2656 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2661
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2663
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2663:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2664
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2664:
	; Computing bound for 'm'
	mov rax, [rel const158] ; 112
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2665
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2665:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof float[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 112 
	jno .jump2666
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2666:
	imul rdi, [rsp + 0 + 8] ; multiply by (- (f / f)) 
	jno .jump2667
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2667:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2668: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2669
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2669:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2670
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2670:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2671
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2671:
	; Computing bound for 'o'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2672
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump2673
.jump2672:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump2673:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2674
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2674:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by (if false then n else n) 
	jno .jump2675
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2675:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump2676
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2676:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump2677
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2677:
	imul rdi, [rsp + 0 + 24] ; multiply by f 
	jno .jump2678
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2678:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump2679: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const636] ; 50.75
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2679 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2679 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2679 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2679 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2668 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2668 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump2662
.jump2661:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const388] ; 121
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2680
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2680:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2681
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2681:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof float[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump2682
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2682:
	imul rdi, [rsp + 0 + 8] ; multiply by 121 
	jno .jump2683
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2683:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2684: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2685
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2685:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2686
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2686:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2687
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2687:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2688
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2688:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump2689
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2689:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump2690
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2690:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump2691
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2691:
	imul rdi, [rsp + 0 + 24] ; multiply by n 
	jno .jump2692
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2692:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump2693: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _i
	add rsp, 16
	add rsp, 32
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2693 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2693 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2693 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2693 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2684 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2684 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump2662:
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const637] ; 814
	push rax
	mov rax, [rel const638] ; 669
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2694
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2694:
	cmp rax, [rsp + 16]
	jl .jump2695
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2695:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2696
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2696:
	cmp rax, [rsp + 24]
	jl .jump2697
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2697:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 40
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2542:
.jump2369:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2698
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2698:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	mov rax, [rel const543] ; 977
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2699
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2699:
	cmp rax, [rsp + 8]
	jl .jump2700
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2700:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2701
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2701:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2702
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2702:
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const639] ; 88.48
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2703
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2705
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump2706
.jump2705:
	mov rax, [rel const640] ; 416
	push rax
.jump2706:
	jmp .jump2704
.jump2703:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const641] ; 648
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
.jump2704:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2707
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2707:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2708
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2708:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2709
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2709:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2710
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2710:
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2711
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump2712
.jump2711:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
.jump2712:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2713
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2713:
	; Computing bound for 'm'
	sub rsp, 16
	; Moving 16 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const527] ; 439
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2714
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2714:
	cmp rax, [rsp + 8]
	jl .jump2715
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2715:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2716
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2716:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2717: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const104] ; 103
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2718
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2718:
	cmp rax, [rsp + 8]
	jl .jump2719
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2719:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2717 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2717 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2720
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2720:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2721: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2721 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2721 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2721 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2721 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2722
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2722:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2723
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2723:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2724
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2724:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2725: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2725 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2725 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2725 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2725 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2726
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const227] ; 378
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2728
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2728:
	; Computing bound for 'm'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2729
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2729:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- k) 
	jno .jump2730
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2730:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2731: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const642] ; 275
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 0], 1
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2731 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const643] ; 375
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2732
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2732:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2733
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2733:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2734
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2734:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2735: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2735 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2735 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2735 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2736
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2736:
	cmp rax, [rsp + 8]
	jl .jump2737
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2737:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2738
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2738:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (- (array[m : (- k)] 275)[(sum[m : (- h), n : h, o : 375] n)]) 
	jno .jump2739
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2739:
	imul rdi, [rsp + 0 + 8] ; multiply by (f - (- 378)) 
	jno .jump2740
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2740:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2741: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2741 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2741 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump2727
.jump2726:
	mov rax, [rel const26] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2742
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2744
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
.jump2744:
	push rax
	pop rax
	cmp rax, 0
	je .jump2745
	mov rax, [rel const11] ; True
	push rax
	jmp .jump2746
.jump2745:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump2747
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump2747:
	push rax
	pop rax
	xor rax, 1
	push rax
.jump2746:
	pop rax
	cmp rax, 0
	je .jump2748
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2750
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2750:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2751
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2751:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump2752
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2752:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump2753
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2753:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2754: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2754 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2754 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2755
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2755:
	; Computing bound for 'm'
	mov rax, [rel const644] ; 49
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2756
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2756:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2757: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2757 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2757 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2758
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2758:
	cmp rax, [rsp + 16]
	jl .jump2759
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2759:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2760
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2760:
	cmp rax, [rsp + 24]
	jl .jump2761
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2761:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2762
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const645] ; 550
	push rax
	mov rax, [rel const646] ; 895
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2764
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2764:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2765
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2765:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- k) 
	jno .jump2766
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2766:
	imul rdi, [rsp + 0 + 8] ; multiply by (895 + 550) 
	jno .jump2767
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2767:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2768: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2769
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2769:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2770
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2770:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2771
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2771:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump2772: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2772 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2772 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2772 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2768 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2768 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump2763
.jump2762:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2773
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2773:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2774
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2774:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump2775
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2775:
	imul rdi, [rsp + 0 + 8] ; multiply by (h - f) 
	jno .jump2776
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2776:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2777: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2777 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2777 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump2763:
	jmp .jump2749
.jump2748:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2778
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump2779
.jump2778:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
.jump2779:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2780
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2780:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2781
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2781:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2782
	mov rax, [rel const647] ; 528
	push rax
	jmp .jump2783
.jump2782:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
.jump2783:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2784
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2784:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if a then 528 else f) 
	jno .jump2785
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2785:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump2786
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2786:
	imul rdi, [rsp + 0 + 16] ; multiply by (if true then f else f) 
	jno .jump2787
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2787:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2788: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2789
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2789:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2790
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2790:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump2791
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2791:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump2792
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2792:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump2793: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 8], 1
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2793 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2793 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2788 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2788 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2788 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2794
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2796
	mov rax, [rel const115] ; 719
	push rax
	jmp .jump2797
.jump2796:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
.jump2797:
	jmp .jump2795
.jump2794:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const645] ; 550
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2798
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2798:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2799
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2799:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2800: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2800 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2800 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump2795:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	mov rax, [rel const648] ; 515
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2801
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2801:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2802
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2802:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const649] ; 188
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2803
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2803:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2804
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2804:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2805: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2805 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2805 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2805 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2805 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const650] ; 452
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2806
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2806:
	cmp rax, [rsp + 24]
	jl .jump2807
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2807:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2808
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2808:
	cmp rax, [rsp + 32]
	jl .jump2809
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2809:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2810
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2810:
	cmp rax, [rsp + 40]
	jl .jump2811
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2811:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2749:
	jmp .jump2743
.jump2742:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2812
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2814
	mov rax, [rel const26] ; False
	push rax
	jmp .jump2815
.jump2814:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump2815:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2816
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2818
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2818:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2819
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2819:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump2820
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2820:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump2821
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2821:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2822: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2822 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2822 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump2817
.jump2816:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const651] ; 525
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2823
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2823:
	; Computing bound for 'm'
	mov rax, [rel const2] ; 886
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2824
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2824:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 886 
	jno .jump2825
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2825:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 525) 
	jno .jump2826
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2826:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2827: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2827 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2827 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump2817:
	jmp .jump2813
.jump2812:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const442] ; 809
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2828
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2828:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2829
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2829:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- (- f)) 
	jno .jump2830
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2830:
	imul rdi, [rsp + 0 + 8] ; multiply by ((- 809) + f) 
	jno .jump2831
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2831:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2832: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2833
	mov rax, [rel const11] ; True
	push rax
	pop rax
.jump2833:
	push rax
	pop rax
	cmp rax, 0
	je .jump2834
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2836
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2836:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump2837: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2837 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump2835
.jump2834:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump2835:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2832 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2832 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump2813:
.jump2743:
.jump2727:
	mov rax, [rel const646] ; 895
	push rax
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2838
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2840
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2840:
	cmp rax, [rsp + 8]
	jl .jump2841
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2841:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2842
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2842:
	cmp rax, [rsp + 24]
	jl .jump2843
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2843:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2844
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2844:
	cmp rax, [rsp + 32]
	jl .jump2845
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2845:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2846
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2846:
	cmp rax, [rsp + 40]
	jl .jump2847
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2847:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2848
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump2849
.jump2848:
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
.jump2849:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2850
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2850:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2851: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 0], 1
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2851 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump2839
.jump2838:
	mov rax, [rel const109] ; 238
	push rax
	pop rax
	neg rax
	push rax
.jump2839:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2852
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2852:
	cmp rax, [rsp + 16]
	jl .jump2853
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2853:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2854
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2854:
	cmp rax, [rsp + 24]
	jl .jump2855
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2855:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const5] ; 883
	push rax
	mov rax, [rel const643] ; 375
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2856
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2856:
	cmp rax, [rsp + 32]
	jl .jump2857
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2857:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2858
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2858:
	cmp rax, [rsp + 40]
	jl .jump2859
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2859:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2860
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2860:
	cmp rax, [rsp + 48]
	jl .jump2861
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2861:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2862
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2862:
	cmp rax, [rsp + 56]
	jl .jump2863
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2863:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 0 ; Local variables
	pop rbp
	ret
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2864
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2866
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2868
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2868:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2869
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2869:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump2870
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2870:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump2871
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2871:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2872: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2872 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2872 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump2867
.jump2866:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2873
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2873:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2874
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2874:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump2875
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2875:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump2876
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2876:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2877: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2877 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2877 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump2867:
	mov rax, [rel const652] ; 836
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const338] ; 901
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rel const653] ; 366
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2878
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2878:
	cmp rax, [rsp + 16]
	jl .jump2879
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2879:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2880
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2880:
	cmp rax, [rsp + 24]
	jl .jump2881
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2881:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump2865
.jump2864:
	mov rax, [rel const654] ; 615
	push rax
.jump2865:
	mov rax, [rel const249] ; 241
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2882
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2884
	mov rax, [rel const655] ; 53.41
	push rax
	jmp .jump2885
.jump2884:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
.jump2885:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Add alignment
	sub rsp, 32
	; Moving 32 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _i
	add rsp, 16
	add rsp, 32
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2886
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2886:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2887
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2887:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2888
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2888:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2889: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2889 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2889 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2889 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2890
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2890:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2891: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const656] ; 84.3
	push rax
	sub rsp, 32
	; Moving 32 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 16 to rsp + 24 
		mov r10, [rsp + 16 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'm'
	add qword [rsp + 0], 1
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2891 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2892
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2892:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2893
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2893:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2894
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2894:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2895
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2895:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2896
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2896:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2897
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2897:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2898: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2898 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2898 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2898 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2899
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2899:
	cmp rax, [rsp + 8]
	jl .jump2900
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2900:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2901
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2901:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2902: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2903
	mov rax, [rel const657] ; 76.12
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump2904
.jump2903:
	mov rax, [rel const658] ; 7.93
	push rax
.jump2904:
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2902 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2902 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2902 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2902 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2905
	mov rax, [rel const659] ; 39.6
	push rax
	jmp .jump2906
.jump2905:
	mov rax, [rel const660] ; 21.25
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump2906:
	sub rsp, 32
	; Moving 32 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2907
	mov rax, [rel const72] ; 512
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2909
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump2910
.jump2909:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2911
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump2912
.jump2911:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2913
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump2913:
	cqo
	idiv r10
	push rax
.jump2912:
.jump2910:
	jmp .jump2908
.jump2907:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
.jump2908:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2914
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2914:
	cmp rax, [rsp + 8]
	jl .jump2915
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2915:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump2883
.jump2882:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	mov rax, [rel const83] ; 523
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2916
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2916:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2917
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2917:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2918
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2918:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2919
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2919:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- f) 
	jno .jump2920
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2920:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump2921
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2921:
	imul rdi, [rsp + 0 + 16] ; multiply by (- h) 
	jno .jump2922
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2922:
	imul rdi, [rsp + 0 + 24] ; multiply by 523 
	jno .jump2923
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2923:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2924: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2925
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2925:
	; Computing bound for 'q'
	mov rax, [rel const182] ; 300
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2926
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2926:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by 300 
	jno .jump2927
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2927:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump2928
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2928:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump2929: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'r'
	add qword [rsp + 8], 1
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2929 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2929 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'p'
	add qword [rsp + 24], 1
	; Compare p to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2924 ; If p < bound, next iter
	mov qword [rsp + 24], 0 ; p = 0
	add qword [rsp + 16], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2924 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2924 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2924 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2930
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2930:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2931
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2931:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2932
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump2933
.jump2932:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump2933:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2934
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2934:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2935: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2936
	mov rax, [rel const661] ; 851
	push rax
	jmp .jump2937
.jump2936:
	mov rax, [rel const264] ; 458
	push rax
.jump2937:
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2935 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2935 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2935 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2938
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2938:
	cmp rax, [rsp + 32]
	jl .jump2939
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2939:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2940
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2940:
	cmp rax, [rsp + 40]
	jl .jump2941
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2941:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2942
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2942:
	cmp rax, [rsp + 48]
	jl .jump2943
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2943:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2944
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2944:
	cmp rax, [rsp + 56]
	jl .jump2945
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2945:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2946
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2946:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2947: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 0], 1
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2947 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2948
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump2949
.jump2948:
	mov rax, [rel const590] ; 768
	push rax
.jump2949:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2950
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2950:
	cmp rax, [rsp + 16]
	jl .jump2951
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2951:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2952
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2952:
	cmp rax, [rsp + 24]
	jl .jump2953
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2953:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _i
	add rsp, 16
	add rsp, 32
	sub rsp, 8
	movsd [rsp], xmm0
.jump2883:
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const81] ; 312
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2954
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2954:
	; Computing bound for 'n'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2955
	mov rax, [rel const508] ; 507
	push rax
	jmp .jump2956
.jump2955:
	mov rax, [rel const613] ; 277
	push rax
	pop rax
	neg rax
	push rax
.jump2956:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2957
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump2957:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2958
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2958:
	; Computing bound for 'o'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2959
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	jmp .jump2960
.jump2959:
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
.jump2960:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2961
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump2962
.jump2961:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2963
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2963:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2964
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2964:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2965
	sub rsp, 16
	; Moving 16 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2967
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2967:
	cmp rax, [rsp + 8]
	jl .jump2968
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2968:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump2966
.jump2965:
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
.jump2966:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2969
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2969:
	; Computing bound for 'n'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2970
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2970:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2971
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2971:
	; Computing bound for 'o'
	mov rax, [rel const662] ; 197
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2972
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2972:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2973
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2973:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump2974
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2974:
	imul rdi, [rsp + 0 + 8] ; multiply by 197 
	jno .jump2975
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2975:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump2976
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2976:
	imul rdi, [rsp + 0 + 24] ; multiply by k 
	jno .jump2977
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2977:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2978: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2978 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2978 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2978 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2978 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const663] ; 919
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const664] ; 434
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2979
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2979:
	cmp rax, [rsp + 32]
	jl .jump2980
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2980:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2981
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2981:
	cmp rax, [rsp + 40]
	jl .jump2982
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2982:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2983
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2983:
	cmp rax, [rsp + 48]
	jl .jump2984
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2984:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2985
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2985:
	cmp rax, [rsp + 56]
	jl .jump2986
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2986:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2987
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2987:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2988: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'q'
	add qword [rsp + 24], 1
	; Compare q to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2988 ; If q < bound, next iter
	mov qword [rsp + 24], 0 ; q = 0
	add qword [rsp + 16], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2988 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2988 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2988 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
.jump2962:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2989
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2989:
	; Computing bound for 'n'
	mov rax, [rel const110] ; 194
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2990
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2990:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 194 
	jno .jump2991
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2991:
imul rdi, [rsp + 0 + 8] ; multiply by (if (! (if true then (! a) else (h < h))) then h else (sum[n : (array[n : f, o : 197, p : h, q : k] f)[h, 434, k, 919], o : (if (a == a) then e[k] else h), p : k, q : ((- f) * (- f))] n)) 
	jno .jump2992
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2992:
	imul rdi, [rsp + 0 + 16] ; multiply by ((if true then 507 else (- 277)) % h) 
	jno .jump2993
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2993:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump2994: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2995
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2995:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2996
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2996:
	; Computing bound for 'q'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2997
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2997:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2998
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2998:
	; Computing bound for 'r'
	mov rax, [rel const665] ; 338
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2999
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2999:
	; Computing bound for 'q'
	mov rax, [rel const666] ; 519
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3000
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3000:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 519 
	jno .jump3001
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3001:
	imul rdi, [rsp + 0 + 8] ; multiply by 338 
	jno .jump3002
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3002:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump3003
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3003:
	imul rdi, [rsp + 0 + 24] ; multiply by o 
	jno .jump3004
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3004:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump3005: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 't'
	add qword [rsp + 24], 1
	; Compare t to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3005 ; If t < bound, next iter
	mov qword [rsp + 24], 0 ; t = 0
	add qword [rsp + 16], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3005 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3005 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3005 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3006
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3006:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3007
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3007:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump3008
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3008:
	imul rdi, [rsp + 0 + 8] ; multiply by k 
	jno .jump3009
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3009:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump3010: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 8], 1
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3010 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3010 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const667] ; 92
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3011
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3011:
	cqo
	idiv r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3012
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3012:
	cmp rax, [rsp + 16]
	jl .jump3013
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3013:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3014
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3014:
	cmp rax, [rsp + 24]
	jl .jump3015
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3015:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3016
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3016:
	cmp rax, [rsp + 32]
	jl .jump3017
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3017:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3018
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3018:
	cmp rax, [rsp + 40]
	jl .jump3019
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3019:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3020
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3020:
	cmp rax, [rsp + 48]
	jl .jump3021
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3021:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3022
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3022:
	cmp rax, [rsp + 56]
	jl .jump3023
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3023:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3024
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3024:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (array[q : 519, r : 338, s : h, t : o] o)[k, n, (array[q : o, r : k] n)[(h / 92), f], k] 
	jno .jump3025
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3025:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump3026
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3026:
	imul rdi, [rsp + 0 + 16] ; multiply by p 
	jno .jump3027
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3027:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump3028: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 's'
	add qword [rsp + 16], 1
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3028 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3028 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3028 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2994 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2994 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2994 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const668] ; 954
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3029
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3029:
	cqo
	idiv r10
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3030
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3030:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3031
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3031:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump3032: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3033
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3033:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3034
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3034:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by k 
	jno .jump3035
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3035:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump3036
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3036:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump3037: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const669] ; 41
	push rax
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 8], 1
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3037 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3037 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3038
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3038:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3039
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3039:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3040
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3040:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump3041: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3041 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3041 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3041 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3042
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3042:
	cmp rax, [rsp + 16]
	jl .jump3043
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3043:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3044
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3044:
	cmp rax, [rsp + 24]
	jl .jump3045
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3045:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3032 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3032 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3046
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3046:
	cmp rax, [rsp + 24]
	jl .jump3047
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3047:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3048
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3048:
	cmp rax, [rsp + 32]
	jl .jump3049
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3049:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3050
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3050:
	cmp rax, [rsp + 40]
	jl .jump3051
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3051:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const670] ; 747
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3052
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3052:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3053
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3053:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump3054
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3054:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump3055
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3055:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump3056: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3057
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3057:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3058
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3058:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3059
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3059:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump3060
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3060:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump3061
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3061:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump3062
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3062:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump3063: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3063 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3063 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3063 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const644] ; 49
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3064
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3064:
	cmp rax, [rsp + 24]
	jl .jump3065
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3065:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3066
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3066:
	cmp rax, [rsp + 32]
	jl .jump3067
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3067:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3068
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3068:
	cmp rax, [rsp + 40]
	jl .jump3069
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3069:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3056 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3056 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3070
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3070:
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3071
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3071:
	; Computing bound for 'n'
	mov rax, [rel const116] ; 586
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3072
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3072:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump3073: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const212] ; 428
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3073 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3073 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3074
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3074:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3075
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3075:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump3076: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3076 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3076 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3076 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump3077
	mov rax, [rel const26] ; False
	push rax
	pop rax
.jump3077:
	push rax
	pop rax
	cmp rax, 0
	je .jump3078
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump3079
.jump3078:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
.jump3079:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3080
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3080:
	cmp rax, [rsp + 16]
	jl .jump3081
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3081:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3082
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3082:
	cmp rax, [rsp + 24]
	jl .jump3083
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3083:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3084
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3084:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump3085: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 0], 1
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3085 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3086
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3088
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump3088:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	jmp .jump3087
.jump3086:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3089
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3089:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3090
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3090:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3091
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3091:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump3092
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3092:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump3093
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3093:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump3094
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3094:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump3095: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 16], 1
	; Compare p to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3095 ; If p < bound, next iter
	mov qword [rsp + 16], 0 ; p = 0
	add qword [rsp + 8], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3095 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3095 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3096
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3096:
	cmp rax, [rsp + 24]
	jl .jump3097
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3097:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3098
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3098:
	cmp rax, [rsp + 32]
	jl .jump3099
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3099:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3100
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3100:
	cmp rax, [rsp + 40]
	jl .jump3101
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3101:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
.jump3087:
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3102
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump3102:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3103
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3103:
	cmp rax, [rsp + 24]
	jl .jump3104
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3104:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3105
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3105:
	cmp rax, [rsp + 32]
	jl .jump3106
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3106:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3107
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3107:
	cmp rax, [rsp + 40]
	jl .jump3108
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3108:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3109
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3109:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (array[n : 194, o : (if (! (if true then (! a) else (h < h))) then h else (sum[n : (array[n : f, o : 197, p : h, q : k] f)[h, 434, k, 919], o : (if (a == a) then e[k] else h), p : k, q : ((- f) * (- f))] n)), p : ((if true then 507 else (- 277)) % h)] (array[q : (array[q : 519, r : 338, s : h, t : o] o)[k, n, (array[q : o, r : k] n)[(h / 92), f], k], r : h, s : p] p))[((sum[n : k, o : h] (array[p : k, q : o] (- 41))[f, (- (sum[p : k, q : n, r : n] o))]) * (k / h)), f, 954][(- f), (((if true then (f % h) else (h - (array[n : f, o : h, p : k] f)[(- h), h, (k - k)])) * (- k)) / (sum[n : (array[n : f, o : f] (array[p : n, q : n, r : k] o)[h, f, (- 49)])[(if (false || false) then f else (- (- f))), (sum[n : (- k), o : (sum[n : 586, o : f] 428), p : f] n)]] f)), 747] 
	jno .jump3110
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3110:
	imul rdi, [rsp + 0 + 8] ; multiply by 312 
	jno .jump3111
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3111:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump3112: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3112 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3112 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump3113
	lea rdi, [rel const671] ; 'q'
	call _fail_assertion
.jump3113:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const549] ; 291
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3114
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3116
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump3116:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3117
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3117:
	; Computing bound for 's'
	mov rax, [rel const672] ; 18.83
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3118
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump3119
.jump3118:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump3119:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3120
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3120:
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3121
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3121:
	; Computing bound for 'q'
	mov rax, [rel const673] ; 834
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3122
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3122:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
.jump3123: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3124
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3124:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3125
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3125:
	; Computing bound for 'u'
	mov rax, [rel const548] ; 793
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3126
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3126:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3127: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3128
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3128:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3129
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3129:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3130
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3130:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump3131
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3131:
	imul rdi, [rsp + 0 + 8] ; multiply by v 
	jno .jump3132
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3132:
	imul rdi, [rsp + 0 + 16] ; multiply by k 
	jno .jump3133
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3133:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
.jump3134: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'z'
	add qword [rsp + 16], 1
	; Compare z to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3134 ; If z < bound, next iter
	mov qword [rsp + 16], 0 ; z = 0
	add qword [rsp + 8], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3134 ; If y < bound, next iter
	mov qword [rsp + 8], 0 ; y = 0
	add qword [rsp + 0], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3134 ; If x < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3135
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3135:
	cmp rax, [rsp + 24]
	jl .jump3136
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3136:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3137
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3137:
	cmp rax, [rsp + 32]
	jl .jump3138
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3138:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3139
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3139:
	cmp rax, [rsp + 40]
	jl .jump3140
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3140:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'w'
	add qword [rsp + 16], 1
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3127 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3127 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3127 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3141
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump3141:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 't'
	add qword [rsp + 24], 1
	; Compare t to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3123 ; If t < bound, next iter
	mov qword [rsp + 24], 0 ; t = 0
	add qword [rsp + 16], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3123 ; If s < bound, next iter
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3123 ; If r < bound, next iter
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3123 ; If q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	pop r10
	sub rax, r10
	push rax
	jmp .jump3115
.jump3114:
	mov rax, [rel const414] ; 801
	push rax
.jump3115:
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump3142
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const674] ; 'r'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3142:
	sub rsp, 32
	sub rsp, 8 ; Add alignment
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3143
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3145
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3145:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump3146
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3146:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump3147: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3148
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3148:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3149
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3149:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3150
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3150:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump3151
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3151:
	imul rdi, [rsp + 0 + 8] ; multiply by (- q) 
	jno .jump3152
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3152:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump3153
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3153:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump3154: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 16], 1
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3154 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3154 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3154 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3155
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	jmp .jump3156
.jump3155:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump3156:
	mov rax, [rel const209] ; 286
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3157
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3157:
	cmp rax, [rsp + 24]
	jl .jump3158
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3158:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3159
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3159:
	cmp rax, [rsp + 32]
	jl .jump3160
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3160:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3161
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3161:
	cmp rax, [rsp + 40]
	jl .jump3162
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3162:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 0], 1
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3147 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump3144
.jump3143:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3163
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3163:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by p 
	jno .jump3164
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3164:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
.jump3165: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const609] ; 3.82
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 0], 1
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3165 ; If r < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump3144:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rsi
	lea rdi, [rsp + 24]
	call _b
	add rsp, 16
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 40 ; Local variables
	pop rbp
	ret

j:
_j:
	push rbp
	mov rbp, rsp
	push rdi
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 16
	; Moving 16 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3166
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3166:
	cmp rax, [rsp + 8]
	jl .jump3167
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3167:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3168
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3170
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3170:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3171
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3171:
	; Computing bound for 's'
	mov rax, [rel const56] ; 408
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3172
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3172:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 408 
	jno .jump3173
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3173:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump3174
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3174:
	imul rdi, [rsp + 0 + 16] ; multiply by o 
	jno .jump3175
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3175:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump3176: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3177
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3179
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3179:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3180
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3180:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump3181
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3181:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump3182
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3182:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump3183: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 8], 1
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3183 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3183 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const675] ; 2
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3184
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3184:
	cmp rax, [rsp + 16]
	jl .jump3185
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3185:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3186
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3186:
	cmp rax, [rsp + 24]
	jl .jump3187
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3187:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	jmp .jump3178
.jump3177:
	sub rsp, 16
	; Moving 16 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3188
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3188:
	cmp rax, [rsp + 8]
	jl .jump3189
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3189:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump3178:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 16], 1
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3176 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3176 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3176 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump3169
.jump3168:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'v'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3190
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3190:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3191
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3191:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3192
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3192:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- f) 
	jno .jump3193
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3193:
	imul rdi, [rsp + 0 + 8] ; multiply by (- (- f)) 
	jno .jump3194
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3194:
	imul rdi, [rsp + 0 + 16] ; multiply by l 
	jno .jump3195
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3195:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump3196: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 16], 1
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3196 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3196 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3196 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const676] ; 113
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	mov rax, [rel const104] ; 103
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3197
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3197:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3198
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3198:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3199
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3199:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3200
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3200:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump3201: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3202
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3202:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3203
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3203:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3204
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3204:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3205
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3205:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump3206: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'y'
	add qword [rsp + 24], 1
	; Compare y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3206 ; If y < bound, next iter
	mov qword [rsp + 24], 0 ; y = 0
	add qword [rsp + 16], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3206 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3206 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3206 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'u'
	add qword [rsp + 16], 1
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3201 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3201 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3201 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3207
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump3207:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3208
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3208:
	cmp rax, [rsp + 24]
	jl .jump3209
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3209:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3210
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3210:
	cmp rax, [rsp + 32]
	jl .jump3211
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3211:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3212
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3212:
	cmp rax, [rsp + 40]
	jl .jump3213
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3213:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3214
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3214:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3215
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3215:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3216
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3216:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3217
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3217:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump3218: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3219
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	jmp .jump3220
.jump3219:
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3221
	mov rax, [rel const11] ; True
	push rax
	jmp .jump3222
.jump3221:
	mov rax, [rel const26] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
.jump3222:
	pop rax
	cmp rax, 0
	je .jump3223
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump3224
.jump3223:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
.jump3224:
.jump3220:
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'v'
	add qword [rsp + 24], 1
	; Compare v to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3218 ; If v < bound, next iter
	mov qword [rsp + 24], 0 ; v = 0
	add qword [rsp + 16], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3218 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3218 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3218 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3225
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3225:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3226
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3226:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3227
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3227:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (- (- m)) 
	jno .jump3228
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3228:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump3229
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3229:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[s : r, t : o, u : f, v : (array[s : (- f), t : (- (- f)), u : l] m)[(l % (sum[s : (f / o), t : l, u : 103] (sum[v : r, w : t, x : f, y : h] h))), ((- f) * h), 113]] (if (m >= (- u)) then t else (if (if false then true else (! false)) then f else f))) 
	jno .jump3230
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3230:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump3231: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3232
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3232:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3233
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3233:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3234
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3234:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3235
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3235:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump3236: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'y'
	add qword [rsp + 24], 1
	; Compare y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3236 ; If y < bound, next iter
	mov qword [rsp + 24], 0 ; y = 0
	add qword [rsp + 16], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3236 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3236 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3236 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3237
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3237:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3238
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3238:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3239
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3239:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by u 
	jno .jump3240
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3240:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump3241
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3241:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[v : o, w : t, x : l, y : r] s) 
	jno .jump3242
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3242:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump3243: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3244
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3244:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3245
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3245:
	; Computing bound for 'y'
	mov rax, [rel const677] ; 732
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3246
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3246:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 732 
	jno .jump3247
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3247:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump3248
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3248:
	imul rdi, [rsp + 0 + 16] ; multiply by o 
	jno .jump3249
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3249:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3250: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'A'
	add qword [rsp + 16], 1
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3250 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3250 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3250 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'x'
	add qword [rsp + 16], 1
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3243 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3243 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3243 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3251
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3251:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3252
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3252:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3253
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3253:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3254
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3254:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump3255: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'y'
	add qword [rsp + 24], 1
	; Compare y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3255 ; If y < bound, next iter
	mov qword [rsp + 24], 0 ; y = 0
	add qword [rsp + 16], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3255 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3255 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3255 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3256
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3256:
	cmp rax, [rsp + 24]
	jl .jump3257
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3257:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3258
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3258:
	cmp rax, [rsp + 32]
	jl .jump3259
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3259:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3260
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3260:
	cmp rax, [rsp + 40]
	jl .jump3261
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3261:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3262
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3262:
	cmp rax, [rsp + 24]
	jl .jump3263
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3263:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3264
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3264:
	cmp rax, [rsp + 32]
	jl .jump3265
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3265:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3266
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3266:
	cmp rax, [rsp + 40]
	jl .jump3267
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3267:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 16], 1
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3231 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3231 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3231 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump3169:
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3268
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3268:
	cmp rax, [rsp + 24]
	jl .jump3269
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3269:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3270
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3270:
	cmp rax, [rsp + 32]
	jl .jump3271
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3271:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3272
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3272:
	cmp rax, [rsp + 40]
	jl .jump3273
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3273:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump3274
	lea rdi, [rel const678] ; 's'
	call _fail_assertion
.jump3274:
	mov rax, [rel const26] ; False
	push rax
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3275
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3275:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3276
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3276:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- m) 
	jno .jump3277
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3277:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump3278
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3278:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump3279: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3280
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3280:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3281
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3281:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump3282
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3282:
	imul rdi, [rsp + 0 + 8] ; multiply by t 
	jno .jump3283
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3283:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3284: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3285
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump3286
.jump3285:
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump3286:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3287
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3287:
	cmp rax, [rsp + 16]
	jl .jump3288
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3288:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3289
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3289:
	cmp rax, [rsp + 24]
	jl .jump3290
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3290:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3284 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3284 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 't'
	add qword [rsp + 8], 1
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3279 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3279 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const679] ; 43.37
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3291
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump3292
.jump3291:
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump3292:
	mov rax, [rel const293] ; 479
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3293
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3293:
	cmp rax, [rsp + 16]
	jl .jump3294
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3294:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3295
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3295:
	cmp rax, [rsp + 24]
	jl .jump3296
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3296:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _d
	add rsp, 8
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3297
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3299
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3299:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3300
	mov rax, [rel const680] ; 646
	push rax
	jmp .jump3301
.jump3300:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump3301:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3302
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3302:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (if a then 646 else r) 
	jno .jump3303
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3303:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump3304
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3304:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump3305: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3306
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3307
	mov rax, [rel const11] ; True
	push rax
	jmp .jump3308
.jump3307:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump3308:
	pop rax
.jump3306:
	push rax
	pop rax
	cmp rax, 0
	je .jump3309
	mov rax, [rel const11] ; True
	push rax
	pop rax
.jump3309:
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 't'
	add qword [rsp + 8], 1
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3305 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3305 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3310
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3310:
	cmp rax, [rsp + 16]
	jl .jump3311
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3311:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3312
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3312:
	cmp rax, [rsp + 24]
	jl .jump3313
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3313:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3298
.jump3297:
	mov rax, [rel const11] ; True
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3314
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3314:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3315
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3315:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump3316
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3316:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump3317
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3317:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump3318: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 't'
	add qword [rsp + 8], 1
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3318 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3318 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3319
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3319:
	cmp rax, [rsp + 16]
	jl .jump3320
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3320:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3321
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3321:
	cmp rax, [rsp + 24]
	jl .jump3322
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3322:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _d
	add rsp, 8
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3323
	mov rax, [rel const26] ; False
	push rax
	jmp .jump3324
.jump3323:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
.jump3324:
	pop rax
	cmp rax, 0
	je .jump3325
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	mov rax, [rel const681] ; 70
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3327
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3327:
	; Computing bound for 's'
	mov rax, [rel const375] ; 554
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3328
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3328:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (r - 554) 
	jno .jump3329
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3329:
	imul rdi, [rsp + 0 + 8] ; multiply by 70 
	jno .jump3330
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3330:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump3331: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	mov rax, [rel const682] ; 314
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3332
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3332:
	; Computing bound for 'u'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3333
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3333:
	; Computing bound for 'v'
	mov rax, [rel const683] ; 367
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3334
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3334:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3335
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3335:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3336: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'w'
	add qword [rsp + 16], 1
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3336 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3336 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3336 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3337
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3337:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[u : o, v : 367, w : r] u) 
	jno .jump3338
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3338:
	imul rdi, [rsp + 0 + 8] ; multiply by 314 
	jno .jump3339
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3339:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3340: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3340 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3340 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3341
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3341:
	cqo
	idiv r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3342
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3342:
	cmp rax, [rsp + 16]
	jl .jump3343
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3343:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3344
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3344:
	cmp rax, [rsp + 24]
	jl .jump3345
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3345:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 't'
	add qword [rsp + 8], 1
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3331 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3331 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump3326
.jump3325:
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3346
	sub rsp, 16
	; Moving 16 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump3347
.jump3346:
	sub rsp, 16
	; Moving 16 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
.jump3347:
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3348
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3348:
	cmp rax, [rsp + 8]
	jl .jump3349
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3349:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3350
	mov rax, [rel const11] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3352
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	jmp .jump3353
.jump3352:
	mov rax, [rel const26] ; False
	push rax
.jump3353:
	pop rax
	cmp rax, 0
	je .jump3354
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3356
	mov rax, [rel const11] ; True
	push rax
	pop rax
.jump3356:
	push rax
	pop rax
	cmp rax, 0
	je .jump3357
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3359
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3359:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3360
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3360:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump3361
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3361:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump3362
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3362:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump3363: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 't'
	add qword [rsp + 8], 1
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3363 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3363 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump3358
.jump3357:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3364
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3364:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3365
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3365:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump3366
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3366:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump3367
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3367:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump3368: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 't'
	add qword [rsp + 8], 1
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3368 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3368 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump3358:
	jmp .jump3355
.jump3354:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3369
	mov rax, [rel const26] ; False
	push rax
	jmp .jump3370
.jump3369:
	mov rax, [rel const26] ; False
	push rax
.jump3370:
	pop rax
	cmp rax, 0
	je .jump3371
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3373
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3373:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3374
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3374:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump3375
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3375:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump3376
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3376:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump3377: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 't'
	add qword [rsp + 8], 1
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3377 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3377 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump3372
.jump3371:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3378
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3378:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3379
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3379:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump3380
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3380:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump3381
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3381:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump3382: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 't'
	add qword [rsp + 8], 1
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3382 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3382 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump3372:
.jump3355:
	jmp .jump3351
.jump3350:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3383
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3383:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3384
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3384:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3385
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3385:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump3386: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'u'
	add qword [rsp + 16], 1
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3386 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3386 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3386 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3387
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3387:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3388
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3388:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump3389
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3389:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[s : h, t : o, u : f] s) 
	jno .jump3390
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3390:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump3391: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 't'
	add qword [rsp + 8], 1
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3391 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3391 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump3351:
.jump3326:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3392
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3392:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3393
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3393:
	; Computing bound for 't'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 't'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3394
	mov rax, [rel const366] ; 810
	push rax
	jmp .jump3395
.jump3394:
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
.jump3395:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3396
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3396:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3397
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3397:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- r) 
	jno .jump3398
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3398:
	imul rdi, [rsp + 0 + 8] ; multiply by (if false then 810 else h) 
	jno .jump3399
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3399:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump3400: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 't'
	add qword [rsp + 8], 1
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3400 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3400 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3401
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3401:
	cmp rax, [rsp + 16]
	jl .jump3402
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3402:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3403
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3403:
	cmp rax, [rsp + 24]
	jl .jump3404
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3404:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3405
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3405:
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3406
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3406:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump3407
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3407:
imul rdi, [rsp + 0 + 8] ; multiply by (array[s : (- r), t : (if false then 810 else h)] f)[l, l] 
	jno .jump3408
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3408:
	imul rdi, [rsp + 0 + 16] ; multiply by l 
	jno .jump3409
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3409:
	imul rdi, [rsp + 0 + 24] ; multiply by l 
	jno .jump3410
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3410:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump3411: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const684] ; 33.52
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3412
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3414
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3414:
	cmp rax, [rsp + 8]
	jl .jump3415
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3415:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3416
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3416:
	cmp rax, [rsp + 16]
	jl .jump3417
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3417:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3418
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3418:
	cmp rax, [rsp + 24]
	jl .jump3419
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3419:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3413
.jump3412:
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3420
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3420:
	cmp rax, [rsp + 16]
	jl .jump3421
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3421:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3422
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3422:
	cmp rax, [rsp + 24]
	jl .jump3423
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3423:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump3413:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 24], 1
	; Compare v to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3411 ; If v < bound, next iter
	mov qword [rsp + 24], 0 ; v = 0
	add qword [rsp + 16], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3411 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3411 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3411 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	mov rax, [rel const252] ; 729
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3424
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3424:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3425
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3425:
	; Computing bound for 's'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3426
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3426:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump3427: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 's'
	add qword [rsp + 0], 1
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3427 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3428
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3428:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump3429: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'u'
	add qword [rsp + 16], 1
	; Compare u to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3429 ; If u < bound, next iter
	mov qword [rsp + 16], 0 ; u = 0
	add qword [rsp + 8], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3429 ; If t < bound, next iter
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3429 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const501] ; 746
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3430
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3430:
	cmp rax, [rsp + 32]
	jl .jump3431
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3431:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3432
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3432:
	cmp rax, [rsp + 40]
	jl .jump3433
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3433:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3434
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3434:
	cmp rax, [rsp + 48]
	jl .jump3435
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3435:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3436
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3436:
	cmp rax, [rsp + 56]
	jl .jump3437
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3437:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _d
	add rsp, 8
	add rsp, 24
	push rax
.jump3298:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump3438
	lea rdi, [rel const678] ; 's'
	call _fail_assertion
.jump3438:
	sub rsp, 16
	; Moving 16 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3439
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3439:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3440
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3440:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3441
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3441:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump3442
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3442:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump3443
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3443:
	imul rdi, [rsp + 0 + 16] ; multiply by (r + (- m)) 
	jno .jump3444
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3444:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3445: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 16], 1
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3445 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3445 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3445 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'w'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3446
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3446:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3447
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3447:
	; Computing bound for 'u'
	mov rax, [rel const211] ; 737
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3448
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3448:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 737 
	jno .jump3449
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3449:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump3450
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3450:
	imul rdi, [rsp + 0 + 16] ; multiply by f 
	jno .jump3451
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3451:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3452: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 16], 1
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3452 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3452 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3452 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const468] ; 326
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3453
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3453:
	cmp rax, [rsp + 24]
	jl .jump3454
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3454:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3455
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3455:
	cmp rax, [rsp + 32]
	jl .jump3456
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3456:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3457
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3457:
	cmp rax, [rsp + 40]
	jl .jump3458
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3458:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3459
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3459:
	; Computing bound for 'v'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3460
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3460:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3461
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3461:
	; Computing bound for 'u'
	mov rax, [rel const138] ; 607
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3462
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3462:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3463: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'w'
	add qword [rsp + 16], 1
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3463 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3463 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3463 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3464
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3464:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3465
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3465:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3466: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3467
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3467:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'w'
	add qword [rsp + 16], 1
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3466 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3466 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3466 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const441] ; 265
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3468
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	jmp .jump3469
.jump3468:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump3469:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3470
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3470:
	cmp rax, [rsp + 24]
	jl .jump3471
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3471:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3472
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3472:
	cmp rax, [rsp + 32]
	jl .jump3473
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3473:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3474
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3474:
	cmp rax, [rsp + 40]
	jl .jump3475
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3475:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3476
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3476:
	; Computing bound for 'u'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3477
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3477:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3478: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'u'
	add qword [rsp + 0], 1
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3478 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3479
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3479:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[u : m] r) 
	jno .jump3480
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3480:
imul rdi, [rsp + 0 + 8] ; multiply by (array[u : r, v : m, w : (r + (- m))] l)[(if (m < 265) then o else r), (sum[u : h, v : (sum[u : 607, v : r, w : h] u), w : (array[u : 737, v : h, w : f] u)[326, (- t), t]] (h % h)), (- h)] 
	jno .jump3481
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3481:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3482: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3483
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'x'
	mov rax, [rel const26] ; 0
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3485
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3485:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3486
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3486:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump3487: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'x'
	add qword [rsp + 8], 1
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3487 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3487 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	jmp .jump3484
.jump3483:
	mov rax, [rel const26] ; False
	push rax
.jump3484:
	pop rax
	cmp rax, 0
	je .jump3488
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump3489
.jump3488:
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump3489:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3482 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3482 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3490
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3490:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3491
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3491:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3492: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3492 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3492 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3493
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3493:
	; Computing bound for 'w'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3494
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3494:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3495
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3495:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3496
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3496:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3497: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'w'
	add qword [rsp + 16], 1
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3497 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3497 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3497 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3498
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3498:
	; Computing bound for 'v'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3499
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3499:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3500
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3500:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3501: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3501 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3501 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3502
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3502:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3503
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3503:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by (- f) 
	jno .jump3504
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3504:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[u : h, v : m] f) 
	jno .jump3505
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3505:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[u : m, v : l, w : f] w) 
	jno .jump3506
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3506:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[u : o, v : m] r) 
	jno .jump3507
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3507:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3508: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const685] ; 75.79
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'x'
	add qword [rsp + 24], 1
	; Compare x to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3508 ; If x < bound, next iter
	mov qword [rsp + 24], 0 ; x = 0
	add qword [rsp + 16], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3508 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3508 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3508 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3509
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3509:
	; Computing bound for 'w'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3510
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3510:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3511: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'u'
	add qword [rsp + 0], 1
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3511 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3512
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3512:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3513
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3513:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3514
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3514:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3515: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'x'
	add qword [rsp + 24], 1
	; Compare x to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3515 ; If x < bound, next iter
	mov qword [rsp + 24], 0 ; x = 0
	add qword [rsp + 16], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3515 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3515 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3515 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const31] ; 891
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3516
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3516:
	cmp rax, [rsp + 32]
	jl .jump3517
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3517:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3518
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3518:
	cmp rax, [rsp + 40]
	jl .jump3519
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3519:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3520
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3520:
	cmp rax, [rsp + 48]
	jl .jump3521
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3521:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3522
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3522:
	cmp rax, [rsp + 56]
	jl .jump3523
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3523:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3524
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3524:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3525
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3525:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3526
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3526:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3527: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'w'
	add qword [rsp + 16], 1
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3527 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3527 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3527 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3528
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3530
	mov rax, [rel const26] ; False
	push rax
	pop rax
.jump3530:
	push rax
	pop rax
	cmp rax, 0
	je .jump3531
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump3532
.jump3531:
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
.jump3532:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3533
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3533:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3534
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3534:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3535
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3535:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by (o % m) 
	jno .jump3536
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3536:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (false && false) then h else o) 
	jno .jump3537
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3537:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3538: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3539
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3539:
	cmp rax, [rsp + 16]
	jl .jump3540
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3540:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3541
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3541:
	cmp rax, [rsp + 24]
	jl .jump3542
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3542:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3538 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3538 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3543
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump3544
.jump3543:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3545
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3545:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3546
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3546:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3547
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3547:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump3548
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3548:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump3549
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3549:
	imul rdi, [rsp + 0 + 16] ; multiply by l 
	jno .jump3550
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3550:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3551: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 16], 1
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3551 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3551 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3551 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3552
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3552:
	cmp rax, [rsp + 24]
	jl .jump3553
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3553:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3554
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3554:
	cmp rax, [rsp + 32]
	jl .jump3555
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3555:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3556
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3556:
	cmp rax, [rsp + 40]
	jl .jump3557
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3557:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump3544:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3558
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3558:
	cmp rax, [rsp + 16]
	jl .jump3559
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3559:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3560
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3560:
	cmp rax, [rsp + 24]
	jl .jump3561
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3561:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3529
.jump3528:
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3562
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3564
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3564:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3565
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3565:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3566: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'u'
	add qword [rsp + 0], 1
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3566 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3567
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3567:
	cmp rax, [rsp + 16]
	jl .jump3568
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3568:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3569
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3569:
	cmp rax, [rsp + 24]
	jl .jump3570
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3570:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3563
.jump3562:
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rdi, 96
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 96 bytes from rsp to rax 
		mov r10, [rsp + 88]
		mov [rax + 88], r10
		mov r10, [rsp + 80]
		mov [rax + 80], r10
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 96
	push rax
	mov rax, 4
	push rax
	mov rax, [rel const686] ; 803
	push rax
	mov rax, [rel const457] ; 633
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3571
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3571:
	cmp rax, [rsp + 8]
	jl .jump3572
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3572:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3573
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	jmp .jump3574
.jump3573:
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3575
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump3576
.jump3575:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
.jump3576:
.jump3574:
	mov rax, [rel const361] ; 317
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3577
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3577:
	cmp rax, [rsp + 16]
	jl .jump3578
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3578:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3579
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3579:
	cmp rax, [rsp + 24]
	jl .jump3580
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3580:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump3563:
.jump3529:
	call _d
	add rsp, 8
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump3581
	mov rax, [rel const11] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3583
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3585
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3585:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump3586
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3586:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3587: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 0], 1
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3587 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump3584
.jump3583:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3588
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3588:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump3589
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3589:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3590: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	mov rax, [rel const687] ; 91.43
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const688] ; 46.2
	push rax
	mov rax, [rel const689] ; 73.33
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3591
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3591:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by t 
	jno .jump3592
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3592:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump3593: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3594
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3594:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3595
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3595:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3596
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3596:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump3597
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3597:
	imul rdi, [rsp + 0 + 8] ; multiply by (v - h) 
	jno .jump3598
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3598:
	imul rdi, [rsp + 0 + 16] ; multiply by f 
	jno .jump3599
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3599:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump3600: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'y'
	add qword [rsp + 16], 1
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3600 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3600 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3600 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'v'
	add qword [rsp + 0], 1
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3593 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	call _i
	add rsp, 16
	add rsp, 32
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 0], 1
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3590 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump3584:
	jmp .jump3582
.jump3581:
	sub rsp, 16
	; Moving 16 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3601
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3601:
	cmp rax, [rsp + 8]
	jl .jump3602
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3602:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump3603
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump3603:
	push rax
	pop rax
	cmp rax, 0
	je .jump3604
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump3606
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
.jump3606:
	push rax
	jmp .jump3605
.jump3604:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3607
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3608
	mov rax, [rel const26] ; False
	push rax
	jmp .jump3609
.jump3608:
	mov rax, [rel const11] ; True
	push rax
.jump3609:
	pop rax
.jump3607:
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
.jump3605:
	pop rax
	cmp rax, 0
	je .jump3610
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3612
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3614
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3616
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3616:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3617
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3617:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3618
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3618:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump3619
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3619:
	imul rdi, [rsp + 0 + 8] ; multiply by t 
	jno .jump3620
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3620:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump3621
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3621:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3622: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 16], 1
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3622 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3622 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3622 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3623
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3623:
	cmp rax, [rsp + 24]
	jl .jump3624
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3624:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3625
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3625:
	cmp rax, [rsp + 32]
	jl .jump3626
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3626:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3627
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3627:
	cmp rax, [rsp + 40]
	jl .jump3628
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3628:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3629
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3631
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3631:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3632: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'u'
	add qword [rsp + 0], 1
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3632 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	jmp .jump3630
.jump3629:
	mov rax, [rel const690] ; 71.4
	push rax
	mov rax, [rel const691] ; 64.55
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3633
	mov rax, [rel const692] ; 79.24
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	jmp .jump3634
.jump3633:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3635
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3635:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump3636
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3636:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3637: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const693] ; 94.5
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 0], 1
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3637 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump3634:
.jump3630:
	jmp .jump3615
.jump3614:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3638
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3638:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3639
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3639:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump3640
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3640:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump3641
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3641:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3642: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3642 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3642 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3643
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3643:
	cmp rax, [rsp + 16]
	jl .jump3644
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3644:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3645
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3645:
	cmp rax, [rsp + 24]
	jl .jump3646
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3646:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _d
	add rsp, 8
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump3647
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3649
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3649:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump3650
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3650:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3651: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 0], 1
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3651 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump3648
.jump3647:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
.jump3648:
.jump3615:
	jmp .jump3613
.jump3612:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
.jump3613:
	jmp .jump3611
.jump3610:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3652
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3653
	mov rax, [rel const11] ; True
	push rax
	pop rax
.jump3653:
	push rax
	pop rax
.jump3652:
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump3654
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
.jump3654:
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3655
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const694] ; 141
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	jmp .jump3656
.jump3655:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump3657
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump3658
	mov rax, [rel const695] ; 52.5
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
.jump3658:
	push rax
	pop rax
.jump3657:
	push rax
.jump3656:
	pop rax
	cmp rax, 0
	je .jump3659
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3661
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3661:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by (- l) 
	jno .jump3662
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3662:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3663: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 0], 1
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3663 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump3660
.jump3659:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3664
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3664:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump3665
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3665:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3666: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3667
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3667:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump3668
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3668:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump3669: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const696] ; 35.04
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 0], 1
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3669 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3670
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3670:
	cmp rax, [rsp + 8]
	jl .jump3671
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3671:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 0], 1
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3666 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump3660:
.jump3611:
.jump3582:
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	pop rsi
	lea rdi, [rsp + 16]
	call _b
	add rsp, 16
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 80 ; Local variables
	pop rbp
	ret
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3672
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3672:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3673
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3673:
	; Computing bound for 'v'
	mov rax, [rel const697] ; 572
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3674
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3674:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3675
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3675:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump3676
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3676:
	imul rdi, [rsp + 0 + 8] ; multiply by (t - 572) 
	jno .jump3677
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3677:
	imul rdi, [rsp + 0 + 16] ; multiply by t 
	jno .jump3678
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3678:
	imul rdi, [rsp + 0 + 24] ; multiply by l 
	jno .jump3679
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3679:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3680: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3681
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3683
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3683:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3684
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3684:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump3685
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3685:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump3686
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3686:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3687: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'z'
	add qword [rsp + 8], 1
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3687 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3687 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump3682
.jump3681:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3688
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3688:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3689
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3689:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump3690
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3690:
	imul rdi, [rsp + 0 + 8] ; multiply by x 
	jno .jump3691
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3691:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3692: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'z'
	add qword [rsp + 8], 1
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3692 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3692 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump3682:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 24
	add rax, [rsp + 88]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'x'
	add qword [rsp + 24], 1
	; Compare x to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3680 ; If x < bound, next iter
	mov qword [rsp + 24], 0 ; x = 0
	add qword [rsp + 16], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3680 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3680 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3680 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3693
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump3694
.jump3693:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump3694:
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3695
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump3695:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rel const698] ; 639
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3696
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3696:
	cmp rax, [rsp + 32]
	jl .jump3697
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3697:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3698
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3698:
	cmp rax, [rsp + 40]
	jl .jump3699
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3699:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3700
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3700:
	cmp rax, [rsp + 48]
	jl .jump3701
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3701:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3702
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3702:
	cmp rax, [rsp + 56]
	jl .jump3703
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3703:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3704
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3704:
	cmp rax, [rsp + 16]
	jl .jump3705
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3705:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3706
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3706:
	cmp rax, [rsp + 24]
	jl .jump3707
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3707:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3708
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3708:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3709
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3709:
	; Computing bound for 'v'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3710
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3710:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3711
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3711:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump3712
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3712:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump3713
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3713:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3714: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3715
	mov rax, [rel const26] ; False
	push rax
	pop rax
.jump3715:
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3714 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3714 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3716
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3716:
	cmp rax, [rsp + 16]
	jl .jump3717
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3717:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3718
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3718:
	cmp rax, [rsp + 24]
	jl .jump3719
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3719:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3720
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3722
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3724
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3726
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3726:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3727
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3727:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump3728
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3728:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump3729
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3729:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3730: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3730 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3730 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump3725
.jump3724:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3731
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3731:
	; Computing bound for 'u'
	mov rax, [rel const429] ; 110
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3732
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3732:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 110 
	jno .jump3733
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3733:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump3734
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3734:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3735: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3735 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3735 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump3725:
	jmp .jump3723
.jump3722:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3736
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3736:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3737
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3737:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump3738
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3738:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump3739
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3739:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3740: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3740 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3740 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump3723:
	jmp .jump3721
.jump3720:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3741
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3741:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3742
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3742:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump3743
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3743:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump3744
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3744:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3745: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3745 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3745 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump3721:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3746
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3746:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3747
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3747:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3748
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3748:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3749
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3749:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump3750
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3750:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump3751
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3751:
	imul rdi, [rsp + 0 + 16] ; multiply by r 
	jno .jump3752
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3752:
	imul rdi, [rsp + 0 + 24] ; multiply by o 
	jno .jump3753
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3753:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3754: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const26] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'x'
	add qword [rsp + 24], 1
	; Compare x to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3754 ; If x < bound, next iter
	mov qword [rsp + 24], 0 ; x = 0
	add qword [rsp + 16], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3754 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3754 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3754 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3755
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3755:
	cmp rax, [rsp + 32]
	jl .jump3756
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3756:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3757
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3757:
	cmp rax, [rsp + 40]
	jl .jump3758
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3758:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3759
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3759:
	cmp rax, [rsp + 48]
	jl .jump3760
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3760:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3761
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3761:
	cmp rax, [rsp + 56]
	jl .jump3762
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3762:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3763
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	jmp .jump3764
.jump3763:
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
.jump3764:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3765
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3765:
	cmp rax, [rsp + 16]
	jl .jump3766
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3766:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3767
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump3767:
	cmp rax, [rsp + 24]
	jl .jump3768
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump3768:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3769
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3769:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3770
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3770:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by t 
	jno .jump3771
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3771:
imul rdi, [rsp + 0 + 8] ; multiply by (if (array[u : h, v : r] (true && false))[l, m] then (if a then (if (t == h) then (array[u : h, v : l] f) else (array[u : 110, v : o] f)) else (array[u : m, v : l] f)) else (array[u : o, v : r] u))[(if (! (array[u : o, v : r, w : r, x : o] false)[t, h, t, r]) then o else h), r] 
	jno .jump3772
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3772:
	imul rdi, [rsp + 0 + 16] ; multiply by r 
	jno .jump3773
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3773:
imul rdi, [rsp + 0 + 24] ; multiply by (array[u : r, v : (t - 572), w : t, x : l] (if (c > p) then (array[y : v, z : r] h) else (array[y : o, z : x] v)))[(- 639), (l % m), (if (m <= o) then r else r), m][f, r] 
	jno .jump3774
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3774:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3775: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rsi
	lea rdi, [rsp + 24]
	call _b
	add rsp, 16
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3776
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3776:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3777
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3777:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3778
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3778:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- r) 
	jno .jump3779
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3779:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump3780
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3780:
	imul rdi, [rsp + 0 + 16] ; multiply by t 
	jno .jump3781
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3781:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
.jump3782: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'A'
	add qword [rsp + 16], 1
	; Compare A to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3782 ; If A < bound, next iter
	mov qword [rsp + 16], 0 ; A = 0
	add qword [rsp + 8], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3782 ; If z < bound, next iter
	mov qword [rsp + 8], 0 ; z = 0
	add qword [rsp + 0], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3782 ; If y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const699] ; 182
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3783
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3783:
	cmp rax, [rsp + 24]
	jl .jump3784
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3784:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3785
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3785:
	cmp rax, [rsp + 32]
	jl .jump3786
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3786:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3787
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3787:
	cmp rax, [rsp + 40]
	jl .jump3788
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3788:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3789
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3789:
	cmp rax, [rsp + 8]
	jl .jump3790
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3790:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'x'
	add qword [rsp + 24], 1
	; Compare x to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3775 ; If x < bound, next iter
	mov qword [rsp + 24], 0 ; x = 0
	add qword [rsp + 16], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3775 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3775 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3775 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const116] ; 586
	push rax
	sub rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3791
	mov rax, [rel const700] ; 60.2
	push rax
	jmp .jump3792
.jump3791:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
.jump3792:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rsi
	lea rdi, [rsp + 16]
	call _b
	add rsp, 16
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3793
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3793:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3794
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3794:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3795
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3795:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump3796
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3796:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump3797
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3797:
	imul rdi, [rsp + 0 + 16] ; multiply by (m - h) 
	jno .jump3798
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3798:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3799: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 16], 1
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3799 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3799 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3799 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3800
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3800:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3801
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3801:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3802
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3802:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (m + m) 
	jno .jump3803
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3803:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump3804
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3804:
	imul rdi, [rsp + 0 + 16] ; multiply by (- f) 
	jno .jump3805
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3805:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3806: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 16], 1
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3806 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3806 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3806 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3807
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3809
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3809:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3810
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3810:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3811
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3811:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump3812
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3812:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump3813
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3813:
	imul rdi, [rsp + 0 + 16] ; multiply by o 
	jno .jump3814
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3814:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3815: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const26] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 16], 1
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3815 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3815 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3815 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump3808
.jump3807:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3816
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3816:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3817
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3817:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3818
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3818:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump3819
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3819:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump3820
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3820:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump3821
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3821:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3822: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'w'
	add qword [rsp + 16], 1
	; Compare w to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3822 ; If w < bound, next iter
	mov qword [rsp + 16], 0 ; w = 0
	add qword [rsp + 8], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3822 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3822 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump3808:
	mov rdi, 96
	call _jpl_alloc
	; Moving 96 bytes from rsp to rax 
		mov r10, [rsp + 88]
		mov [rax + 88], r10
		mov r10, [rsp + 80]
		mov [rax + 80], r10
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 96
	push rax
	mov rax, 3
	push rax
	call _i
	add rsp, 16
	add rsp, 32
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3823
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3823:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3824: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3825
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump3826
.jump3825:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3827
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3827:
	; Computing bound for 'x'
	mov rax, [rel const275] ; 295
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3828
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3828:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3829
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3829:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3830
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3830:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
.jump3831: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'y'
	add qword [rsp + 24], 1
	; Compare y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3831 ; If y < bound, next iter
	mov qword [rsp + 24], 0 ; y = 0
	add qword [rsp + 16], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3831 ; If x < bound, next iter
	mov qword [rsp + 16], 0 ; x = 0
	add qword [rsp + 8], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3831 ; If w < bound, next iter
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3831 ; If v < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump3826:
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'u'
	add qword [rsp + 0], 1
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3824 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3832
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump3833
.jump3832:
	sub rsp, 16
	; Moving 16 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3834
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3834:
	cmp rax, [rsp + 8]
	jl .jump3835
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3835:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump3833:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3836
	mov rax, [rel const701] ; 133
	push rax
	jmp .jump3837
.jump3836:
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
.jump3837:
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3838
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3838:
	cmp rax, [rsp + 32]
	jl .jump3839
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3839:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3840
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3840:
	cmp rax, [rsp + 40]
	jl .jump3841
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3841:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3842
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3842:
	cmp rax, [rsp + 48]
	jl .jump3843
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3843:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump3844
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3844:
	cmp rax, [rsp + 56]
	jl .jump3845
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3845:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump3846
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	mov rax, [rel const449] ; 610
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3847
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3847:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3848
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3848:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump3849
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3849:
	imul rdi, [rsp + 0 + 8] ; multiply by 610 
	jno .jump3850
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3850:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3851: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3851 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3851 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3852
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3852:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3853: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'u'
	add qword [rsp + 0], 1
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3853 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const614] ; 463
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3854
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3854:
	cmp rax, [rsp + 16]
	jl .jump3855
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3855:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3856
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3856:
	cmp rax, [rsp + 24]
	jl .jump3857
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3857:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const702] ; 98.03
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3858
	sub rsp, 16
	; Moving 16 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	jmp .jump3859
.jump3858:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3860
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump3862
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump3863
.jump3862:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3864
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump3865
.jump3864:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump3865:
.jump3863:
	jmp .jump3861
.jump3860:
	mov rax, [rel const703] ; 23.87
	push rax
.jump3861:
	mov rax, [rel const704] ; 36.45
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3866
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3866:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3867
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3867:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump3868
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3868:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump3869
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3869:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3870: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3870 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3870 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const423] ; 117
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3871
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3871:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'v'
	mov rax, [rel const343] ; 206
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3872
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3872:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3873
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3873:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump3874: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3874 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3874 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3875
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3875:
	cmp rax, [rsp + 16]
	jl .jump3876
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3876:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3877
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3877:
	cmp rax, [rsp + 24]
	jl .jump3878
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3878:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3879
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3881
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump3882
.jump3881:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump3882:
	pop rax
	cmp rax, 0
	je .jump3883
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	jmp .jump3884
.jump3883:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump3884:
	pop rax
	xor rax, 1
	push rax
	jmp .jump3880
.jump3879:
	mov rax, [rel const705] ; 59.68
	push rax
	mov rax, [rel const706] ; 41.45
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
.jump3880:
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
.jump3859:
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3885
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3885:
	cmp rax, [rsp + 8]
	jl .jump3886
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3886:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
.jump3846:
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3887
	mov rax, [rel const26] ; False
	push rax
	jmp .jump3888
.jump3887:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump3888:
	pop rax
	cmp rax, 0
	je .jump3889
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3891
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	jmp .jump3892
.jump3891:
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
.jump3892:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3893
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3893:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3894
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3894:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3895
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3895:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump3896: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'y'
	add qword [rsp + 16], 1
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3896 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3896 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3896 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3897
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3897:
	; Computing bound for 'x'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3898
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3898:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3899
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3899:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump3900: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'w'
	add qword [rsp + 0], 1
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3900 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3901
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3901:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3902
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3902:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump3903
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3903:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[w : (o % h)] (r - m)) 
	jno .jump3904
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3904:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[w : m, x : f, y : (if u then m else h)] t) 
	jno .jump3905
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3905:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump3906: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump3907
	mov rax, [rel const26] ; False
	push rax
	pop rax
.jump3907:
	push rax
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'y'
	add qword [rsp + 16], 1
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3906 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3906 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3906 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3908
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3908:
	cmp rax, [rsp + 24]
	jl .jump3909
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3909:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump3910
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3910:
	cmp rax, [rsp + 32]
	jl .jump3911
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3911:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump3912
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3912:
	cmp rax, [rsp + 40]
	jl .jump3913
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3913:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump3890
.jump3889:
	sub rsp, 16
	; Moving 16 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3914
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump3914:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3915
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3915:
	cmp rax, [rsp + 8]
	jl .jump3916
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3916:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump3890:
	pop rax
	cmp rax, 0
	je .jump3917
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3919
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3919:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3920
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3920:
	; Computing bound for 'w'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3921
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3921:
	; Computing bound for 'y'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3922
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3922:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3923
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3923:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3924
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3924:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3925
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3925:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump3926: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const370] ; 335
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'z'
	add qword [rsp + 24], 1
	; Compare z to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3926 ; If z < bound, next iter
	mov qword [rsp + 24], 0 ; z = 0
	add qword [rsp + 16], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3926 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3926 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3926 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3927
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3927:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump3928
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump3928:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3929
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3929:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3930
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3930:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump3931: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3932
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	jmp .jump3933
.jump3932:
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
.jump3933:
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'z'
	add qword [rsp + 24], 1
	; Compare z to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3931 ; If z < bound, next iter
	mov qword [rsp + 24], 0 ; z = 0
	add qword [rsp + 16], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3931 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3931 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3931 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3934
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3934:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba[,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[w : v, x : (l % h), y : (sum[w : t, x : v, y : m, z : o] 335), z : l] (if true then m else h)) 
	jno .jump3935
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3935:
	imul rdi, [rsp + 0 + 8] ; multiply by (f * r) 
	jno .jump3936
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3936:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump3937
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3937:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump3938: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3939
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3940
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump3941
.jump3940:
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
.jump3941:
	pop rax
.jump3939:
	push rax
	pop rax
	cmp rax, 0
	je .jump3942
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	jmp .jump3943
.jump3942:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump3943:
	pop rax
	cmp rax, 0
	je .jump3944
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3946
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3946:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3947
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3947:
	; Computing bound for 'z'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3948
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3948:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump3949: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3950
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3950:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3951
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3951:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3952: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3952 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3952 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'z'
	add qword [rsp + 0], 1
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3949 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3953
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3953:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[z : x] (sum[A : h, B : h] w)) 
	jno .jump3954
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3954:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump3955
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3955:
	imul rdi, [rsp + 0 + 16] ; multiply by w 
	jno .jump3956
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3956:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump3957: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3958
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3958:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump3959
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3959:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump3960: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'C'
	add qword [rsp + 0], 1
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump3960 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rsi
	lea rdi, [rsp + 16]
	call _b
	add rsp, 16
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3957 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3957 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3957 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump3945
.jump3944:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3961
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3961:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3962
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3962:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3963
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3963:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump3964
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3964:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump3965
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3965:
	imul rdi, [rsp + 0 + 16] ; multiply by v 
	jno .jump3966
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3966:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump3967: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const707] ; 69.74
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3967 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3967 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3967 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump3945:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'y'
	add qword [rsp + 16], 1
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3938 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3938 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3938 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump3918
.jump3917:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3968
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3968:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3969
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3969:
	; Computing bound for 'w'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3970
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3970:
	; Computing bound for 'y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump3971
	mov rax, [rel const160] ; 389
	push rax
	jmp .jump3972
.jump3971:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
.jump3972:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3973
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3973:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3974
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3974:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3975
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3975:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'z' to 0
	mov rax, 0
	push rax
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump3976: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3977
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3977:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3978
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3978:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump3979: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3979 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3979 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'z'
	add qword [rsp + 24], 1
	; Compare z to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump3976 ; If z < bound, next iter
	mov qword [rsp + 24], 0 ; z = 0
	add qword [rsp + 16], 1 ; y++
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump3976 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump3976 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump3976 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3980
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3980:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba[,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[w : f, x : h, y : (if a then 389 else t), z : f] (sum[A : h, B : x] w)) 
	jno .jump3981
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3981:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump3982
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3982:
	imul rdi, [rsp + 0 + 16] ; multiply by f 
	jno .jump3983
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3983:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump3984: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3985
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3985:
	; Computing bound for 'A'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3986
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3986:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3987
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3987:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump3988: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'A'
	add qword [rsp + 8], 1
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump3988 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump3988 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3989
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3989:
	; Computing bound for 'z'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3990
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3990:
	; Computing bound for 'B'
	sub rsp, 16
	; Moving 16 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3991
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3991:
	cmp rax, [rsp + 8]
	jl .jump3992
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3992:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3993
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3993:
	; Computing bound for 'A'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3994
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3994:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3995
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3995:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3996
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3996:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3997
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump3997:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump3998
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3998:
	imul rdi, [rsp + 0 + 8] ; multiply by y 
	jno .jump3999
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump3999:
	imul rdi, [rsp + 0 + 16] ; multiply by o 
	jno .jump4000
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4000:
	imul rdi, [rsp + 0 + 24] ; multiply by t 
	jno .jump4001
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4001:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump4002: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'C'
	add qword [rsp + 24], 1
	; Compare C to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4002 ; If C < bound, next iter
	mov qword [rsp + 24], 0 ; C = 0
	add qword [rsp + 16], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4002 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4002 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4002 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4003
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4003:
	cmp rax, [rsp + 32]
	jl .jump4004
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4004:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4005
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4005:
	cmp rax, [rsp + 40]
	jl .jump4006
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4006:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4007
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4007:
	cmp rax, [rsp + 48]
	jl .jump4008
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4008:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4009
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4009:
	cmp rax, [rsp + 56]
	jl .jump4010
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4010:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4011
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4011:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4012
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4012:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump4013: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'C'
	add qword [rsp + 24], 1
	; Compare C to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4013 ; If C < bound, next iter
	mov qword [rsp + 24], 0 ; C = 0
	add qword [rsp + 16], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4013 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4013 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4013 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4014
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4014:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[z : y, A : (array[z : l, A : y, B : o, C : t] h)[o, f, o, x], B : s[x], C : y] (C + B)) 
	jno .jump4015
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4015:
imul rdi, [rsp + 0 + 8] ; multiply by (- (sum[z : y, A : (- m)] h)) 
	jno .jump4016
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4016:
	imul rdi, [rsp + 0 + 16] ; multiply by t 
	jno .jump4017
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4017:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump4018: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4019
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump4020
.jump4019:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
.jump4020:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const708] ; 31.97
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4018 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4018 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4018 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'y'
	add qword [rsp + 16], 1
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump3984 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump3984 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump3984 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump3918:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'x'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4021
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	jmp .jump4022
.jump4021:
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
.jump4022:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4023
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4023:
	; Computing bound for 'w'
	mov rax, [rel const331] ; 808
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4024
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4024:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump4025: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'x'
	add qword [rsp + 8], 1
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4025 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4025 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'y'
	mov rax, [rel const709] ; 448
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4026
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump4028
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4029
	mov rax, [rel const11] ; True
	push rax
	jmp .jump4030
.jump4029:
	mov rax, [rel const11] ; True
	push rax
.jump4030:
	pop rax
.jump4028:
	push rax
	jmp .jump4027
.jump4026:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4031
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4031:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4032
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4032:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump4033
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4033:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump4034
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4034:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump4035: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'x'
	add qword [rsp + 8], 1
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4035 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4035 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4036
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump4036:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4037
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4037:
	cmp rax, [rsp + 16]
	jl .jump4038
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4038:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4039
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4039:
	cmp rax, [rsp + 24]
	jl .jump4040
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4040:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4027:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4041
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump4042
.jump4041:
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
.jump4042:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4043
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4043:
	; Computing bound for 'x'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4044
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4044:
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4045
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4045:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'y' to 0
	mov rax, 0
	push rax
	; Initialize 'x' to 0
	mov rax, 0
	push rax
	; Initialize 'w' to 0
	mov rax, 0
	push rax
.jump4046: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'y'
	add qword [rsp + 16], 1
	; Compare y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4046 ; If y < bound, next iter
	mov qword [rsp + 16], 0 ; y = 0
	add qword [rsp + 8], 1 ; x++
	; Compare x to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4046 ; If x < bound, next iter
	mov qword [rsp + 8], 0 ; x = 0
	add qword [rsp + 0], 1 ; w++
	; Compare w to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4046 ; If w < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4047
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4047:
	cmp rax, [rsp + 24]
	jl .jump4048
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4048:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4049
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4049:
	cmp rax, [rsp + 32]
	jl .jump4050
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4050:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4051
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4051:
	cmp rax, [rsp + 40]
	jl .jump4052
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4052:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4053
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4053:
	cmp rax, [rsp + 24]
	jl .jump4054
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4054:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4055
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4055:
	cmp rax, [rsp + 32]
	jl .jump4056
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4056:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4057
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4057:
	cmp rax, [rsp + 40]
	jl .jump4058
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4058:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 128 ; Local variables
	pop rbp
	ret

E:
_E:
	push rbp
	mov rbp, rsp
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5238
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5240
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	jmp .jump5241
.jump5240:
	mov rax, [rel const11] ; True
	push rax
.jump5241:
	pop rax
	cmp rax, 0
	je .jump5242
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5244
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5246
	mov rax, [rel const790] ; 56.03
	push rax
	jmp .jump5247
.jump5246:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
.jump5247:
	jmp .jump5245
.jump5244:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5248
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5248:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5249
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5249:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5250
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5250:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5251
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5251:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump5252: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'V'
	add qword [rsp + 24], 1
	; Compare V to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5252 ; If V < bound, next iter
	mov qword [rsp + 24], 0 ; V = 0
	add qword [rsp + 16], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5252 ; If U < bound, next iter
	mov qword [rsp + 16], 0 ; U = 0
	add qword [rsp + 8], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5252 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5252 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const791] ; 59.4
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump5245:
	mov rax, [rel const792] ; 65.15
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5253
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5253:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5254
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5254:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump5255: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5256
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5256:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5257
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5257:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump5258
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5258:
	imul rdi, [rsp + 0 + 8] ; multiply by x 
	jno .jump5259
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5259:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
.jump5260: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'V'
	add qword [rsp + 8], 1
	; Compare V to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5260 ; If V < bound, next iter
	mov qword [rsp + 8], 0 ; V = 0
	add qword [rsp + 0], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5260 ; If U < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5261
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5263
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5263:
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5264
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5264:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5265
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5265:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5266
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5266:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump5267
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5267:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump5268
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5268:
	imul rdi, [rsp + 0 + 16] ; multiply by C 
	jno .jump5269
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5269:
	imul rdi, [rsp + 0 + 24] ; multiply by q 
	jno .jump5270
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5270:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'X' to 0
	mov rax, 0
	push rax
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
.jump5271: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'X'
	add qword [rsp + 24], 1
	; Compare X to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5271 ; If X < bound, next iter
	mov qword [rsp + 24], 0 ; X = 0
	add qword [rsp + 16], 1 ; W++
	; Compare W to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5271 ; If W < bound, next iter
	mov qword [rsp + 16], 0 ; W = 0
	add qword [rsp + 8], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5271 ; If V < bound, next iter
	mov qword [rsp + 8], 0 ; V = 0
	add qword [rsp + 0], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5271 ; If U < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump5262
.jump5261:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5272
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump5273
.jump5272:
	sub rsp, 40
	; Moving 40 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump5273:
.jump5262:
	call _E
	add rsp, 40
	add rsp, 24
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'T'
	add qword [rsp + 8], 1
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5255 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5255 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8 ; Add alignment
	sub rsp, 24
	; Moving 24 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	sub rsp, 40
	; Moving 40 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	call _E
	add rsp, 40
	add rsp, 24
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const793] ; 21.2
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5274
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5274:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5275
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5275:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump5276
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5276:
	imul rdi, [rsp + 0 + 8] ; multiply by R 
	jno .jump5277
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5277:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump5278: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'T'
	add qword [rsp + 8], 1
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5278 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5278 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 40
	; Moving 40 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	call _E
	add rsp, 40
	add rsp, 24
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5279
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5279:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump5280
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5280:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump5281: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5282
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5284
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5284:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5285
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5285:
	; Computing bound for 'T'
	mov rax, [rel const357] ; 570
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5286
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5286:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 570 
	jno .jump5287
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5287:
	imul rdi, [rsp + 0 + 8] ; multiply by C 
	jno .jump5288
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5288:
	imul rdi, [rsp + 0 + 16] ; multiply by S 
	jno .jump5289
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5289:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump5290: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const26] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'V'
	add qword [rsp + 16], 1
	; Compare V to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5290 ; If V < bound, next iter
	mov qword [rsp + 16], 0 ; V = 0
	add qword [rsp + 8], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5290 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5290 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump5283
.jump5282:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5291
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5291:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5292
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5292:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5293
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5293:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by I 
	jno .jump5294
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5294:
	imul rdi, [rsp + 0 + 8] ; multiply by Q 
	jno .jump5295
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5295:
	imul rdi, [rsp + 0 + 16] ; multiply by S 
	jno .jump5296
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5296:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump5297: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'V'
	add qword [rsp + 16], 1
	; Compare V to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5297 ; If V < bound, next iter
	mov qword [rsp + 16], 0 ; V = 0
	add qword [rsp + 8], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5297 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5297 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump5283:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'S'
	add qword [rsp + 0], 1
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5281 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	call _i
	add rsp, 16
	add rsp, 32
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'V'
	mov rax, [rel const794] ; 562
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5298
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5298:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5299
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5299:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5300
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5300:
	; Computing bound for 'S'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5301
	mov rax, [rel const64] ; 167
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5303
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump5303:
	cqo
	idiv r10
	push rax
	jmp .jump5302
.jump5301:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'T'
	mov rax, [rel const388] ; 121
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5304
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5304:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5305
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5305:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump5306: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'T'
	add qword [rsp + 8], 1
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5306 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5306 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump5302:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5307
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5307:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump5308: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5309
	mov rax, [rel const795] ; 15.32
	push rax
	mov rax, [rel const796] ; 9.84
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump5310
.jump5309:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
.jump5310:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'V'
	add qword [rsp + 24], 1
	; Compare V to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5308 ; If V < bound, next iter
	mov qword [rsp + 24], 0 ; V = 0
	add qword [rsp + 16], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5308 ; If U < bound, next iter
	mov qword [rsp + 16], 0 ; U = 0
	add qword [rsp + 8], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5308 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5308 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	jmp .jump5243
.jump5242:
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5311
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5313
	sub rsp, 24
	; Moving 24 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	jmp .jump5314
.jump5313:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5315
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5315:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - -64 to rsp 
		mov r10, [rbp - -64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5316
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5316:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by M 
	jno .jump5317
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5317:
	imul rdi, [rsp + 0 + 8] ; multiply by I 
	jno .jump5318
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5318:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump5319: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'T'
	add qword [rsp + 8], 1
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5319 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5319 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump5314:
	sub rsp, 40
	; Moving 40 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	call _E
	add rsp, 40
	add rsp, 24
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump5312
.jump5311:
	sub rsp, 8 ; Add alignment
	sub rsp, 24
	; Moving 24 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _E
	add rsp, 40
	add rsp, 24
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
.jump5312:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const797] ; 81.89
	push rax
	mov rax, [rel const798] ; 97.31
	push rax
.jump5243:
	jmp .jump5239
.jump5238:
	sub rsp, 32
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5320
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5320:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump5321
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5321:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump5322: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5323
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5323:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5324
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5324:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5325
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5325:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump5326: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _E
	add rsp, 40
	add rsp, 24
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'V'
	add qword [rsp + 16], 1
	; Compare V to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5326 ; If V < bound, next iter
	mov qword [rsp + 16], 0 ; V = 0
	add qword [rsp + 8], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5326 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5326 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'S'
	add qword [rsp + 0], 1
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5322 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rsi
	lea rdi, [rsp + 24]
	call _b
	add rsp, 16
	add rsp, 8 ; Remove alignment
.jump5239:
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 40 ; Local variables
	pop rbp
	ret
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const799] ; 76.36
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const800] ; 32.12
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5327
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	jmp .jump5328
.jump5327:
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
.jump5328:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5329
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5329:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump5330: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5331
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5331:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5332
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5332:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5333
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5333:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by O 
	jno .jump5334
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5334:
	imul rdi, [rsp + 0 + 8] ; multiply by R 
	jno .jump5335
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5335:
	imul rdi, [rsp + 0 + 16] ; multiply by S 
	jno .jump5336
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5336:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
.jump5337: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'W'
	add qword [rsp + 16], 1
	; Compare W to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5337 ; If W < bound, next iter
	mov qword [rsp + 16], 0 ; W = 0
	add qword [rsp + 8], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5337 ; If V < bound, next iter
	mov qword [rsp + 8], 0 ; V = 0
	add qword [rsp + 0], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5337 ; If U < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5338
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5338:
	cmp rax, [rsp + 24]
	jl .jump5339
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5339:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5340
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5340:
	cmp rax, [rsp + 32]
	jl .jump5341
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5341:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5342
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5342:
	cmp rax, [rsp + 40]
	jl .jump5343
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5343:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5344
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5344:
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5345
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5345:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5346
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5346:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5347
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5347:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump5348
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5348:
	imul rdi, [rsp + 0 + 8] ; multiply by T 
	jno .jump5349
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5349:
	imul rdi, [rsp + 0 + 16] ; multiply by r 
	jno .jump5350
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5350:
	imul rdi, [rsp + 0 + 24] ; multiply by L 
	jno .jump5351
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5351:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'X' to 0
	mov rax, 0
	push rax
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
.jump5352: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'X'
	add qword [rsp + 24], 1
	; Compare X to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5352 ; If X < bound, next iter
	mov qword [rsp + 24], 0 ; X = 0
	add qword [rsp + 16], 1 ; W++
	; Compare W to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5352 ; If W < bound, next iter
	mov qword [rsp + 16], 0 ; W = 0
	add qword [rsp + 8], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5352 ; If V < bound, next iter
	mov qword [rsp + 8], 0 ; V = 0
	add qword [rsp + 0], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5352 ; If U < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	call _E
	add rsp, 40
	add rsp, 24
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'T'
	add qword [rsp + 0], 1
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5330 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - -64 to rsp 
		mov r10, [rbp - -64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5353
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5353:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - -64 to rsp 
		mov r10, [rbp - -64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5354
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5354:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by M 
	jno .jump5355
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5355:
	imul rdi, [rsp + 0 + 8] ; multiply by (- M) 
	jno .jump5356
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5356:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump5357: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'U'
	add qword [rsp + 8], 1
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5357 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5357 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 40
	; Moving 40 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	call _E
	add rsp, 40
	add rsp, 24
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump5358
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
.jump5358:
	push rax
	pop rax
	cmp rax, 0
	jne .jump5359
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5360
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	jmp .jump5361
.jump5360:
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
.jump5361:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5362
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5362:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (if (! (a == a)) then D else y) 
	jno .jump5363
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5363:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump5364: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump5365
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5366
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	jmp .jump5367
.jump5366:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump5367:
	pop rax
.jump5365:
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'T'
	add qword [rsp + 0], 1
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5364 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5368
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5368:
	cmp rax, [rsp + 8]
	jl .jump5369
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5369:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
.jump5359:
	push rax
	pop rax
	cmp rax, 0
	je .jump5370
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5372
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5374
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5376
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump5377
.jump5376:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump5377:
	pop rax
	cmp rax, 0
	je .jump5378
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5380
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5380:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5381
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5381:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5382
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5382:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[] 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump5383
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5383:
	imul rdi, [rsp + 0 + 8] ; multiply by D 
	jno .jump5384
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5384:
	imul rdi, [rsp + 0 + 16] ; multiply by r 
	jno .jump5385
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5385:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump5386: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'V'
	add qword [rsp + 16], 1
	; Compare V to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5386 ; If V < bound, next iter
	mov qword [rsp + 16], 0 ; V = 0
	add qword [rsp + 8], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5386 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5386 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5387
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5387:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5388
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5388:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump5389: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'U'
	add qword [rsp + 8], 1
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5389 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5389 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5390
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5390:
	cmp rax, [rsp + 24]
	jl .jump5391
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5391:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5392
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5392:
	cmp rax, [rsp + 32]
	jl .jump5393
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5393:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5394
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5394:
	cmp rax, [rsp + 40]
	jl .jump5395
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5395:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5379
.jump5378:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5396
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5396:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (- x) 
	jno .jump5397
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5397:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump5398: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'T'
	add qword [rsp + 0], 1
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5398 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump5379:
	jmp .jump5375
.jump5374:
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump5399
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
.jump5399:
	push rax
	pop rax
	cmp rax, 0
	je .jump5400
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5402
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5402:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump5403
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5403:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump5404: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'T'
	add qword [rsp + 0], 1
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5404 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump5401
.jump5400:
	sub rsp, 16
	; Moving 16 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
.jump5401:
.jump5375:
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5405
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5405:
	cmp rax, [rsp + 8]
	jl .jump5406
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5406:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5407
	sub rsp, 40
	; Moving 40 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump5408
.jump5407:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5409
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5411
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump5412
.jump5411:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump5412:
	pop rax
	cmp rax, 0
	je .jump5413
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5415
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump5416
.jump5415:
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5417
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5419
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5419:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5420
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5420:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - -64 to rsp 
		mov r10, [rbp - -64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5421
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5421:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5422
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5422:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump5423
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5423:
	imul rdi, [rsp + 0 + 8] ; multiply by M 
	jno .jump5424
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5424:
	imul rdi, [rsp + 0 + 16] ; multiply by R 
	jno .jump5425
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5425:
	imul rdi, [rsp + 0 + 24] ; multiply by P 
	jno .jump5426
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5426:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump5427: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'W'
	add qword [rsp + 24], 1
	; Compare W to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5427 ; If W < bound, next iter
	mov qword [rsp + 24], 0 ; W = 0
	add qword [rsp + 16], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5427 ; If V < bound, next iter
	mov qword [rsp + 16], 0 ; V = 0
	add qword [rsp + 8], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5427 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5427 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump5418
.jump5417:
	sub rsp, 40
	; Moving 40 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump5418:
.jump5416:
	jmp .jump5414
.jump5413:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from rbp - -64 to rsp 
		mov r10, [rbp - -64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5428
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5428:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5429
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5429:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5430
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5430:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5431
	sub rsp, 24
	; Moving 24 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	jmp .jump5432
.jump5431:
	sub rsp, 24
	; Moving 24 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
.jump5432:
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5433
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5433:
	cmp rax, [rsp + 16]
	jl .jump5434
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5434:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5435
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5435:
	cmp rax, [rsp + 24]
	jl .jump5436
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5436:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5437
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5437:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (if z then K else K)[o, q] 
	jno .jump5438
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5438:
	imul rdi, [rsp + 0 + 8] ; multiply by x 
	jno .jump5439
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5439:
	imul rdi, [rsp + 0 + 16] ; multiply by H 
	jno .jump5440
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5440:
	imul rdi, [rsp + 0 + 24] ; multiply by M 
	jno .jump5441
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5441:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump5442: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'W'
	add qword [rsp + 24], 1
	; Compare W to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5442 ; If W < bound, next iter
	mov qword [rsp + 24], 0 ; W = 0
	add qword [rsp + 16], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5442 ; If V < bound, next iter
	mov qword [rsp + 16], 0 ; V = 0
	add qword [rsp + 8], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5442 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5442 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump5414:
	jmp .jump5410
.jump5409:
	sub rsp, 40
	; Moving 40 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump5410:
.jump5408:
	jmp .jump5373
.jump5372:
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump5373:
	jmp .jump5371
.jump5370:
	sub rsp, 40
	; Moving 40 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump5371:
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump5443
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
.jump5443:
	push rax
	pop rax
	cmp rax, 0
	jne .jump5444
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const801] ; 'Y'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5444:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5445
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5447
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5447:
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5448
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5448:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5449
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5449:
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5450
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5450:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by y 
	jno .jump5451
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5451:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump5452
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5452:
	imul rdi, [rsp + 0 + 16] ; multiply by C 
	jno .jump5453
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5453:
	imul rdi, [rsp + 0 + 24] ; multiply by x 
	jno .jump5454
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5454:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
.jump5455: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const802] ; 33.43
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ab'
	add qword [rsp + 24], 1
	; Compare ab to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5455 ; If ab < bound, next iter
	mov qword [rsp + 24], 0 ; ab = 0
	add qword [rsp + 16], 1 ; aa++
	; Compare aa to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5455 ; If aa < bound, next iter
	mov qword [rsp + 16], 0 ; aa = 0
	add qword [rsp + 8], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5455 ; If Z < bound, next iter
	mov qword [rsp + 8], 0 ; Z = 0
	add qword [rsp + 0], 1 ; Y++
	; Compare Y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5455 ; If Y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5456
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5458
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5458:
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5459
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5459:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by J 
	jno .jump5460
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5460:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump5461
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5461:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
.jump5462: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Z'
	add qword [rsp + 8], 1
	; Compare Z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5462 ; If Z < bound, next iter
	mov qword [rsp + 8], 0 ; Z = 0
	add qword [rsp + 0], 1 ; Y++
	; Compare Y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5462 ; If Y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump5457
.jump5456:
	sub rsp, 24
	; Moving 24 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
.jump5457:
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5463
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5463:
	cmp rax, [rsp + 16]
	jl .jump5464
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5464:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5465
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5465:
	cmp rax, [rsp + 24]
	jl .jump5466
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5466:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5467
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5467:
	cmp rax, [rsp + 32]
	jl .jump5468
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5468:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5469
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5469:
	cmp rax, [rsp + 40]
	jl .jump5470
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5470:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5471
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5471:
	cmp rax, [rsp + 48]
	jl .jump5472
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5472:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5473
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5473:
	cmp rax, [rsp + 56]
	jl .jump5474
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5474:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5446
.jump5445:
	mov rax, [rel const803] ; 7.58
	push rax
.jump5446:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump5475
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const801] ; 'Y'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5475:
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5476
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5476:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by Q 
	jno .jump5477
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5477:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump5478: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const804] ; 90.09
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Z'
	add qword [rsp + 0], 1
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5478 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5479
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5479:
	cmp rax, [rsp + 8]
	jl .jump5480
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5480:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 96 ; Local variables
	pop rbp
	ret

H:
_H:
	push rbp
	mov rbp, rsp
	push rdi
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5484
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5486
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5486:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5487
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5487:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump5488
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5488:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump5489
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5489:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump5490: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5491
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5491:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5492
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5492:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5493
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5493:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by M 
	jno .jump5494
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5494:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump5495
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5495:
	imul rdi, [rsp + 0 + 16] ; multiply by r 
	jno .jump5496
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5496:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump5497: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump5498
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5500
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	jmp .jump5501
.jump5500:
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
.jump5501:
	jmp .jump5499
.jump5498:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5502
	mov rax, [rel const11] ; True
	push rax
	jmp .jump5503
.jump5502:
	mov rax, [rel const26] ; False
	push rax
.jump5503:
.jump5499:
	pop rax
	cmp rax, 0
	je .jump5504
	mov rax, [rel const805] ; 35.35
	push rax
	jmp .jump5505
.jump5504:
	mov rax, [rel const806] ; 40.55
	push rax
.jump5505:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Q'
	add qword [rsp + 16], 1
	; Compare Q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5497 ; If Q < bound, next iter
	mov qword [rsp + 16], 0 ; Q = 0
	add qword [rsp + 8], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5497 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5497 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'N'
	add qword [rsp + 8], 1
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5490 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5490 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5506
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5506:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5507
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5507:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5508
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	jmp .jump5509
.jump5508:
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
.jump5509:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5510
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5510:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5511
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5511:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by B 
	jno .jump5512
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5512:
	imul rdi, [rsp + 0 + 8] ; multiply by (if I then y else q) 
	jno .jump5513
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5513:
	imul rdi, [rsp + 0 + 16] ; multiply by x 
	jno .jump5514
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5514:
	imul rdi, [rsp + 0 + 24] ; multiply by D 
	jno .jump5515
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5515:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump5516: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const89] ; 269
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'P'
	add qword [rsp + 24], 1
	; Compare P to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5516 ; If P < bound, next iter
	mov qword [rsp + 24], 0 ; P = 0
	add qword [rsp + 16], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5516 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5516 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5516 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5517
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5517:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5518
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5518:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5519
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5519:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump5520
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5520:
	imul rdi, [rsp + 0 + 8] ; multiply by B 
	jno .jump5521
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5521:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump5522
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5522:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump5523: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const26] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 16], 1
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5523 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5523 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5523 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5524
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	jmp .jump5525
.jump5524:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5526
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	jmp .jump5527
.jump5526:
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
.jump5527:
.jump5525:
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5528
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5528:
	cmp rax, [rsp + 24]
	jl .jump5529
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5529:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5530
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5530:
	cmp rax, [rsp + 32]
	jl .jump5531
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5531:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5532
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5532:
	cmp rax, [rsp + 40]
	jl .jump5533
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5533:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5534
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	jmp .jump5535
.jump5534:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump5535:
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5536
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5536:
	cmp rax, [rsp + 32]
	jl .jump5537
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5537:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5538
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5538:
	cmp rax, [rsp + 40]
	jl .jump5539
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5539:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5540
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5540:
	cmp rax, [rsp + 48]
	jl .jump5541
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5541:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5542
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5542:
	cmp rax, [rsp + 56]
	jl .jump5543
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5543:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5544
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5544:
	cmp rax, [rsp + 16]
	jl .jump5545
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5545:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5546
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5546:
	cmp rax, [rsp + 24]
	jl .jump5547
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5547:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5548
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5548:
	cmp rax, [rsp + 24]
	jl .jump5549
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5549:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5550
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5550:
	cmp rax, [rsp + 32]
	jl .jump5551
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5551:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5552
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5552:
	cmp rax, [rsp + 40]
	jl .jump5553
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5553:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5485
.jump5484:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5554
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5554:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump5555: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5556
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5556:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5557
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5557:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump5558: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5559
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5559:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5560
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5560:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5561
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5561:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5562
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5562:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5563: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5564
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5564:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5565
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5565:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump5566
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5566:
	imul rdi, [rsp + 0 + 8] ; multiply by N 
	jno .jump5567
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5567:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump5568: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'U'
	add qword [rsp + 8], 1
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5568 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5568 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5569
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5569:
	cmp rax, [rsp + 16]
	jl .jump5570
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5570:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5571
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5571:
	cmp rax, [rsp + 24]
	jl .jump5572
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5572:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'S'
	add qword [rsp + 24], 1
	; Compare S to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5563 ; If S < bound, next iter
	mov qword [rsp + 24], 0 ; S = 0
	add qword [rsp + 16], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5563 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5563 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5563 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5573
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5573:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5574: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5575
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5575:
	; Computing bound for 'S'
	mov rax, [rel const750] ; 967
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5576
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5576:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5577
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5577:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5578
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5578:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump5579: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _H
	add rsp, 24
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'T'
	add qword [rsp + 24], 1
	; Compare T to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5579 ; If T < bound, next iter
	mov qword [rsp + 24], 0 ; T = 0
	add qword [rsp + 16], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5579 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5579 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5579 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'P'
	add qword [rsp + 0], 1
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5574 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5558 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5558 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'M'
	add qword [rsp + 0], 1
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5555 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump5485:
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 8 ; Local variables
	pop rbp
	ret
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5580
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5580:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5581
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5581:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5582
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5582:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5583
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5583:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump5584
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5584:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump5585
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5585:
	imul rdi, [rsp + 0 + 16] ; multiply by o 
	jno .jump5586
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5586:
	imul rdi, [rsp + 0 + 24] ; multiply by x 
	jno .jump5587
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5587:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump5588: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'P'
	add qword [rsp + 24], 1
	; Compare P to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5588 ; If P < bound, next iter
	mov qword [rsp + 24], 0 ; P = 0
	add qword [rsp + 16], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5588 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5588 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5588 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 32
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'P'
	mov rax, [rel const43] ; 324
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5589
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5589:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by 324 
	jno .jump5590
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5590:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5591: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const807] ; 19.26
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'P'
	add qword [rsp + 0], 1
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5591 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rsi
	lea rdi, [rsp + 16]
	call _b
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump5592
	lea rdi, [rel const808] ; 'Q'
	call _fail_assertion
.jump5592:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5593
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump5594
.jump5593:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5595
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5595:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5596
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5596:
	; Computing bound for 'R'
	mov rax, [rel const254] ; 664
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5597
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5597:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5598
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5598:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump5599
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5599:
	imul rdi, [rsp + 0 + 8] ; multiply by 664 
	jno .jump5600
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5600:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump5601
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5601:
	imul rdi, [rsp + 0 + 24] ; multiply by o 
	jno .jump5602
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5602:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump5603: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'T'
	add qword [rsp + 24], 1
	; Compare T to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5603 ; If T < bound, next iter
	mov qword [rsp + 24], 0 ; T = 0
	add qword [rsp + 16], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5603 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5603 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5603 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5604
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5604:
	cmp rax, [rsp + 32]
	jl .jump5605
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5605:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5606
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5606:
	cmp rax, [rsp + 40]
	jl .jump5607
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5607:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5608
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5608:
	cmp rax, [rsp + 48]
	jl .jump5609
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5609:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5610
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5610:
	cmp rax, [rsp + 56]
	jl .jump5611
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5611:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5612
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump5613
.jump5612:
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
.jump5613:
	pop rax
	cmp rax, 0
	je .jump5614
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5616
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5616:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5617
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5617:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5618
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5618:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by B 
	jno .jump5619
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5619:
	imul rdi, [rsp + 0 + 8] ; multiply by C 
	jno .jump5620
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5620:
	imul rdi, [rsp + 0 + 16] ; multiply by D 
	jno .jump5621
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5621:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump5622: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5623
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5623:
	cmp rax, [rsp + 16]
	jl .jump5624
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5624:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5625
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5625:
	cmp rax, [rsp + 24]
	jl .jump5626
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5626:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'S'
	add qword [rsp + 16], 1
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5622 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5622 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5622 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5627
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5627:
	cmp rax, [rsp + 24]
	jl .jump5628
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5628:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5629
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5629:
	cmp rax, [rsp + 32]
	jl .jump5630
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5630:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5631
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5631:
	cmp rax, [rsp + 40]
	jl .jump5632
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5632:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5615
.jump5614:
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
.jump5615:
.jump5594:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5633
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5633:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5634
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5634:
	; Computing bound for 'R'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5635
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5635:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5636
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5636:
	; Computing bound for 'R'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5637
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5637:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump5638: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'Q'
	add qword [rsp + 0], 1
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5638 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5639
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5639:
	; Computing bound for 'Q'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5640
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5640:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5641
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5641:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5642
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5642:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump5643
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5643:
	imul rdi, [rsp + 0 + 8] ; multiply by K 
	jno .jump5644
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5644:
	imul rdi, [rsp + 0 + 16] ; multiply by K 
	jno .jump5645
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5645:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump5646: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'S'
	add qword [rsp + 16], 1
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5646 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5646 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5646 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5647
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	jmp .jump5648
.jump5647:
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
.jump5648:
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5649
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump5650
.jump5649:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
.jump5650:
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5651
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5651:
	cmp rax, [rsp + 24]
	jl .jump5652
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5652:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5653
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5653:
	cmp rax, [rsp + 32]
	jl .jump5654
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5654:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5655
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5655:
	cmp rax, [rsp + 40]
	jl .jump5656
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5656:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5657
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5657:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
imul rdi, [rsp + 0 + 0] ; multiply by (array[Q : x, R : K, S : K] (- x))[(- (if t then h else f)), (if (! a) then x else n), n] 
	jno .jump5658
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5658:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[Q : q] (- Q)) 
	jno .jump5659
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5659:
	imul rdi, [rsp + 0 + 16] ; multiply by v 
	jno .jump5660
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5660:
	imul rdi, [rsp + 0 + 24] ; multiply by q 
	jno .jump5661
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5661:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump5662: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5663
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5663:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump5664
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5664:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
.jump5665: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'U'
	add qword [rsp + 0], 1
	; Compare U to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5665 ; If U < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'T'
	add qword [rsp + 24], 1
	; Compare T to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5662 ; If T < bound, next iter
	mov qword [rsp + 24], 0 ; T = 0
	add qword [rsp + 16], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5662 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5662 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5662 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const597] ; 25
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5666
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5666:
	cmp rax, [rsp + 32]
	jl .jump5667
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5667:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5668
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5668:
	cmp rax, [rsp + 40]
	jl .jump5669
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5669:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5670
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5670:
	cmp rax, [rsp + 48]
	jl .jump5671
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5671:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5672
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5672:
	cmp rax, [rsp + 56]
	jl .jump5673
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5673:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5674
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5674:
	cmp rax, [rsp + 8]
	jl .jump5675
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5675:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5676
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5676:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5677
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5677:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by O 
	jno .jump5678
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5678:
imul rdi, [rsp + 0 + 8] ; multiply by (array[Q : (array[Q : x, R : K, S : K] (- x))[(- (if t then h else f)), (if (! a) then x else n), n], R : (sum[Q : q] (- Q)), S : v, T : q] (array[U : v] r))[G, B, w, 25][m] 
	jno .jump5679
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5679:
	imul rdi, [rsp + 0 + 16] ; multiply by v 
	jno .jump5680
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5680:
imul rdi, [rsp + 0 + 24] ; multiply by (if I then f else (if (if (array[Q : s, R : 664, S : h, T : o] (! I))[D, K, o, o] then (! (! (I == I))) else t) then (array[Q : B, R : C, S : D] J[L, x])[h, (- L), o] else v)) 
	jno .jump5681
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5681:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump5682: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	mov rax, [rel const809] ; 199
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5683
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump5683:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5684
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5684:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5685
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5685:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump5686
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5686:
	imul rdi, [rsp + 0 + 8] ; multiply by (Q % 199) 
	jno .jump5687
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5687:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
.jump5688: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'V'
	add qword [rsp + 8], 1
	; Compare V to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5688 ; If V < bound, next iter
	mov qword [rsp + 8], 0 ; V = 0
	add qword [rsp + 0], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5688 ; If U < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5689
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
.jump5689:
	push rax
	pop rdi
	call _H
	add rsp, 24
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5690
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5690:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5691
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5691:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
.jump5692: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5693
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump5694
.jump5693:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5695
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5695:
	; Computing bound for 'W'
	mov rax, [rel const466] ; 219
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5696
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5696:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 219 
	jno .jump5697
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5697:
	imul rdi, [rsp + 0 + 8] ; multiply by v 
	jno .jump5698
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5698:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'X' to 0
	mov rax, 0
	push rax
	; Initialize 'W' to 0
	mov rax, 0
	push rax
.jump5699: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'X'
	add qword [rsp + 8], 1
	; Compare X to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5699 ; If X < bound, next iter
	mov qword [rsp + 8], 0 ; X = 0
	add qword [rsp + 0], 1 ; W++
	; Compare W to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5699 ; If W < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump5694:
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rdi
	call _H
	add rsp, 24
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'V'
	add qword [rsp + 8], 1
	; Compare V to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5692 ; If V < bound, next iter
	mov qword [rsp + 8], 0 ; V = 0
	add qword [rsp + 0], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5692 ; If U < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'T'
	add qword [rsp + 24], 1
	; Compare T to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5682 ; If T < bound, next iter
	mov qword [rsp + 24], 0 ; T = 0
	add qword [rsp + 16], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5682 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5682 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5682 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5700
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5702
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5704
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5704:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5705
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5705:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5706
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5706:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by O 
	jno .jump5707
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5707:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump5708
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5708:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump5709
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5709:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump5710: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'S'
	add qword [rsp + 16], 1
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5710 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5710 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5710 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 16
	; Moving 16 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5711
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5711:
	cmp rax, [rsp + 8]
	jl .jump5712
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5712:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5713
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5713:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5714
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5714:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump5715: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'R'
	add qword [rsp + 8], 1
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5715 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5715 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5716
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5716:
	cmp rax, [rsp + 24]
	jl .jump5717
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5717:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5718
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5718:
	cmp rax, [rsp + 32]
	jl .jump5719
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5719:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5720
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5720:
	cmp rax, [rsp + 40]
	jl .jump5721
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5721:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5722
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5722:
	cmp rax, [rsp + 16]
	jl .jump5723
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5723:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5724
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5724:
	cmp rax, [rsp + 24]
	jl .jump5725
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5725:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5726
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5726:
	cmp rax, [rsp + 16]
	jl .jump5727
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5727:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5728
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5728:
	cmp rax, [rsp + 24]
	jl .jump5729
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5729:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5730
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5730:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5731
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5731:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5732
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5732:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5733
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5733:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump5734
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5734:
	imul rdi, [rsp + 0 + 8] ; multiply by (- r) 
	jno .jump5735
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5735:
	imul rdi, [rsp + 0 + 16] ; multiply by y 
	jno .jump5736
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5736:
imul rdi, [rsp + 0 + 24] ; multiply by (array[Q : O, R : w, S : h] J)[K, (sum[Q : D, R : q] r), N[m]][J[B, n], m] 
	jno .jump5737
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5737:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump5738: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'T'
	add qword [rsp + 24], 1
	; Compare T to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5738 ; If T < bound, next iter
	mov qword [rsp + 24], 0 ; T = 0
	add qword [rsp + 16], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5738 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5738 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5738 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump5703
.jump5702:
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5739
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5741
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5741:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5742
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5742:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5743
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5743:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5744
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5744:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by L 
	jno .jump5745
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5745:
	imul rdi, [rsp + 0 + 8] ; multiply by (x * K) 
	jno .jump5746
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5746:
	imul rdi, [rsp + 0 + 16] ; multiply by L 
	jno .jump5747
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5747:
	imul rdi, [rsp + 0 + 24] ; multiply by D 
	jno .jump5748
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5748:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump5749: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'T'
	add qword [rsp + 24], 1
	; Compare T to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5749 ; If T < bound, next iter
	mov qword [rsp + 24], 0 ; T = 0
	add qword [rsp + 16], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5749 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5749 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5749 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump5740
.jump5739:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5750
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump5750:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5751
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5751:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5752
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5752:
	; Computing bound for 'R'
	mov rax, [rel const810] ; 887
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5753
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5753:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5754
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5754:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump5755
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5755:
	imul rdi, [rsp + 0 + 8] ; multiply by 887 
	jno .jump5756
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5756:
	imul rdi, [rsp + 0 + 16] ; multiply by O 
	jno .jump5757
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5757:
	imul rdi, [rsp + 0 + 24] ; multiply by (n % K) 
	jno .jump5758
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5758:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump5759: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'T'
	add qword [rsp + 24], 1
	; Compare T to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5759 ; If T < bound, next iter
	mov qword [rsp + 24], 0 ; T = 0
	add qword [rsp + 16], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5759 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5759 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5759 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump5740:
.jump5703:
	jmp .jump5701
.jump5700:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5760
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5760:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5761
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5761:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5762
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5762:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5763
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5763:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump5764: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'T'
	add qword [rsp + 24], 1
	; Compare T to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5764 ; If T < bound, next iter
	mov qword [rsp + 24], 0 ; T = 0
	add qword [rsp + 16], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5764 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5764 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5764 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5765
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5765:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5766
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5766:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5767
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5767:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5768
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5768:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump5769
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5769:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump5770
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5770:
	imul rdi, [rsp + 0 + 16] ; multiply by r 
	jno .jump5771
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5771:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[Q : G, R : (- w), S : n, T : D] q) 
	jno .jump5772
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5772:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump5773: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'T'
	add qword [rsp + 24], 1
	; Compare T to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5773 ; If T < bound, next iter
	mov qword [rsp + 24], 0 ; T = 0
	add qword [rsp + 16], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5773 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5773 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5773 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump5701:
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5774
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump5774:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5775
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5775:
	cmp rax, [rsp + 32]
	jl .jump5776
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5776:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5777
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5777:
	cmp rax, [rsp + 40]
	jl .jump5778
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5778:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5779
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5779:
	cmp rax, [rsp + 48]
	jl .jump5780
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5780:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5781
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5781:
	cmp rax, [rsp + 56]
	jl .jump5782
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5782:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5783
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5783:
	cmp rax, [rsp + 32]
	jl .jump5784
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5784:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5785
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5785:
	cmp rax, [rsp + 40]
	jl .jump5786
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5786:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5787
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5787:
	cmp rax, [rsp + 48]
	jl .jump5788
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5788:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5789
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5789:
	cmp rax, [rsp + 56]
	jl .jump5790
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5790:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump5791
	lea rdi, [rel const808] ; 'Q'
	call _fail_assertion
.jump5791:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 96 ; Local variables
	pop rbp
	ret
	mov rax, [rel const811] ; 82.03
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 96 ; Local variables
	pop rbp
	ret

I:
_I:
	push rbp
	mov rbp, rsp
	push rdi
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 80 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5792
	sub rsp, 32
	lea rdi, [rsp + 0]
	call _I
	jmp .jump5793
.jump5792:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5794
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5794:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5795
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5795:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5796
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5796:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by G 
	jno .jump5797
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5797:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump5798
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5798:
	imul rdi, [rsp + 0 + 16] ; multiply by o 
	jno .jump5799
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5799:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump5800: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5801
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5801:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5802
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5802:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump5803
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5803:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump5804
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5804:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5805: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Q'
	add qword [rsp + 8], 1
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5805 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5805 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 16
	; Moving 16 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5806
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5806:
	cmp rax, [rsp + 8]
	jl .jump5807
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5807:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rdi
	call _H
	add rsp, 24
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump5808
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
.jump5808:
	push rax
	pop rax
	cmp rax, 0
	je .jump5809
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5811
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5811:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5812
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5812:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by G 
	jno .jump5813
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5813:
	imul rdi, [rsp + 0 + 8] ; multiply by B 
	jno .jump5814
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5814:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5815: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Q'
	add qword [rsp + 8], 1
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5815 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5815 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 32
	lea rdi, [rsp + 0]
	call _I
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5816
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5816:
	cmp rax, [rsp + 24]
	jl .jump5817
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5817:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5818
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5818:
	cmp rax, [rsp + 32]
	jl .jump5819
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5819:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5820
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5820:
	cmp rax, [rsp + 40]
	jl .jump5821
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5821:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rdi
	call _H
	add rsp, 24
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump5810
.jump5809:
	mov rax, [rel const812] ; 92.34
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5822
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5822:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5823
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5823:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5824
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5824:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5825
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5825:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump5826: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const813] ; 99.9
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'S'
	add qword [rsp + 24], 1
	; Compare S to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5826 ; If S < bound, next iter
	mov qword [rsp + 24], 0 ; S = 0
	add qword [rsp + 16], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5826 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5826 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5826 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump5810:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 16], 1
	; Compare O to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5800 ; If O < bound, next iter
	mov qword [rsp + 16], 0 ; O = 0
	add qword [rsp + 8], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5800 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5800 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump5793:
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5827
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5827:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5828
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5828:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by y 
	jno .jump5829
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5829:
	imul rdi, [rsp + 0 + 8] ; multiply by P 
	jno .jump5830
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5830:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump5831: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5832
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5832:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5833
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5833:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5834
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5834:
	; Computing bound for 'S'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5835
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5835:
	; Computing bound for 'S'
	sub rsp, 16
	; Moving 16 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5836
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5836:
	cmp rax, [rsp + 8]
	jl .jump5837
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5837:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5838
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5838:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by F[r] 
	jno .jump5839
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5839:
	imul rdi, [rsp + 0 + 8] ; multiply by G 
	jno .jump5840
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5840:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump5841: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5842
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	jmp .jump5843
.jump5842:
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
.jump5843:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'T'
	add qword [rsp + 8], 1
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5841 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5841 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5844
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5844:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5845
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5845:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump5846
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5846:
	imul rdi, [rsp + 0 + 8] ; multiply by Q 
	jno .jump5847
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5847:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump5848: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'T'
	add qword [rsp + 8], 1
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5848 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5848 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5849
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5849:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5850
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5850:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by O 
	jno .jump5851
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5851:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump5852
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5852:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump5853: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5854
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5854:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
.jump5855: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'U'
	add qword [rsp + 0], 1
	; Compare U to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5855 ; If U < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'T'
	add qword [rsp + 8], 1
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5853 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5853 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rdi, 72
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 72 bytes from rsp to rax 
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 72
	push rax
	mov rax, 3
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5856
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5856:
	cmp rax, [rsp + 8]
	jl .jump5857
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5857:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5858
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5858:
	; Computing bound for 'U'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5859
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5859:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5860
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5860:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5861
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5861:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by Q 
	jno .jump5862
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5862:
	imul rdi, [rsp + 0 + 8] ; multiply by G 
	jno .jump5863
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5863:
	imul rdi, [rsp + 0 + 16] ; multiply by O 
	jno .jump5864
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5864:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump5865: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'U'
	add qword [rsp + 16], 1
	; Compare U to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5865 ; If U < bound, next iter
	mov qword [rsp + 16], 0 ; U = 0
	add qword [rsp + 8], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5865 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5865 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5866
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5866:
	cmp rax, [rsp + 24]
	jl .jump5867
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5867:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5868
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5868:
	cmp rax, [rsp + 32]
	jl .jump5869
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5869:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5870
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5870:
	cmp rax, [rsp + 40]
	jl .jump5871
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5871:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5872
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5872:
	; Computing bound for 'T'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5873
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5873:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5874
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5874:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump5875: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const814] ; 179
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'T'
	add qword [rsp + 8], 1
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5875 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5875 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5876
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5876:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5877
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5877:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump5878
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5878:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[S : q, T : m] 179) 
	jno .jump5879
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5879:
imul rdi, [rsp + 0 + 16] ; multiply by (array[S : Q, T : G, U : O] R)[m, J, h] 
	jno .jump5880
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5880:
	imul rdi, [rsp + 0 + 24] ; multiply by s 
	jno .jump5881
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5881:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump5882: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'V'
	add qword [rsp + 24], 1
	; Compare V to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5882 ; If V < bound, next iter
	mov qword [rsp + 24], 0 ; V = 0
	add qword [rsp + 16], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5882 ; If U < bound, next iter
	mov qword [rsp + 16], 0 ; U = 0
	add qword [rsp + 8], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5882 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5882 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5883
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5883:
	cmp rax, [rsp + 32]
	jl .jump5884
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5884:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5885
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5885:
	cmp rax, [rsp + 40]
	jl .jump5886
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5886:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5887
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5887:
	cmp rax, [rsp + 48]
	jl .jump5888
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5888:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5889
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5889:
	cmp rax, [rsp + 56]
	jl .jump5890
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5890:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5891
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5891:
	cmp rax, [rsp + 16]
	jl .jump5892
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5892:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5893
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5893:
	cmp rax, [rsp + 24]
	jl .jump5894
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5894:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5895
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5895:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
.jump5896: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5897
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5897:
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5898
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5898:
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5899
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5899:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump5900
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5900:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump5901
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5901:
	imul rdi, [rsp + 0 + 16] ; multiply by v 
	jno .jump5902
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5902:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
	; Initialize 'W' to 0
	mov rax, 0
	push rax
.jump5903: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5904
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5904:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5905
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5905:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by W 
	jno .jump5906
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5906:
	imul rdi, [rsp + 0 + 8] ; multiply by R 
	jno .jump5907
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5907:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
.jump5908: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'aa'
	add qword [rsp + 8], 1
	; Compare aa to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5908 ; If aa < bound, next iter
	mov qword [rsp + 8], 0 ; aa = 0
	add qword [rsp + 0], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5908 ; If Z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'Y'
	add qword [rsp + 16], 1
	; Compare Y to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5903 ; If Y < bound, next iter
	mov qword [rsp + 16], 0 ; Y = 0
	add qword [rsp + 8], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5903 ; If X < bound, next iter
	mov qword [rsp + 8], 0 ; X = 0
	add qword [rsp + 0], 1 ; W++
	; Compare W to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5903 ; If W < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5909
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	jmp .jump5910
.jump5909:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5911
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump5912
.jump5911:
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
.jump5912:
.jump5910:
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5913
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5913:
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5914
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5914:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'X' to 0
	mov rax, 0
	push rax
	; Initialize 'W' to 0
	mov rax, 0
	push rax
.jump5915: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'X'
	add qword [rsp + 8], 1
	; Compare X to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5915 ; If X < bound, next iter
	mov qword [rsp + 8], 0 ; X = 0
	add qword [rsp + 0], 1 ; W++
	; Compare W to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5915 ; If W < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5916
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5916:
	cmp rax, [rsp + 24]
	jl .jump5917
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5917:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5918
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5918:
	cmp rax, [rsp + 32]
	jl .jump5919
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5919:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5920
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5920:
	cmp rax, [rsp + 40]
	jl .jump5921
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5921:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const650] ; 452
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5922
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5922:
	cmp rax, [rsp + 16]
	jl .jump5923
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5923:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5924
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5924:
	cmp rax, [rsp + 24]
	jl .jump5925
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5925:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'V'
	add qword [rsp + 24], 1
	; Compare V to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5896 ; If V < bound, next iter
	mov qword [rsp + 24], 0 ; V = 0
	add qword [rsp + 16], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5896 ; If U < bound, next iter
	mov qword [rsp + 16], 0 ; U = 0
	add qword [rsp + 8], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5896 ; If T < bound, next iter
	mov qword [rsp + 8], 0 ; T = 0
	add qword [rsp + 0], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5896 ; If S < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'R'
	add qword [rsp + 8], 1
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5831 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5831 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5926
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5926:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5927
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5927:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5928
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5928:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump5929
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5929:
	imul rdi, [rsp + 0 + 8] ; multiply by C 
	jno .jump5930
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5930:
	imul rdi, [rsp + 0 + 16] ; multiply by v 
	jno .jump5931
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5931:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump5932: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5933
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5933:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5934
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5934:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by P 
	jno .jump5935
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5935:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump5936
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5936:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump5937: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5938
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5938:
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5939
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5939:
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5940
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5940:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5941
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5941:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump5942
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5942:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump5943
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5943:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump5944
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5944:
	imul rdi, [rsp + 0 + 24] ; multiply by U 
	jno .jump5945
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5945:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
	; Initialize 'X' to 0
	mov rax, 0
	push rax
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
.jump5946: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Y'
	add qword [rsp + 24], 1
	; Compare Y to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5946 ; If Y < bound, next iter
	mov qword [rsp + 24], 0 ; Y = 0
	add qword [rsp + 16], 1 ; X++
	; Compare X to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5946 ; If X < bound, next iter
	mov qword [rsp + 16], 0 ; X = 0
	add qword [rsp + 8], 1 ; W++
	; Compare W to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5946 ; If W < bound, next iter
	mov qword [rsp + 8], 0 ; W = 0
	add qword [rsp + 0], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5946 ; If V < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'U'
	add qword [rsp + 8], 1
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5937 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5937 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5947
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5947:
	cmp rax, [rsp + 16]
	jl .jump5948
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5948:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5949
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5949:
	cmp rax, [rsp + 24]
	jl .jump5950
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5950:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 40
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'S'
	add qword [rsp + 16], 1
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5932 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5932 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5932 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5951
	mov rax, [rel const11] ; True
	push rax
	jmp .jump5952
.jump5951:
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
.jump5952:
	pop rax
	cmp rax, 0
	je .jump5953
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5955
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5955:
	; Computing bound for 'S'
	mov rax, [rel const665] ; 338
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5956
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5956:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5957
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5957:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5958
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5958:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump5959: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'T'
	add qword [rsp + 24], 1
	; Compare T to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5959 ; If T < bound, next iter
	mov qword [rsp + 24], 0 ; T = 0
	add qword [rsp + 16], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5959 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5959 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5959 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5960
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5960:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5961
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5961:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by O 
	jno .jump5962
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5962:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[Q : C, R : N, S : 338, T : O] N) 
	jno .jump5963
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5963:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump5964: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'R'
	add qword [rsp + 8], 1
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5964 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5964 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump5954
.jump5953:
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5965
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5967
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5967:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5968
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5968:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by C 
	jno .jump5969
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5969:
	imul rdi, [rsp + 0 + 8] ; multiply by B 
	jno .jump5970
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5970:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump5971: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'R'
	add qword [rsp + 8], 1
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5971 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5971 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump5966
.jump5965:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	mov rax, [rel const262] ; 636
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5972
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5972:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5973
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5973:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump5974
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5974:
	imul rdi, [rsp + 0 + 8] ; multiply by 636 
	jno .jump5975
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5975:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump5976: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'R'
	add qword [rsp + 8], 1
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5976 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5976 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump5966:
.jump5954:
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5977
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5977:
	cmp rax, [rsp + 16]
	jl .jump5978
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5978:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5979
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5979:
	cmp rax, [rsp + 24]
	jl .jump5980
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5980:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5981
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5981:
	cmp rax, [rsp + 24]
	jl .jump5982
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5982:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5983
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5983:
	cmp rax, [rsp + 32]
	jl .jump5984
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5984:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5985
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5985:
	cmp rax, [rsp + 40]
	jl .jump5986
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5986:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5987
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5987:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5988
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5988:
	cmp rax, [rsp + 32]
	jl .jump5989
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5989:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5990
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5990:
	cmp rax, [rsp + 40]
	jl .jump5991
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5991:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5992
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5992:
	cmp rax, [rsp + 48]
	jl .jump5993
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5993:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5994
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5994:
	cmp rax, [rsp + 56]
	jl .jump5995
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5995:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5996
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const815] ; 592
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
.jump5996:
	push rax
	pop rdi
	call _H
	add rsp, 24
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5997
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5999
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5999:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by J 
	jno .jump6000
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6000:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump6001: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'R'
	add qword [rsp + 0], 1
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6001 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6002
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6002:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by O 
	jno .jump6003
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6003:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump6004: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 80 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'R'
	add qword [rsp + 0], 1
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6004 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6005
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6005:
	cmp rax, [rsp + 8]
	jl .jump6006
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6006:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6007
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6009
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6009:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6010
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6010:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6011
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6011:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof rgba[,][] 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump6012
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6012:
	imul rdi, [rsp + 0 + 8] ; multiply by v 
	jno .jump6013
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6013:
	imul rdi, [rsp + 0 + 16] ; multiply by C 
	jno .jump6014
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6014:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump6015: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6016
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6016:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump6017
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6017:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
.jump6018: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'U'
	add qword [rsp + 0], 1
	; Compare U to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6018 ; If U < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'T'
	add qword [rsp + 16], 1
	; Compare T to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6015 ; If T < bound, next iter
	mov qword [rsp + 16], 0 ; T = 0
	add qword [rsp + 8], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6015 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6015 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump6008
.jump6007:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	mov rax, [rel const644] ; 49
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6019
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6019:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6020
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6020:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6021
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6021:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof rgba[,][] 
	imul rdi, [rsp + 0 + 0] ; multiply by y 
	jno .jump6022
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6022:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump6023
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6023:
	imul rdi, [rsp + 0 + 16] ; multiply by 49 
	jno .jump6024
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6024:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump6025: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 176 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rdi, 48
	call _jpl_alloc
	; Moving 48 bytes from rsp to rax 
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 48
	push rax
	mov rax, 2
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'T'
	add qword [rsp + 16], 1
	; Compare T to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6025 ; If T < bound, next iter
	mov qword [rsp + 16], 0 ; T = 0
	add qword [rsp + 8], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6025 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6025 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump6008:
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6026
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6026:
	cmp rax, [rsp + 24]
	jl .jump6027
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6027:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6028
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6028:
	cmp rax, [rsp + 32]
	jl .jump6029
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6029:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6030
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6030:
	cmp rax, [rsp + 40]
	jl .jump6031
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6031:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rdi, 48
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 48 bytes from rsp to rax 
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 48
	push rax
	mov rax, 3
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6032
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6032:
	cmp rax, [rsp + 8]
	jl .jump6033
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6033:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5998
.jump5997:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6034
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6034:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof rgba[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by J 
	jno .jump6035
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6035:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump6036: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 176 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'R'
	add qword [rsp + 0], 1
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6036 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump5998:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6037
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6037:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6038
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6038:
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6039
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6039:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6040
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6040:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump6041
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6041:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump6042
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6042:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump6043
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6043:
	imul rdi, [rsp + 0 + 24] ; multiply by h 
	jno .jump6044
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6044:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump6045: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'U'
	add qword [rsp + 24], 1
	; Compare U to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6045 ; If U < bound, next iter
	mov qword [rsp + 24], 0 ; U = 0
	add qword [rsp + 16], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6045 ; If T < bound, next iter
	mov qword [rsp + 16], 0 ; T = 0
	add qword [rsp + 8], 1 ; S++
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6045 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6045 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6046
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6046:
	cmp rax, [rsp + 32]
	jl .jump6047
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6047:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6048
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6048:
	cmp rax, [rsp + 40]
	jl .jump6049
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6049:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6050
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6050:
	cmp rax, [rsp + 48]
	jl .jump6051
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6051:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6052
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6052:
	cmp rax, [rsp + 56]
	jl .jump6053
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6053:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6054
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6054:
	cmp rax, [rsp + 8]
	jl .jump6055
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6055:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _I
	add rsp, 8 ; Remove alignment
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 152 ; Local variables
	pop rbp
	ret

J:
_J:
	push rbp
	mov rbp, rsp
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6056
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
.jump6056:
	push rax
	pop rax
	cmp rax, 0
	jne .jump6057
	lea rdi, [rel const816] ; 'K'
	call _fail_assertion
.jump6057:
	sub rsp, 16
	; Moving 16 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump6058
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6060
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6060:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump6061
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6061:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6062: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6063
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6063:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6064
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6064:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump6065
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6065:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump6066
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6066:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
.jump6067: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6068
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6068:
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6069
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6069:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'P' to 0
	mov rax, 0
	push rax
	; Initialize 'O' to 0
	mov rax, 0
	push rax
.jump6070: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'P'
	add qword [rsp + 8], 1
	; Compare P to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6070 ; If P < bound, next iter
	mov qword [rsp + 8], 0 ; P = 0
	add qword [rsp + 0], 1 ; O++
	; Compare O to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6070 ; If O < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'N'
	add qword [rsp + 8], 1
	; Compare N to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6067 ; If N < bound, next iter
	mov qword [rsp + 8], 0 ; N = 0
	add qword [rsp + 0], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6067 ; If M < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'L'
	add qword [rsp + 0], 1
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6062 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6071
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6071:
	cmp rax, [rsp + 8]
	jl .jump6072
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6072:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump6059
.jump6058:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6073
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6073:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6074
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump6075
.jump6074:
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
.jump6075:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6076
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6076:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof int[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if z then h else o) 
	jno .jump6077
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6077:
	imul rdi, [rsp + 0 + 8] ; multiply by C 
	jno .jump6078
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6078:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6079: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6080
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6080:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6081
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6081:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump6082
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6082:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump6083
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6083:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump6084: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6084 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6084 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6079 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6079 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6085
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6085:
	cmp rax, [rsp + 16]
	jl .jump6086
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6086:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6087
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6087:
	cmp rax, [rsp + 24]
	jl .jump6088
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6088:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 24
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump6059:
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6089
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6089:
	; Computing bound for 'N'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6090
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6090:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6091
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6091:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6092
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6092:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6093
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6093:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6094: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6094 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6094 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6094 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6094 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6095
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6095:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6096
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6096:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6097
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6097:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6098: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6098 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6098 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6098 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6098 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rdi
	call _H
	add rsp, 24
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const817] ; 45.74
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump6099
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump6100
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump6101
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
.jump6101:
	push rax
	pop rax
.jump6100:
	push rax
	pop rax
.jump6099:
	push rax
	pop rax
	cmp rax, 0
	jne .jump6102
	lea rdi, [rel const818] ; 'L'
	call _fail_assertion
.jump6102:
	call _J
	push rax
	pop rax
	add rsp, 16 ; Local variables
	pop rbp
	ret
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6103
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6105
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6105:
	; Computing bound for 'N'
	mov rax, [rel const819] ; 230
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6106
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6106:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6107
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6107:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6108
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6108:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump6109
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6109:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump6110
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6110:
	imul rdi, [rsp + 0 + 16] ; multiply by 230 
	jno .jump6111
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6111:
	imul rdi, [rsp + 0 + 24] ; multiply by (- q) 
	jno .jump6112
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6112:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6113: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6114
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6114:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6115
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6115:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6116
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6116:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6117
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6117:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof void[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by N 
	jno .jump6118
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6118:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump6119
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6119:
	imul rdi, [rsp + 0 + 16] ; multiply by (- r) 
	jno .jump6120
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6120:
	imul rdi, [rsp + 0 + 24] ; multiply by O 
	jno .jump6121
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6121:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump6122: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6123
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6123:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6124
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6124:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6125
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6125:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump6126
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6126:
	imul rdi, [rsp + 0 + 8] ; multiply by O 
	jno .jump6127
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6127:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump6128
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6128:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump6129: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _J
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'V'
	add qword [rsp + 16], 1
	; Compare V to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6129 ; If V < bound, next iter
	mov qword [rsp + 16], 0 ; V = 0
	add qword [rsp + 8], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6129 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6129 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'S'
	add qword [rsp + 24], 1
	; Compare S to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6122 ; If S < bound, next iter
	mov qword [rsp + 24], 0 ; S = 0
	add qword [rsp + 16], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6122 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6122 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6122 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6130
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6130:
	cmp rax, [rsp + 32]
	jl .jump6131
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6131:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6132
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6132:
	cmp rax, [rsp + 40]
	jl .jump6133
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6133:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6134
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6134:
	cmp rax, [rsp + 48]
	jl .jump6135
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6135:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6136
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6136:
	cmp rax, [rsp + 56]
	jl .jump6137
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6137:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const820] ; 177
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6138
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6138:
	cmp rax, [rsp + 24]
	jl .jump6139
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6139:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6140
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6140:
	cmp rax, [rsp + 32]
	jl .jump6141
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6141:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6142
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6142:
	cmp rax, [rsp + 40]
	jl .jump6143
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6143:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6113 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6113 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6113 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6113 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6144
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	jmp .jump6145
.jump6144:
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6146
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6148
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6148:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6149: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'L'
	add qword [rsp + 0], 1
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6149 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump6147
.jump6146:
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
.jump6147:
.jump6145:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6150
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6150:
	cmp rax, [rsp + 32]
	jl .jump6151
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6151:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6152
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6152:
	cmp rax, [rsp + 40]
	jl .jump6153
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6153:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6154
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6154:
	cmp rax, [rsp + 48]
	jl .jump6155
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6155:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6156
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6156:
	cmp rax, [rsp + 56]
	jl .jump6157
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6157:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump6104
.jump6103:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	mov rax, [rel const821] ; 748
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6158
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6158:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6159
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6159:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump6160
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6160:
	imul rdi, [rsp + 0 + 8] ; multiply by 748 
	jno .jump6161
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6161:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6162: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6163
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6163:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6164
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6164:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[] 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump6165
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6165:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump6166
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6166:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump6167: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6167 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6167 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6168
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6168:
	cmp rax, [rsp + 16]
	jl .jump6169
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6169:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6170
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6170:
	cmp rax, [rsp + 24]
	jl .jump6171
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6171:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 16
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6172
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6172:
	cmp rax, [rsp + 8]
	jl .jump6173
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6173:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6174
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6176
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6176:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6177
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6177:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump6178
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6178:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump6179
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6179:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump6180: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6181
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6181:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6182
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6182:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6183
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6183:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6184
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6184:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump6185
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6185:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump6186
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6186:
	imul rdi, [rsp + 0 + 16] ; multiply by O 
	jno .jump6187
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6187:
	imul rdi, [rsp + 0 + 24] ; multiply by w 
	jno .jump6188
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6188:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump6189: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _J
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'S'
	add qword [rsp + 24], 1
	; Compare S to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6189 ; If S < bound, next iter
	mov qword [rsp + 24], 0 ; S = 0
	add qword [rsp + 16], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6189 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6189 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6189 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6190
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6190:
	cmp rax, [rsp + 32]
	jl .jump6191
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6191:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6192
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6192:
	cmp rax, [rsp + 40]
	jl .jump6193
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6193:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6194
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6194:
	cmp rax, [rsp + 48]
	jl .jump6195
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6195:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6196
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6196:
	cmp rax, [rsp + 56]
	jl .jump6197
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6197:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6180 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6180 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump6175
.jump6174:
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6198
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6200
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6202
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6202:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6203
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6203:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump6204
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6204:
	imul rdi, [rsp + 0 + 8] ; multiply by D 
	jno .jump6205
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6205:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump6206: ; Begin body of loop
	; Compute loop body
	call _J
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6206 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6206 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump6201
.jump6200:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6207
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6207:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6208
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6208:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by M 
	jno .jump6209
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6209:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump6210
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6210:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump6211: ; Begin body of loop
	; Compute loop body
	call _J
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6211 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6211 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump6201:
	jmp .jump6199
.jump6198:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6212
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6212:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6213
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6213:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by B 
	jno .jump6214
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6214:
	imul rdi, [rsp + 0 + 8] ; multiply by G 
	jno .jump6215
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6215:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump6216: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6217
	call _J
	push rax
	jmp .jump6218
.jump6217:
	call _J
	push rax
.jump6218:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6216 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6216 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump6199:
.jump6175:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6162 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6162 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6219
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6221
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6221:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6222
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6222:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6223
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6223:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6224
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6224:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof void[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- m) 
	jno .jump6225
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6225:
	imul rdi, [rsp + 0 + 8] ; multiply by B 
	jno .jump6226
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6226:
	imul rdi, [rsp + 0 + 16] ; multiply by (- q) 
	jno .jump6227
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6227:
	imul rdi, [rsp + 0 + 24] ; multiply by o 
	jno .jump6228
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6228:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6229: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6230
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6230:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6231
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6231:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6232
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6232:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6233
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6233:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump6234
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6234:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump6235
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6235:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump6236
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6236:
	imul rdi, [rsp + 0 + 24] ; multiply by D 
	jno .jump6237
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6237:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump6238: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _J
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'S'
	add qword [rsp + 24], 1
	; Compare S to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6238 ; If S < bound, next iter
	mov qword [rsp + 24], 0 ; S = 0
	add qword [rsp + 16], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6238 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6238 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6238 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6229 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6229 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6229 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6229 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump6220
.jump6219:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6239
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6239:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6240
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6240:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6241
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6241:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6242: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'N'
	add qword [rsp + 16], 1
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6242 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6242 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6242 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6243
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6243:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6244
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6244:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6245
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6245:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6246
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6246:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof void[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by D 
	jno .jump6247
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6247:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump6248
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6248:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump6249
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6249:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[L : h, M : f, N : B] L) 
	jno .jump6250
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6250:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6251: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6252
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6252:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6253
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6253:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6254
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6254:
	; Computing bound for 'P'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6255
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6255:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by D 
	jno .jump6256
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6256:
	imul rdi, [rsp + 0 + 8] ; multiply by O 
	jno .jump6257
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6257:
	imul rdi, [rsp + 0 + 16] ; multiply by s 
	jno .jump6258
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6258:
	imul rdi, [rsp + 0 + 24] ; multiply by n 
	jno .jump6259
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6259:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
	; Initialize 'P' to 0
	mov rax, 0
	push rax
.jump6260: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _J
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'S'
	add qword [rsp + 24], 1
	; Compare S to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6260 ; If S < bound, next iter
	mov qword [rsp + 24], 0 ; S = 0
	add qword [rsp + 16], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6260 ; If R < bound, next iter
	mov qword [rsp + 16], 0 ; R = 0
	add qword [rsp + 8], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6260 ; If Q < bound, next iter
	mov qword [rsp + 8], 0 ; Q = 0
	add qword [rsp + 0], 1 ; P++
	; Compare P to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6260 ; If P < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6251 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6251 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6251 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6251 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump6220:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6261
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6261:
	; Computing bound for 'M'
	mov rax, [rel const541] ; 424
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6262
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6262:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6263
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	jmp .jump6264
.jump6263:
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
.jump6264:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6265
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6265:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if a then r else r) 
	jno .jump6266
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6266:
	imul rdi, [rsp + 0 + 8] ; multiply by 424 
	jno .jump6267
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6267:
	imul rdi, [rsp + 0 + 16] ; multiply by B 
	jno .jump6268
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6268:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6269: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'N'
	add qword [rsp + 16], 1
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6269 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6269 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6269 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6270
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6270:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6271
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6271:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6272
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6272:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6273
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6273:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6274: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6274 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6274 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6274 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6274 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump6275
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const822] ; 372
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	jmp .jump6276
.jump6275:
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
.jump6276:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6277
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6277:
	cmp rax, [rsp + 24]
	jl .jump6278
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6278:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6279
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6279:
	cmp rax, [rsp + 32]
	jl .jump6280
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6280:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6281
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6281:
	cmp rax, [rsp + 40]
	jl .jump6282
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6282:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6283
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6283:
	cmp rax, [rsp + 32]
	jl .jump6284
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6284:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6285
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6285:
	cmp rax, [rsp + 40]
	jl .jump6286
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6286:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6287
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6287:
	cmp rax, [rsp + 48]
	jl .jump6288
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6288:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6289
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6289:
	cmp rax, [rsp + 56]
	jl .jump6290
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6290:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6291
	sub rsp, 32
	lea rdi, [rsp + 0]
	call _I
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const591] ; 859
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6293
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6293:
	cmp rax, [rsp + 24]
	jl .jump6294
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6294:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6295
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6295:
	cmp rax, [rsp + 32]
	jl .jump6296
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6296:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6297
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6297:
	cmp rax, [rsp + 40]
	jl .jump6298
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6298:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6299
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6301
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6301:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6302
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6302:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by G 
	jno .jump6303
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6303:
	imul rdi, [rsp + 0 + 8] ; multiply by v 
	jno .jump6304
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6304:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6305: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6305 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6305 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump6300
.jump6299:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6306
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6306:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6307
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6307:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump6308
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6308:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump6309
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6309:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6310: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6310 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6310 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump6300:
	jmp .jump6292
.jump6291:
	mov rax, [rel const823] ; 99.71
	push rax
	mov rax, [rel const824] ; 43.06
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6311
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6313
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6313:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6314
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6314:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump6315
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6315:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump6316
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6316:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6317: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6317 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6317 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump6312
.jump6311:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6318
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6318:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6319
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6319:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by y 
	jno .jump6320
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6320:
	imul rdi, [rsp + 0 + 8] ; multiply by v 
	jno .jump6321
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6321:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6322: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6322 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6322 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump6312:
.jump6292:
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6323
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6323:
	cmp rax, [rsp + 16]
	jl .jump6324
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6324:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6325
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6325:
	cmp rax, [rsp + 24]
	jl .jump6326
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6326:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6327
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6327:
	cmp rax, [rsp + 32]
	jl .jump6328
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6328:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6329
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6329:
	cmp rax, [rsp + 40]
	jl .jump6330
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6330:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6331
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6331:
	cmp rax, [rsp + 48]
	jl .jump6332
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6332:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6333
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6333:
	cmp rax, [rsp + 56]
	jl .jump6334
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6334:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _d
	add rsp, 8
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump6335
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6337
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6339
	call _J
	push rax
	jmp .jump6340
.jump6339:
	mov rax, [rel const26] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6341
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6343
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6343:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6344
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6344:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6345
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6345:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6346
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6346:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump6347
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6347:
	imul rdi, [rsp + 0 + 8] ; multiply by G 
	jno .jump6348
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6348:
	imul rdi, [rsp + 0 + 16] ; multiply by q 
	jno .jump6349
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6349:
	imul rdi, [rsp + 0 + 24] ; multiply by q 
	jno .jump6350
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6350:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6351: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _J
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6351 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6351 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6351 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6351 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump6342
.jump6341:
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6352
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6354
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6354:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6355
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6355:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6356
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6356:
	; Computing bound for 'L'
	mov rax, [rel const73] ; 938
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6357
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6357:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by 938 
	jno .jump6358
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6358:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump6359
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6359:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump6360
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6360:
	imul rdi, [rsp + 0 + 24] ; multiply by G 
	jno .jump6361
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6361:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6362: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _J
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6362 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6362 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6362 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6362 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump6353
.jump6352:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6363
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6363:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6364
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6364:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6365
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6365:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6366
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6366:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump6367
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6367:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump6368
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6368:
	imul rdi, [rsp + 0 + 16] ; multiply by o 
	jno .jump6369
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6369:
	imul rdi, [rsp + 0 + 24] ; multiply by s 
	jno .jump6370
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6370:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6371: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _J
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6371 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6371 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6371 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6371 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump6353:
.jump6342:
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6372
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6372:
	cmp rax, [rsp + 32]
	jl .jump6373
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6373:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6374
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6374:
	cmp rax, [rsp + 40]
	jl .jump6375
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6375:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6376
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6376:
	cmp rax, [rsp + 48]
	jl .jump6377
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6377:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6378
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6378:
	cmp rax, [rsp + 56]
	jl .jump6379
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6379:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump6340:
	jmp .jump6338
.jump6337:
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6380
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	mov rax, [rel const60] ; 837
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6382
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6382:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6383
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6383:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by B 
	jno .jump6384
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6384:
	imul rdi, [rsp + 0 + 8] ; multiply by 837 
	jno .jump6385
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6385:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6386: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6387
	sub rsp, 8 ; Add alignment
	call _J
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump6388
.jump6387:
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6389
	sub rsp, 8 ; Add alignment
	call _J
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump6390
.jump6389:
	sub rsp, 8 ; Add alignment
	call _J
	add rsp, 8 ; Remove alignment
	push rax
.jump6390:
.jump6388:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6386 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6386 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6391
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	jmp .jump6392
.jump6391:
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
.jump6392:
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6393
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6393:
	cmp rax, [rsp + 16]
	jl .jump6394
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6394:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6395
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6395:
	cmp rax, [rsp + 24]
	jl .jump6396
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6396:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump6381
.jump6380:
	call _J
	push rax
.jump6381:
.jump6338:
	jmp .jump6336
.jump6335:
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6397
	call _J
	push rax
	jmp .jump6398
.jump6397:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6399
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6399:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6400
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump6400:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6401
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump6401:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6402
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6402:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6403
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6403:
	; Computing bound for 'L'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6404
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6404:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6405
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6405:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6406: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const234] ; 720
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6406 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6406 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6407
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6407:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[L : G, M : v] 720) 
	jno .jump6408
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6408:
	imul rdi, [rsp + 0 + 8] ; multiply by y 
	jno .jump6409
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6409:
	imul rdi, [rsp + 0 + 16] ; multiply by (s / (q / m)) 
	jno .jump6410
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6410:
	imul rdi, [rsp + 0 + 24] ; multiply by o 
	jno .jump6411
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6411:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6412: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6413
	sub rsp, 8 ; Add alignment
	call _J
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump6414
.jump6413:
	sub rsp, 8 ; Add alignment
	call _J
	add rsp, 8 ; Remove alignment
	push rax
.jump6414:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6412 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6412 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6412 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6412 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6415
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6415:
	cmp rax, [rsp + 32]
	jl .jump6416
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6416:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6417
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6417:
	cmp rax, [rsp + 40]
	jl .jump6418
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6418:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6419
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6419:
	cmp rax, [rsp + 48]
	jl .jump6420
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6420:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6421
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6421:
	cmp rax, [rsp + 56]
	jl .jump6422
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6422:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump6398:
.jump6336:
.jump6104:
	pop rax
	add rsp, 16 ; Local variables
	pop rbp
	ret
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump6423
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
.jump6423:
	push rax
	pop rax
	cmp rax, 0
	je .jump6424
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump6425
.jump6424:
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6426
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6428
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump6429
.jump6428:
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
.jump6429:
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6430
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6430:
	cqo
	idiv r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6431
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6433
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6433:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6434
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6434:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6435
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6435:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump6436
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump6436:
	push rax
	pop rax
	cmp rax, 0
	je .jump6437
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump6438
.jump6437:
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
.jump6438:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6439
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6439:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (if (z || a) then h else D) 
	jno .jump6440
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6440:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump6441
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6441:
	imul rdi, [rsp + 0 + 16] ; multiply by B 
	jno .jump6442
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6442:
	imul rdi, [rsp + 0 + 24] ; multiply by v 
	jno .jump6443
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6443:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6444: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6444 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6444 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6444 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6444 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump6432
.jump6431:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	mov rax, [rel const673] ; 834
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6445
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6445:
	; Computing bound for 'N'
	mov rax, [rel const466] ; 219
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6446
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6446:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6447
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6447:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6448
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6448:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by D 
	jno .jump6449
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6449:
	imul rdi, [rsp + 0 + 8] ; multiply by v 
	jno .jump6450
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6450:
	imul rdi, [rsp + 0 + 16] ; multiply by 219 
	jno .jump6451
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6451:
	imul rdi, [rsp + 0 + 24] ; multiply by 834 
	jno .jump6452
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6452:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6453: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6453 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6453 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6453 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6453 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump6432:
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6454
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6454:
	cmp rax, [rsp + 32]
	jl .jump6455
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6455:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6456
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6456:
	cmp rax, [rsp + 40]
	jl .jump6457
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6457:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6458
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6458:
	cmp rax, [rsp + 48]
	jl .jump6459
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6459:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6460
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6460:
	cmp rax, [rsp + 56]
	jl .jump6461
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6461:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump6427
.jump6426:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump6462
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
.jump6462:
	push rax
.jump6427:
	pop rax
	cmp rax, 0
	jne .jump6463
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6464
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6465
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
.jump6465:
	push rax
	pop rax
.jump6464:
	push rax
	pop rax
	cmp rax, 0
	je .jump6466
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6468
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6468:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6469
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump6470
.jump6469:
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
.jump6470:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6471
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6471:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (if t then (- h) else o) 
	jno .jump6472
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6472:
	imul rdi, [rsp + 0 + 8] ; multiply by G 
	jno .jump6473
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6473:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6474: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6474 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6474 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump6467
.jump6466:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6475
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6475:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6476
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6476:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump6477
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6477:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump6478
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6478:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6479: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6480
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	jmp .jump6481
.jump6480:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump6481:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6479 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6479 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump6467:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6482
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	jmp .jump6483
.jump6482:
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
.jump6483:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6484
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6484:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6485
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6485:
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6486
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6486:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6487
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6487:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6488
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6488:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6489: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'O'
	add qword [rsp + 24], 1
	; Compare O to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6489 ; If O < bound, next iter
	mov qword [rsp + 24], 0 ; O = 0
	add qword [rsp + 16], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6489 ; If N < bound, next iter
	mov qword [rsp + 16], 0 ; N = 0
	add qword [rsp + 8], 1 ; M++
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6489 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6489 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6490
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6490:
	cmp rax, [rsp + 16]
	jl .jump6491
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6491:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6492
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6492:
	cmp rax, [rsp + 24]
	jl .jump6493
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6493:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'M'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6494
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6494:
	; Computing bound for 'L'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6495
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6495:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump6496
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6496:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump6497
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6497:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'M' to 0
	mov rax, 0
	push rax
	; Initialize 'L' to 0
	mov rax, 0
	push rax
.jump6498: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'O'
	sub rsp, 16
	; Moving 16 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6499
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6499:
	cmp rax, [rsp + 8]
	jl .jump6500
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6500:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6501
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6501:
	; Computing bound for 'N'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6502
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6502:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump6503
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6503:
	imul rdi, [rsp + 0 + 8] ; multiply by e[r] 
	jno .jump6504
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6504:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'O' to 0
	mov rax, 0
	push rax
	; Initialize 'N' to 0
	mov rax, 0
	push rax
.jump6505: ; Begin body of loop
	; Compute loop body
	call _J
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'O'
	add qword [rsp + 8], 1
	; Compare O to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6505 ; If O < bound, next iter
	mov qword [rsp + 8], 0 ; O = 0
	add qword [rsp + 0], 1 ; N++
	; Compare N to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6505 ; If N < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'M'
	add qword [rsp + 8], 1
	; Compare M to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6498 ; If M < bound, next iter
	mov qword [rsp + 8], 0 ; M = 0
	add qword [rsp + 0], 1 ; L++
	; Compare L to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6498 ; If L < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _J
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	add rsp, 8
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
.jump6463:
	push rax
.jump6425:
	pop rax
	cmp rax, 0
	jne .jump6506
	lea rdi, [rel const818] ; 'L'
	call _fail_assertion
.jump6506:
	sub rsp, 24
	; Moving 24 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 176 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10

L:
_L:
	push rbp
	mov rbp, rsp
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ad'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6507
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6507:
	; Computing bound for 'ac'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6508
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6508:
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6509
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6509:
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6510
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6510:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6511
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6511:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by (f % Q) 
	jno .jump6512
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6512:
	imul rdi, [rsp + 0 + 8] ; multiply by Z 
	jno .jump6513
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6513:
	imul rdi, [rsp + 0 + 16] ; multiply by x 
	jno .jump6514
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6514:
	imul rdi, [rsp + 0 + 24] ; multiply by x 
	jno .jump6515
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6515:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ad' to 0
	mov rax, 0
	push rax
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
.jump6516: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const825] ; 90.12
	push rax
	sub rsp, 8 ; Add alignment
	sub rsp, 32
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	pop rsi
	lea rdi, [rsp + 16]
	call _b
	add rsp, 16
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6517
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6517:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by B 
	jno .jump6518
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6518:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6519: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _I
	add rsp, 8 ; Remove alignment
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'ae'
	add qword [rsp + 0], 1
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6519 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	call _i
	add rsp, 16
	add rsp, 32
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 24
	; Moving 24 bytes from r12 - 80 to rsp 
		mov r10, [r12 - 80 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 80 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6520
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6520:
	cmp rax, [rsp + 16]
	jl .jump6521
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6521:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6522
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6522:
	cmp rax, [rsp + 24]
	jl .jump6523
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6523:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24 
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const826] ; 88.94
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6524
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6526
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6526:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by W 
	jno .jump6527
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6527:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6528: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _I
	add rsp, 8 ; Remove alignment
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'ae'
	add qword [rsp + 0], 1
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6528 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6529
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6529:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by W 
	jno .jump6530
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6530:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6531: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _I
	add rsp, 8 ; Remove alignment
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'ae'
	add qword [rsp + 0], 1
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6531 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6532
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6532:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump6533
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6533:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6534: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _I
	add rsp, 8 ; Remove alignment
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'ae'
	add qword [rsp + 0], 1
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6534 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6535
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6535:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by aa 
	jno .jump6536
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6536:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6537: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _I
	add rsp, 8 ; Remove alignment
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'ae'
	add qword [rsp + 0], 1
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6537 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rdi, 64
	call _jpl_alloc
	; Moving 64 bytes from rsp to rax 
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 64
	push rax
	mov rax, 4
	push rax
	jmp .jump6525
.jump6524:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6538
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6538:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump6539
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6539:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6540: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _I
	add rsp, 8 ; Remove alignment
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'ae'
	add qword [rsp + 0], 1
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6540 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6541
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6541:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by B 
	jno .jump6542
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6542:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6543: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _I
	add rsp, 8 ; Remove alignment
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'ae'
	add qword [rsp + 0], 1
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6543 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 2
	push rax
.jump6525:
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6544
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6544:
	cmp rax, [rsp + 8]
	jl .jump6545
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6545:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	call _i
	add rsp, 16
	add rsp, 32
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ad'
	add qword [rsp + 24], 1
	; Compare ad to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6516 ; If ad < bound, next iter
	mov qword [rsp + 24], 0 ; ad = 0
	add qword [rsp + 16], 1 ; ac++
	; Compare ac to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6516 ; If ac < bound, next iter
	mov qword [rsp + 16], 0 ; ac = 0
	add qword [rsp + 8], 1 ; ab++
	; Compare ab to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6516 ; If ab < bound, next iter
	mov qword [rsp + 8], 0 ; ab = 0
	add qword [rsp + 0], 1 ; aa++
	; Compare aa to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6516 ; If aa < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6546
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6546:
	cmp rax, [rsp + 32]
	jl .jump6547
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6547:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6548
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6548:
	cmp rax, [rsp + 40]
	jl .jump6549
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6549:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6550
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6550:
	cmp rax, [rsp + 48]
	jl .jump6551
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6551:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6552
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6552:
	cmp rax, [rsp + 56]
	jl .jump6553
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6553:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const827] ; 13.67
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump6554
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const828] ; 'aa'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6554:
	sub rsp, 32
	sub rsp, 8 ; Add alignment
	lea rdi, [rsp + 8]
	call _I
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6555
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump6555:
	push rax
	pop rax
	cmp rax, 0
	je .jump6556
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6558
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6558:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6559
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6559:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6560: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const829] ; 29.75
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'af'
	add qword [rsp + 8], 1
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6560 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6560 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6561
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6563
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6563:
	; Computing bound for 'ae'
	mov rax, [rel const830] ; 45
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6564
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6564:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 45 
	jno .jump6565
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6565:
	imul rdi, [rsp + 0 + 8] ; multiply by ab 
	jno .jump6566
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6566:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6567: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'af'
	add qword [rsp + 8], 1
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6567 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6567 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump6562
.jump6561:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'af'
	sub rsp, 16
	; Moving 16 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -96 to rsp 
		mov r10, [rbp - -96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6568
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6568:
	cmp rax, [rsp + 8]
	jl .jump6569
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6569:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6570
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6570:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6571
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6571:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by B 
	jno .jump6572
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6572:
	imul rdi, [rsp + 0 + 8] ; multiply by F[X] 
	jno .jump6573
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6573:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6574: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'af'
	add qword [rsp + 8], 1
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6574 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6574 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump6562:
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6575
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	jmp .jump6576
.jump6575:
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6577
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	jmp .jump6578
.jump6577:
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6579
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	jmp .jump6580
.jump6579:
	mov rax, [rel const26] ; False
	push rax
.jump6580:
.jump6578:
.jump6576:
	pop rdi
	call _H
	add rsp, 24
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6581
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6583
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6583:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6584
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6584:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (G + ab) 
	jno .jump6585
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6585:
	imul rdi, [rsp + 0 + 8] ; multiply by C 
	jno .jump6586
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6586:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6587: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'aj'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6588
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6588:
	; Computing bound for 'ai'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6589
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6589:
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6590
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6590:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6591
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6591:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'aj' to 0
	mov rax, 0
	push rax
	; Initialize 'ai' to 0
	mov rax, 0
	push rax
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
.jump6592: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'aj'
	add qword [rsp + 24], 1
	; Compare aj to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6592 ; If aj < bound, next iter
	mov qword [rsp + 24], 0 ; aj = 0
	add qword [rsp + 16], 1 ; ai++
	; Compare ai to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6592 ; If ai < bound, next iter
	mov qword [rsp + 16], 0 ; ai = 0
	add qword [rsp + 8], 1 ; ah++
	; Compare ah to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6592 ; If ah < bound, next iter
	mov qword [rsp + 8], 0 ; ah = 0
	add qword [rsp + 0], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6592 ; If ag < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'af'
	add qword [rsp + 8], 1
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6587 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6587 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump6582
.jump6581:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6593
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6593:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6594
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6594:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by B 
	jno .jump6595
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6595:
	imul rdi, [rsp + 0 + 8] ; multiply by N 
	jno .jump6596
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6596:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6597: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'af'
	add qword [rsp + 8], 1
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6597 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6597 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump6582:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from r12 - 256 to rsp 
		mov r10, [r12 - 256 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6598
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6598:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6599
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6599:
	; Computing bound for 'af'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6600
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6600:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from rbp - -64 to rsp 
		mov r10, [rbp - -64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6601
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6601:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6602
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6602:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump6603
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6603:
	imul rdi, [rsp + 0 + 8] ; multiply by T 
	jno .jump6604
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6604:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump6605
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6605:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6606: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ag'
	add qword [rsp + 16], 1
	; Compare ag to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6606 ; If ag < bound, next iter
	mov qword [rsp + 16], 0 ; ag = 0
	add qword [rsp + 8], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6606 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6606 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from rbp - -64 to rsp 
		mov r10, [rbp - -64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6607
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6607:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6608: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'ae'
	add qword [rsp + 0], 1
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6608 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6609
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6609:
	cmp rax, [rsp + 24]
	jl .jump6610
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6610:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6611
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6611:
	cmp rax, [rsp + 32]
	jl .jump6612
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6612:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6613
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6613:
	cmp rax, [rsp + 40]
	jl .jump6614
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6614:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6615
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6615:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6616
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6616:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by ad 
	jno .jump6617
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6617:
imul rdi, [rsp + 0 + 8] ; multiply by (array[ae : h, af : T, ag : m] y)[Q, (sum[ae : T] m), v] 
	jno .jump6618
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6618:
	imul rdi, [rsp + 0 + 16] ; multiply by O 
	jno .jump6619
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6619:
	imul rdi, [rsp + 0 + 24] ; multiply by K 
	jno .jump6620
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6620:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6621: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ah'
	add qword [rsp + 24], 1
	; Compare ah to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6621 ; If ah < bound, next iter
	mov qword [rsp + 24], 0 ; ah = 0
	add qword [rsp + 16], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6621 ; If ag < bound, next iter
	mov qword [rsp + 16], 0 ; ag = 0
	add qword [rsp + 8], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6621 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6621 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	call _E
	add rsp, 40
	add rsp, 24
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6622
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6624
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6624:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6625
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6625:
	; Computing bound for 'af'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'ag'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6626
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6626:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6627
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6627:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6628: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const48] ; 812
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'af'
	add qword [rsp + 8], 1
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6628 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6628 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6629
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6629:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6630
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6630:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6631
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6631:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6632: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'ag'
	add qword [rsp + 16], 1
	; Compare ag to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6632 ; If ag < bound, next iter
	mov qword [rsp + 16], 0 ; ag = 0
	add qword [rsp + 8], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6632 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6632 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6633
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6633:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6634
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6634:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof void[][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump6635
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6635:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[ae : ab, af : V, ag : (sum[ae : x, af : s] 812)] Y) 
	jno .jump6636
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6636:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump6637
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6637:
	imul rdi, [rsp + 0 + 24] ; multiply by ac 
	jno .jump6638
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6638:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6639: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'al'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6640
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6640:
	; Computing bound for 'ak'
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6641
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6641:
	; Computing bound for 'aj'
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6642
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6642:
	; Computing bound for 'ai'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6643
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6643:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof void[] 
	imul rdi, [rsp + 0 + 0] ; multiply by y 
	jno .jump6644
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6644:
	imul rdi, [rsp + 0 + 8] ; multiply by W 
	jno .jump6645
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6645:
	imul rdi, [rsp + 0 + 16] ; multiply by W 
	jno .jump6646
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6646:
	imul rdi, [rsp + 0 + 24] ; multiply by af 
	jno .jump6647
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6647:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'al' to 0
	mov rax, 0
	push rax
	; Initialize 'ak' to 0
	mov rax, 0
	push rax
	; Initialize 'aj' to 0
	mov rax, 0
	push rax
	; Initialize 'ai' to 0
	mov rax, 0
	push rax
.jump6648: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'am'
	sub rsp, 8
	; Moving 8 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6649
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6649:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by Y 
	jno .jump6650
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6650:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'am' to 0
	mov rax, 0
	push rax
.jump6651: ; Begin body of loop
	; Compute loop body
	call _J
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'am'
	add qword [rsp + 0], 1
	; Compare am to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6651 ; If am < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 16
	add rax, [rsp + 80]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'al'
	add qword [rsp + 24], 1
	; Compare al to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6648 ; If al < bound, next iter
	mov qword [rsp + 24], 0 ; al = 0
	add qword [rsp + 16], 1 ; ak++
	; Compare ak to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6648 ; If ak < bound, next iter
	mov qword [rsp + 16], 0 ; ak = 0
	add qword [rsp + 8], 1 ; aj++
	; Compare aj to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6648 ; If aj < bound, next iter
	mov qword [rsp + 8], 0 ; aj = 0
	add qword [rsp + 0], 1 ; ai++
	; Compare ai to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6648 ; If ai < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'ah'
	add qword [rsp + 24], 1
	; Compare ah to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6639 ; If ah < bound, next iter
	mov qword [rsp + 24], 0 ; ah = 0
	add qword [rsp + 16], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6639 ; If ag < bound, next iter
	mov qword [rsp + 16], 0 ; ag = 0
	add qword [rsp + 8], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6639 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6639 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6652
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6652:
	cmp rax, [rsp + 32]
	jl .jump6653
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6653:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6654
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6654:
	cmp rax, [rsp + 40]
	jl .jump6655
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6655:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6656
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6656:
	cmp rax, [rsp + 48]
	jl .jump6657
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6657:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6658
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6658:
	cmp rax, [rsp + 56]
	jl .jump6659
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6659:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 40
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6660
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6660:
	cmp rax, [rsp + 32]
	jl .jump6661
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6661:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6662
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6662:
	cmp rax, [rsp + 40]
	jl .jump6663
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6663:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6664
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6664:
	cmp rax, [rsp + 48]
	jl .jump6665
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6665:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6666
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6666:
	cmp rax, [rsp + 56]
	jl .jump6667
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6667:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump6623
.jump6622:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6668
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6668:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by C 
	jno .jump6669
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6669:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6670: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6671
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ai'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6673
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6673:
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6674
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6674:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6675
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6675:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6676
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6676:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump6677
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6677:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump6678
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6678:
	imul rdi, [rsp + 0 + 16] ; multiply by s 
	jno .jump6679
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6679:
	imul rdi, [rsp + 0 + 24] ; multiply by P 
	jno .jump6680
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6680:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ai' to 0
	mov rax, 0
	push rax
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
.jump6681: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _J
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ai'
	add qword [rsp + 24], 1
	; Compare ai to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6681 ; If ai < bound, next iter
	mov qword [rsp + 24], 0 ; ai = 0
	add qword [rsp + 16], 1 ; ah++
	; Compare ah to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6681 ; If ah < bound, next iter
	mov qword [rsp + 16], 0 ; ah = 0
	add qword [rsp + 8], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6681 ; If ag < bound, next iter
	mov qword [rsp + 8], 0 ; ag = 0
	add qword [rsp + 0], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6681 ; If af < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6682
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6682:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6683
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6683:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by N 
	jno .jump6684
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6684:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump6685
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6685:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
.jump6686: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -96 to rsp 
		mov r10, [rbp - -96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ag'
	add qword [rsp + 8], 1
	; Compare ag to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6686 ; If ag < bound, next iter
	mov qword [rsp + 8], 0 ; ag = 0
	add qword [rsp + 0], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6686 ; If af < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6687
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6687:
	cmp rax, [rsp + 16]
	jl .jump6688
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6688:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6689
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6689:
	cmp rax, [rsp + 24]
	jl .jump6690
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6690:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6691
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6691:
	cmp rax, [rsp + 32]
	jl .jump6692
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6692:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6693
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6693:
	cmp rax, [rsp + 40]
	jl .jump6694
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6694:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6695
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6695:
	cmp rax, [rsp + 48]
	jl .jump6696
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6696:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6697
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6697:
	cmp rax, [rsp + 56]
	jl .jump6698
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6698:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump6672
.jump6671:
	sub rsp, 8 ; Add alignment
	sub rsp, 40
	; Moving 40 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -80 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -80 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -80 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump6699
	sub rsp, 24
	; Moving 24 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	jmp .jump6700
.jump6699:
	sub rsp, 24
	; Moving 24 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
.jump6700:
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6701
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6703
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump6704
.jump6703:
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump6704:
	jmp .jump6702
.jump6701:
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump6702:
	call _L
	add rsp, 40
	add rsp, 24
	add rsp, 40
	add rsp, 8 ; Remove alignment
	push rax
.jump6672:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ae'
	add qword [rsp + 0], 1
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6670 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump6623:
	jmp .jump6557
.jump6556:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6705
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6705:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6706
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6706:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6707
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6707:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by S 
	jno .jump6708
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6708:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump6709
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6709:
	imul rdi, [rsp + 0 + 16] ; multiply by y 
	jno .jump6710
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6710:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6711: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6712
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6712:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump6713
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6713:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
.jump6714: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -80 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -80 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -80 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'ah'
	add qword [rsp + 0], 1
	; Compare ah to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6714 ; If ah < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6715
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6715:
	cmp rax, [rsp + 8]
	jl .jump6716
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6716:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'ag'
	add qword [rsp + 16], 1
	; Compare ag to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6711 ; If ag < bound, next iter
	mov qword [rsp + 16], 0 ; ag = 0
	add qword [rsp + 8], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6711 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6711 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump6717
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump6717:
	push rax
	pop rax
	cmp rax, 0
	je .jump6718
	mov rax, [rel const145] ; 640
	push rax
	jmp .jump6719
.jump6718:
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
.jump6719:
	sub rsp, 8
	; Moving 8 bytes from r12 - 256 to rsp 
		mov r10, [r12 - 256 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6720
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6720:
	cmp rax, [rsp + 24]
	jl .jump6721
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6721:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6722
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6722:
	cmp rax, [rsp + 32]
	jl .jump6723
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6723:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6724
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6724:
	cmp rax, [rsp + 40]
	jl .jump6725
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6725:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6726
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6726:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6727
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6727:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6728
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6728:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6729
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6729:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by C 
	jno .jump6730
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6730:
	imul rdi, [rsp + 0 + 8] ; multiply by y 
	jno .jump6731
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6731:
	imul rdi, [rsp + 0 + 16] ; multiply by Q 
	jno .jump6732
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6732:
	imul rdi, [rsp + 0 + 24] ; multiply by r 
	jno .jump6733
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6733:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6734: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ah'
	add qword [rsp + 24], 1
	; Compare ah to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6734 ; If ah < bound, next iter
	mov qword [rsp + 24], 0 ; ah = 0
	add qword [rsp + 16], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6734 ; If ag < bound, next iter
	mov qword [rsp + 16], 0 ; ag = 0
	add qword [rsp + 8], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6734 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6734 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	call _L
	add rsp, 40
	add rsp, 24
	add rsp, 40
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6735
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6735:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6736
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6736:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6737
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6737:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by B 
	jno .jump6738
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6738:
	imul rdi, [rsp + 0 + 8] ; multiply by (D - O) 
	jno .jump6739
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6739:
	imul rdi, [rsp + 0 + 16] ; multiply by Z 
	jno .jump6740
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6740:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6741: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ai'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6742
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6742:
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6743
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6743:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by Y 
	jno .jump6744
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6744:
	imul rdi, [rsp + 0 + 8] ; multiply by ac 
	jno .jump6745
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6745:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ai' to 0
	mov rax, 0
	push rax
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
.jump6746: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -80 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -80 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -80 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 40
	add rax, [rsp + 72]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'ai'
	add qword [rsp + 8], 1
	; Compare ai to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6746 ; If ai < bound, next iter
	mov qword [rsp + 8], 0 ; ai = 0
	add qword [rsp + 0], 1 ; ah++
	; Compare ah to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6746 ; If ah < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6747
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6747:
	cmp rax, [rsp + 16]
	jl .jump6748
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6748:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6749
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6749:
	cmp rax, [rsp + 24]
	jl .jump6750
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6750:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 40
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump6751
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	jmp .jump6752
.jump6751:
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
.jump6752:
	pop rax
	cmp rax, 0
	je .jump6753
	sub rsp, 24
	; Moving 24 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	jmp .jump6754
.jump6753:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump6755
	sub rsp, 24
	; Moving 24 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	jmp .jump6756
.jump6755:
	sub rsp, 24
	; Moving 24 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
.jump6756:
.jump6754:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ak'
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6757
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6757:
	; Computing bound for 'aj'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6758
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6758:
	; Computing bound for 'ai'
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6759
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6759:
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6760
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6760:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by N 
	jno .jump6761
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6761:
	imul rdi, [rsp + 0 + 8] ; multiply by ac 
	jno .jump6762
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6762:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump6763
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6763:
	imul rdi, [rsp + 0 + 24] ; multiply by ag 
	jno .jump6764
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6764:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ak' to 0
	mov rax, 0
	push rax
	; Initialize 'aj' to 0
	mov rax, 0
	push rax
	; Initialize 'ai' to 0
	mov rax, 0
	push rax
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
.jump6765: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'an'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6766
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6766:
	; Computing bound for 'am'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6767
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6767:
	; Computing bound for 'al'
	sub rsp, 8
	; Moving 8 bytes from rbp - -32 to rsp 
		mov r10, [rbp - -32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6768
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6768:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'an' to 0
	mov rax, 0
	push rax
	; Initialize 'am' to 0
	mov rax, 0
	push rax
	; Initialize 'al' to 0
	mov rax, 0
	push rax
.jump6769: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'an'
	add qword [rsp + 16], 1
	; Compare an to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6769 ; If an < bound, next iter
	mov qword [rsp + 16], 0 ; an = 0
	add qword [rsp + 8], 1 ; am++
	; Compare am to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6769 ; If am < bound, next iter
	mov qword [rsp + 8], 0 ; am = 0
	add qword [rsp + 0], 1 ; al++
	; Compare al to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6769 ; If al < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ak'
	add qword [rsp + 24], 1
	; Compare ak to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6765 ; If ak < bound, next iter
	mov qword [rsp + 24], 0 ; ak = 0
	add qword [rsp + 16], 1 ; aj++
	; Compare aj to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6765 ; If aj < bound, next iter
	mov qword [rsp + 16], 0 ; aj = 0
	add qword [rsp + 8], 1 ; ai++
	; Compare ai to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6765 ; If ai < bound, next iter
	mov qword [rsp + 8], 0 ; ai = 0
	add qword [rsp + 0], 1 ; ah++
	; Compare ah to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6765 ; If ah < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	call _L
	add rsp, 40
	add rsp, 24
	add rsp, 40
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ag'
	add qword [rsp + 16], 1
	; Compare ag to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6741 ; If ag < bound, next iter
	mov qword [rsp + 16], 0 ; ag = 0
	add qword [rsp + 8], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6741 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6741 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6770
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6770:
	cmp rax, [rsp + 24]
	jl .jump6771
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6771:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6772
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6772:
	cmp rax, [rsp + 32]
	jl .jump6773
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6773:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6774
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6774:
	cmp rax, [rsp + 40]
	jl .jump6775
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6775:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6776
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6776:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6777
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6777:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by Q 
	jno .jump6778
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6778:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump6779
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6779:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6780: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'af'
	add qword [rsp + 8], 1
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6780 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6780 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _H
	add rsp, 24
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp 
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6781
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6781:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6782
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6782:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump6783
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6783:
	imul rdi, [rsp + 0 + 8] ; multiply by W 
	jno .jump6784
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6784:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6785: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -64 to rsp 
		mov r10, [rbp - -64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'af'
	add qword [rsp + 8], 1
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6785 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6785 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 256 to rsp 
		mov r10, [r12 - 256 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rdi
	call _H
	add rsp, 24
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6786
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6788
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6788:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6789
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6789:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6790
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6790:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6791
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6791:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (w - o) 
	jno .jump6792
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6792:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump6793
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6793:
	imul rdi, [rsp + 0 + 16] ; multiply by o 
	jno .jump6794
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6794:
	imul rdi, [rsp + 0 + 24] ; multiply by (h * Q) 
	jno .jump6795
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6795:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6796: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'al'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6797
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6797:
	; Computing bound for 'ak'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6798
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6798:
	; Computing bound for 'aj'
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6799
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6799:
	; Computing bound for 'ai'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6800
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6800:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by D 
	jno .jump6801
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6801:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump6802
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6802:
	imul rdi, [rsp + 0 + 16] ; multiply by ad 
	jno .jump6803
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6803:
	imul rdi, [rsp + 0 + 24] ; multiply by D 
	jno .jump6804
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6804:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'al' to 0
	mov rax, 0
	push rax
	; Initialize 'ak' to 0
	mov rax, 0
	push rax
	; Initialize 'aj' to 0
	mov rax, 0
	push rax
	; Initialize 'ai' to 0
	mov rax, 0
	push rax
.jump6805: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'al'
	add qword [rsp + 24], 1
	; Compare al to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6805 ; If al < bound, next iter
	mov qword [rsp + 24], 0 ; al = 0
	add qword [rsp + 16], 1 ; ak++
	; Compare ak to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6805 ; If ak < bound, next iter
	mov qword [rsp + 16], 0 ; ak = 0
	add qword [rsp + 8], 1 ; aj++
	; Compare aj to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6805 ; If aj < bound, next iter
	mov qword [rsp + 8], 0 ; aj = 0
	add qword [rsp + 0], 1 ; ai++
	; Compare ai to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6805 ; If ai < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'ah'
	add qword [rsp + 24], 1
	; Compare ah to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6796 ; If ah < bound, next iter
	mov qword [rsp + 24], 0 ; ah = 0
	add qword [rsp + 16], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6796 ; If ag < bound, next iter
	mov qword [rsp + 16], 0 ; ag = 0
	add qword [rsp + 8], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6796 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6796 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	jmp .jump6787
.jump6786:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6806
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6806:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,][,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump6807
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6807:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6808: ; Begin body of loop
	; Compute loop body
	sub rsp, 40
	; Moving 40 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -80 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -80 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -80 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 40
	add rax, [rsp + 56]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'ae'
	add qword [rsp + 0], 1
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6808 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6809
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6809:
	cmp rax, [rsp + 8]
	jl .jump6810
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6810:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump6787:
	sub rsp, 24
	; Moving 24 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6811
	mov rax, [rel const505] ; 21
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6813
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump6814
.jump6813:
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6815
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump6816
.jump6815:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6817
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6817:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from rbp - -96 to rsp 
		mov r10, [rbp - -96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6818
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6818:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6819
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6819:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from rbp - -64 to rsp 
		mov r10, [rbp - -64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6820
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6820:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by T 
	jno .jump6821
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6821:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump6822
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6822:
	imul rdi, [rsp + 0 + 16] ; multiply by X 
	jno .jump6823
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6823:
	imul rdi, [rsp + 0 + 24] ; multiply by C 
	jno .jump6824
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6824:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6825: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const301] ; 207
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ah'
	add qword [rsp + 24], 1
	; Compare ah to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6825 ; If ah < bound, next iter
	mov qword [rsp + 24], 0 ; ah = 0
	add qword [rsp + 16], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6825 ; If ag < bound, next iter
	mov qword [rsp + 16], 0 ; ag = 0
	add qword [rsp + 8], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6825 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6825 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
.jump6816:
.jump6814:
	jmp .jump6812
.jump6811:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6826
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6826:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6827
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6827:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6828
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6828:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6829
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6829:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by Y 
	jno .jump6830
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6830:
	imul rdi, [rsp + 0 + 8] ; multiply by G 
	jno .jump6831
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6831:
	imul rdi, [rsp + 0 + 16] ; multiply by r 
	jno .jump6832
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6832:
	imul rdi, [rsp + 0 + 24] ; multiply by n 
	jno .jump6833
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6833:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6834: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ah'
	add qword [rsp + 24], 1
	; Compare ah to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6834 ; If ah < bound, next iter
	mov qword [rsp + 24], 0 ; ah = 0
	add qword [rsp + 16], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6834 ; If ag < bound, next iter
	mov qword [rsp + 16], 0 ; ag = 0
	add qword [rsp + 8], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6834 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6834 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6835
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6835:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6836
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6836:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6837
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6837:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6838
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6838:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump6839
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6839:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump6840
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6840:
	imul rdi, [rsp + 0 + 16] ; multiply by C 
	jno .jump6841
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6841:
	imul rdi, [rsp + 0 + 24] ; multiply by x 
	jno .jump6842
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6842:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6843: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ah'
	add qword [rsp + 24], 1
	; Compare ah to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6843 ; If ah < bound, next iter
	mov qword [rsp + 24], 0 ; ah = 0
	add qword [rsp + 16], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6843 ; If ag < bound, next iter
	mov qword [rsp + 16], 0 ; ag = 0
	add qword [rsp + 8], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6843 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6843 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rdi, 160
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 160 bytes from rsp to rax 
		mov r10, [rsp + 152]
		mov [rax + 152], r10
		mov r10, [rsp + 144]
		mov [rax + 144], r10
		mov r10, [rsp + 136]
		mov [rax + 136], r10
		mov r10, [rsp + 128]
		mov [rax + 128], r10
		mov r10, [rsp + 120]
		mov [rax + 120], r10
		mov r10, [rsp + 112]
		mov [rax + 112], r10
		mov r10, [rsp + 104]
		mov [rax + 104], r10
		mov r10, [rsp + 96]
		mov [rax + 96], r10
		mov r10, [rsp + 88]
		mov [rax + 88], r10
		mov r10, [rsp + 80]
		mov [rax + 80], r10
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 160
	push rax
	mov rax, 4
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6844
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6844:
	cmp rax, [rsp + 8]
	jl .jump6845
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6845:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 40
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump6812:
	call _L
	add rsp, 40
	add rsp, 24
	add rsp, 40
	push rax
	call _J
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6846
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6848
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6848:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by N 
	jno .jump6849
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6849:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6850: ; Begin body of loop
	; Compute loop body
	call _J
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ae'
	add qword [rsp + 0], 1
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6850 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump6847
.jump6846:
	sub rsp, 8 ; Add alignment
	call _J
	add rsp, 8 ; Remove alignment
	push rax
	call _J
	push rax
	sub rsp, 8 ; Add alignment
	call _J
	add rsp, 8 ; Remove alignment
	push rax
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
.jump6847:
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6851
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6851:
	cmp rax, [rsp + 8]
	jl .jump6852
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6852:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6853
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6853:
	cmp rax, [rsp + 8]
	jl .jump6854
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6854:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
.jump6557:
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6855
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6855:
	cmp rax, [rsp + 8]
	jl .jump6856
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6856:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add rsp, 40 ; Local variables
	pop rbp
	ret
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6857
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6857:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,][,] 
	imul rdi, [rsp + 0 + 0] ; multiply by Q 
	jno .jump6858
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6858:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6859: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6860
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6860:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,][,] 
	imul rdi, [rsp + 0 + 0] ; multiply by O 
	jno .jump6861
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6861:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'af' to 0
	mov rax, 0
	push rax
.jump6862: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6863
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6863:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6864
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6864:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by Y 
	jno .jump6865
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6865:
	imul rdi, [rsp + 0 + 8] ; multiply by Z 
	jno .jump6866
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6866:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
.jump6867: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aj'
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6868
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6868:
	; Computing bound for 'ai'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6869
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6869:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by ab 
	jno .jump6870
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6870:
	imul rdi, [rsp + 0 + 8] ; multiply by S 
	jno .jump6871
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6871:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'aj' to 0
	mov rax, 0
	push rax
	; Initialize 'ai' to 0
	mov rax, 0
	push rax
.jump6872: ; Begin body of loop
	; Compute loop body
	call _J
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'aj'
	add qword [rsp + 8], 1
	; Compare aj to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6872 ; If aj < bound, next iter
	mov qword [rsp + 8], 0 ; aj = 0
	add qword [rsp + 0], 1 ; ai++
	; Compare ai to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6872 ; If ai < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'ah'
	add qword [rsp + 8], 1
	; Compare ah to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6867 ; If ah < bound, next iter
	mov qword [rsp + 8], 0 ; ah = 0
	add qword [rsp + 0], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6867 ; If ag < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'af'
	add qword [rsp + 0], 1
	; Compare af to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6862 ; If af < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6873
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6873:
	cmp rax, [rsp + 8]
	jl .jump6874
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6874:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'ae'
	add qword [rsp + 0], 1
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6859 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6875
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6875:
	cmp rax, [rsp + 8]
	jl .jump6876
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6876:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ah'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6877
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6877:
	; Computing bound for 'ae'
	mov rax, [rel const831] ; 27.06
	push rax
	sub rsp, 8 ; Add alignment
	mov rax, [rel const832] ; 16.33
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6878
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	jmp .jump6879
.jump6878:
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
.jump6879:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6880
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6880:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if ((c % 16.33) <= 27.06) then n else v) 
	jno .jump6881
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6881:
	imul rdi, [rsp + 0 + 8] ; multiply by Z 
	jno .jump6882
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6882:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6883: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'af'
	add qword [rsp + 8], 1
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6883 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6883 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp 
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6884
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6884:
	cmp rax, [rsp + 16]
	jl .jump6885
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6885:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6886
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6886:
	cmp rax, [rsp + 24]
	jl .jump6887
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6887:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6888
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6888:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6889
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6889:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6890
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6890:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6891
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6891:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump6892
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6892:
	imul rdi, [rsp + 0 + 8] ; multiply by S 
	jno .jump6893
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6893:
	imul rdi, [rsp + 0 + 16] ; multiply by G 
	jno .jump6894
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6894:
imul rdi, [rsp + 0 + 24] ; multiply by (array[ae : (if ((c % 16.33) <= 27.06) then n else v), af : Z] w)[ac, r] 
	jno .jump6895
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6895:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6896: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump6897
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ak'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump6899
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump6900
.jump6899:
	sub rsp, 40
	; Moving 40 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump6900:
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6901
	sub rsp, 8
	; Moving 8 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	jmp .jump6902
.jump6901:
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
.jump6902:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6903
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6903:
	cmp rax, [rsp + 32]
	jl .jump6904
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6904:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6905
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6905:
	cmp rax, [rsp + 40]
	jl .jump6906
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6906:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6907
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6907:
	cmp rax, [rsp + 48]
	jl .jump6908
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6908:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump6909
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6909:
	cmp rax, [rsp + 56]
	jl .jump6910
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6910:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6911
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6911:
	; Computing bound for 'aj'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6912
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6912:
	; Computing bound for 'ai'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ak'
	sub rsp, 8
	; Moving 8 bytes from rbp - -64 to rsp 
		mov r10, [rbp - -64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6913
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6913:
	; Computing bound for 'aj'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6914
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6914:
	; Computing bound for 'ai'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6915
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6915:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by ae 
	jno .jump6916
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6916:
	imul rdi, [rsp + 0 + 8] ; multiply by N 
	jno .jump6917
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6917:
	imul rdi, [rsp + 0 + 16] ; multiply by T 
	jno .jump6918
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6918:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ak' to 0
	mov rax, 0
	push rax
	; Initialize 'aj' to 0
	mov rax, 0
	push rax
	; Initialize 'ai' to 0
	mov rax, 0
	push rax
.jump6919: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ak'
	add qword [rsp + 16], 1
	; Compare ak to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6919 ; If ak < bound, next iter
	mov qword [rsp + 16], 0 ; ak = 0
	add qword [rsp + 8], 1 ; aj++
	; Compare aj to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6919 ; If aj < bound, next iter
	mov qword [rsp + 8], 0 ; aj = 0
	add qword [rsp + 0], 1 ; ai++
	; Compare ai to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6919 ; If ai < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -96 to rsp 
		mov r10, [rbp - -96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -64 to rsp 
		mov r10, [rbp - -64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6920
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6920:
	cmp rax, [rsp + 24]
	jl .jump6921
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6921:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6922
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6922:
	cmp rax, [rsp + 32]
	jl .jump6923
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6923:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6924
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump6924:
	cmp rax, [rsp + 40]
	jl .jump6925
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump6925:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6926
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6926:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (array[ai : ae, aj : N, ak : T] m)[T, af, X] 
	jno .jump6927
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6927:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump6928
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6928:
	imul rdi, [rsp + 0 + 16] ; multiply by (if false then M else M)[(if z then V else af), ad, f, G] 
	jno .jump6929
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6929:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ak' to 0
	mov rax, 0
	push rax
	; Initialize 'aj' to 0
	mov rax, 0
	push rax
	; Initialize 'ai' to 0
	mov rax, 0
	push rax
.jump6930: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ao'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6931
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6931:
	; Computing bound for 'an'
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6932
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	jmp .jump6933
.jump6932:
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
.jump6933:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6934
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6934:
	; Computing bound for 'am'
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6935
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6935:
	; Computing bound for 'al'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6936
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6936:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump6937
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6937:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump6938
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6938:
	imul rdi, [rsp + 0 + 16] ; multiply by (if z then aj else ai) 
	jno .jump6939
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6939:
	imul rdi, [rsp + 0 + 24] ; multiply by C 
	jno .jump6940
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6940:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ao' to 0
	mov rax, 0
	push rax
	; Initialize 'an' to 0
	mov rax, 0
	push rax
	; Initialize 'am' to 0
	mov rax, 0
	push rax
	; Initialize 'al' to 0
	mov rax, 0
	push rax
.jump6941: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ao'
	add qword [rsp + 24], 1
	; Compare ao to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6941 ; If ao < bound, next iter
	mov qword [rsp + 24], 0 ; ao = 0
	add qword [rsp + 16], 1 ; an++
	; Compare an to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6941 ; If an < bound, next iter
	mov qword [rsp + 16], 0 ; an = 0
	add qword [rsp + 8], 1 ; am++
	; Compare am to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6941 ; If am < bound, next iter
	mov qword [rsp + 8], 0 ; am = 0
	add qword [rsp + 0], 1 ; al++
	; Compare al to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6941 ; If al < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'ak'
	add qword [rsp + 16], 1
	; Compare ak to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6930 ; If ak < bound, next iter
	mov qword [rsp + 16], 0 ; ak = 0
	add qword [rsp + 8], 1 ; aj++
	; Compare aj to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6930 ; If aj < bound, next iter
	mov qword [rsp + 8], 0 ; aj = 0
	add qword [rsp + 0], 1 ; ai++
	; Compare ai to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6930 ; If ai < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump6898
.jump6897:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ak'
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp 
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6942
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6942:
	; Computing bound for 'aj'
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6943
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6943:
	; Computing bound for 'ai'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6944
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6944:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof bool[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by ab 
	jno .jump6945
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6945:
	imul rdi, [rsp + 0 + 8] ; multiply by S 
	jno .jump6946
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6946:
	imul rdi, [rsp + 0 + 16] ; multiply by O 
	jno .jump6947
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6947:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'ak' to 0
	mov rax, 0
	push rax
	; Initialize 'aj' to 0
	mov rax, 0
	push rax
	; Initialize 'ai' to 0
	mov rax, 0
	push rax
.jump6948: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ao'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6949
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6949:
	; Computing bound for 'an'
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6950
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6950:
	; Computing bound for 'am'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6951
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6951:
	; Computing bound for 'al'
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp 
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6952
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6952:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by N 
	jno .jump6953
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6953:
	imul rdi, [rsp + 0 + 8] ; multiply by (- y) 
	jno .jump6954
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6954:
	imul rdi, [rsp + 0 + 16] ; multiply by Q 
	jno .jump6955
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6955:
	imul rdi, [rsp + 0 + 24] ; multiply by f 
	jno .jump6956
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6956:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ao' to 0
	mov rax, 0
	push rax
	; Initialize 'an' to 0
	mov rax, 0
	push rax
	; Initialize 'am' to 0
	mov rax, 0
	push rax
	; Initialize 'al' to 0
	mov rax, 0
	push rax
.jump6957: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ao'
	add qword [rsp + 24], 1
	; Compare ao to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6957 ; If ao < bound, next iter
	mov qword [rsp + 24], 0 ; ao = 0
	add qword [rsp + 16], 1 ; an++
	; Compare an to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6957 ; If an < bound, next iter
	mov qword [rsp + 16], 0 ; an = 0
	add qword [rsp + 8], 1 ; am++
	; Compare am to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6957 ; If am < bound, next iter
	mov qword [rsp + 8], 0 ; am = 0
	add qword [rsp + 0], 1 ; al++
	; Compare al to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6957 ; If al < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'ak'
	add qword [rsp + 16], 1
	; Compare ak to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump6948 ; If ak < bound, next iter
	mov qword [rsp + 16], 0 ; ak = 0
	add qword [rsp + 8], 1 ; aj++
	; Compare aj to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump6948 ; If aj < bound, next iter
	mov qword [rsp + 8], 0 ; aj = 0
	add qword [rsp + 0], 1 ; ai++
	; Compare ai to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump6948 ; If ai < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump6898:
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6958
	sub rsp, 8
	; Moving 8 bytes from r12 - 96 to rsp 
		mov r10, [r12 - 96 + 0]
		mov [rsp + 0], r10
	jmp .jump6959
.jump6958:
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
.jump6959:
	sub rsp, 8
	; Moving 8 bytes from rbp - -96 to rsp 
		mov r10, [rbp - -96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump6960
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6960:
	cmp rax, [rsp + 24]
	jl .jump6961
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6961:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump6962
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6962:
	cmp rax, [rsp + 32]
	jl .jump6963
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6963:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump6964
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6964:
	cmp rax, [rsp + 40]
	jl .jump6965
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6965:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, [rsp + 96] ; No overflow if indices in bounds
	add rax, [rsp + 64]
	imul rax, 40
	add rax, [rsp + 104]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'ah'
	add qword [rsp + 24], 1
	; Compare ah to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6896 ; If ah < bound, next iter
	mov qword [rsp + 24], 0 ; ah = 0
	add qword [rsp + 16], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6896 ; If ag < bound, next iter
	mov qword [rsp + 16], 0 ; ag = 0
	add qword [rsp + 8], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6896 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6896 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 24
	; Moving 24 bytes from rbp - -56 to rsp 
		mov r10, [rbp - -56 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ah'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6966
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6966:
	; Computing bound for 'ag'
	sub rsp, 8
	; Moving 8 bytes from rbp - -104 to rsp 
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6967
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6967:
	; Computing bound for 'af'
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6968
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6968:
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 184 to rsp 
		mov r10, [r12 - 184 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6969
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6969:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (x + C) 
	jno .jump6970
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6970:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump6971
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6971:
	imul rdi, [rsp + 0 + 16] ; multiply by Y 
	jno .jump6972
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6972:
	imul rdi, [rsp + 0 + 24] ; multiply by n 
	jno .jump6973
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6973:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'ah' to 0
	mov rax, 0
	push rax
	; Initialize 'ag' to 0
	mov rax, 0
	push rax
	; Initialize 'af' to 0
	mov rax, 0
	push rax
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6974: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp 
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'ah'
	add qword [rsp + 24], 1
	; Compare ah to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump6974 ; If ah < bound, next iter
	mov qword [rsp + 24], 0 ; ah = 0
	add qword [rsp + 16], 1 ; ag++
	; Compare ag to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump6974 ; If ag < bound, next iter
	mov qword [rsp + 16], 0 ; ag = 0
	add qword [rsp + 8], 1 ; af++
	; Compare af to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump6974 ; If af < bound, next iter
	mov qword [rsp + 8], 0 ; af = 0
	add qword [rsp + 0], 1 ; ae++
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump6974 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	call _L
	add rsp, 40
	add rsp, 24
	add rsp, 40
	push rax
	call _d
	add rsp, 8
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	jne .jump6975
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const833] ; 'ae'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6975:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ae'
	sub rsp, 8
	; Moving 8 bytes from rbp - -64 to rsp 
		mov r10, [rbp - -64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 224 to rsp 
		mov r10, [r12 - 224 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump6976
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump6976:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6977
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6977:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[] 
	imul rdi, [rsp + 0 + 0] ; multiply by (C / T) 
	jno .jump6978
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6978:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'ae' to 0
	mov rax, 0
	push rax
.jump6979: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 32]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'ae'
	add qword [rsp + 0], 1
	; Compare ae to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump6979 ; If ae < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 40
	; Moving 40 bytes from rbp - -80 to rsp 
		mov r10, [rbp - -80 + 32]
		mov [rsp + 32], r10
		mov r10, [rbp - -80 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -80 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -80 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10

N:
_N:
	push rbp
	mov rbp, rsp
	push rdi
	push rsi
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump6980
	lea rdi, [rel const808] ; 'Q'
	call _fail_assertion
.jump6980:
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp 
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const834] ; 47.7
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Add alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6981
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6983
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6983:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6984
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6984:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by y 
	jno .jump6985
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6985:
	imul rdi, [rsp + 0 + 8] ; multiply by B 
	jno .jump6986
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6986:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump6987: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'R'
	add qword [rsp + 8], 1
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6987 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6987 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump6982
.jump6981:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'R'
	mov rax, [rel const835] ; 752
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6988
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump6988:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6989
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6989:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump6990
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6990:
	imul rdi, [rsp + 0 + 8] ; multiply by 752 
	jno .jump6991
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump6991:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump6992: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'R'
	add qword [rsp + 8], 1
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump6992 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump6992 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump6982:
	sub rsp, 8
	; Moving 8 bytes from r12 - 152 to rsp 
		mov r10, [r12 - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6993
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump6993:
	push rax
	pop rdi
	call _H
	add rsp, 24
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump6994
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump6996
	sub rsp, 32
	lea rdi, [rsp + 0]
	call _I
	jmp .jump6997
.jump6996:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6998
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6998:
	; Computing bound for 'R'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6999
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6999:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump7000: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 176 to rsp 
		mov r10, [r12 - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'Q'
	add qword [rsp + 0], 1
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7000 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7001
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7001:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 264 to rsp 
		mov r10, [r12 - 264 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump7002
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	jmp .jump7003
.jump7002:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7004
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7004:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump7005
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7005:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump7006: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'Q'
	add qword [rsp + 0], 1
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7006 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump7003:
	sub rsp, 8
	; Moving 8 bytes from r12 - 104 to rsp 
		mov r10, [r12 - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7007
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump7007:
	cmp rax, [rsp + 8]
	jl .jump7008
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump7008:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7009
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump7009:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (if (! M) then [m] else (array[Q : m] q))[n] 
	jno .jump7010
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump7010:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[Q : m] v) 
	jno .jump7011
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump7011:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump7012
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump7012:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump7013: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7014
	mov rax, [rel const26] ; False
	push rax
	jmp .jump7015
.jump7014:
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump7016
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump7016:
	push rax
.jump7015:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'S'
	add qword [rsp + 16], 1
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7013 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7013 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7013 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump6997:
	sub rsp, 32
	lea rdi, [rsp + 0]
	call _I
	mov rdi, 64
	call _jpl_alloc
	; Moving 64 bytes from rsp to rax 
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 64
	push rax
	mov rax, 2
	push rax
	jmp .jump6995
.jump6994:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	mov rax, [rel const665] ; 338
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7017
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump7017:
	; Computing bound for 'R'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7018
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump7018:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 256 to rsp 
		mov r10, [r12 - 256 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7019
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7019:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7020
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump7020:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump7021: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'S'
	add qword [rsp + 16], 1
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7021 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7021 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7021 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7022
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7022:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from r12 - 56 to rsp 
		mov r10, [r12 - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7023
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump7023:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[,,][] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- (- (G + h))) 
	jno .jump7024
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump7024:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[Q : G, R : K, S : D] h) 
	jno .jump7025
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump7025:
	imul rdi, [rsp + 0 + 16] ; multiply by 338 
	jno .jump7026
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump7026:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump7027: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7028
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7028:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- R) 
	jno .jump7029
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7029:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump7030: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7031
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump7031:
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7032
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7032:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7033
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump7033:
	; Computing bound for 'U'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from r12 - 168 to rsp 
		mov r10, [r12 - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7034
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump7034:
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7035
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7035:
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from r12 - 256 to rsp 
		mov r10, [r12 - 256 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7036
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump7036:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from r12 - 248 to rsp 
		mov r10, [r12 - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7037
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7037:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'X' to 0
	mov rax, 0
	push rax
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
.jump7038: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'X'
	add qword [rsp + 24], 1
	; Compare X to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7038 ; If X < bound, next iter
	mov qword [rsp + 24], 0 ; X = 0
	add qword [rsp + 16], 1 ; W++
	; Compare W to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7038 ; If W < bound, next iter
	mov qword [rsp + 16], 0 ; W = 0
	add qword [rsp + 8], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7038 ; If V < bound, next iter
	mov qword [rsp + 8], 0 ; V = 0
	add qword [rsp + 0], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7038 ; If U < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7039
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7039:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[U : G, V : K, W : R, X : w] Q) 
	jno .jump7040
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7040:
	imul rdi, [rsp + 0 + 8] ; multiply by r 
	jno .jump7041
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7041:
	imul rdi, [rsp + 0 + 16] ; multiply by f 
	jno .jump7042
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7042:
	imul rdi, [rsp + 0 + 24] ; multiply by T 
	jno .jump7043
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7043:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'X' to 0
	mov rax, 0
	push rax
	; Initialize 'W' to 0
	mov rax, 0
	push rax
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
.jump7044: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'aa'
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7045
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7045:
	; Computing bound for 'Z'
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7046
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump7046:
	; Computing bound for 'Y'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7047
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7047:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by B 
	jno .jump7048
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7048:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump7049
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7049:
	imul rdi, [rsp + 0 + 16] ; multiply by r 
	jno .jump7050
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7050:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'aa' to 0
	mov rax, 0
	push rax
	; Initialize 'Z' to 0
	mov rax, 0
	push rax
	; Initialize 'Y' to 0
	mov rax, 0
	push rax
.jump7051: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp 
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'aa'
	add qword [rsp + 16], 1
	; Compare aa to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7051 ; If aa < bound, next iter
	mov qword [rsp + 16], 0 ; aa = 0
	add qword [rsp + 8], 1 ; Z++
	; Compare Z to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7051 ; If Z < bound, next iter
	mov qword [rsp + 8], 0 ; Z = 0
	add qword [rsp + 0], 1 ; Y++
	; Compare Y to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7051 ; If Y < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'X'
	add qword [rsp + 24], 1
	; Compare X to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump7044 ; If X < bound, next iter
	mov qword [rsp + 24], 0 ; X = 0
	add qword [rsp + 16], 1 ; W++
	; Compare W to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump7044 ; If W < bound, next iter
	mov qword [rsp + 16], 0 ; W = 0
	add qword [rsp + 8], 1 ; V++
	; Compare V to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump7044 ; If V < bound, next iter
	mov qword [rsp + 8], 0 ; V = 0
	add qword [rsp + 0], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump7044 ; If U < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 128 to rsp 
		mov r10, [r12 - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 136 to rsp 
		mov r10, [r12 - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 256 to rsp 
		mov r10, [r12 - 256 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7052
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7052:
	cmp rax, [rsp + 32]
	jl .jump7053
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7053:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7054
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7054:
	cmp rax, [rsp + 40]
	jl .jump7055
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7055:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump7056
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7056:
	cmp rax, [rsp + 48]
	jl .jump7057
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7057:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump7058
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7058:
	cmp rax, [rsp + 56]
	jl .jump7059
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7059:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'T'
	add qword [rsp + 0], 1
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump7030 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'S'
	add qword [rsp + 16], 1
	; Compare S to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7027 ; If S < bound, next iter
	mov qword [rsp + 16], 0 ; S = 0
	add qword [rsp + 8], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7027 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7027 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const836] ; 381
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from r12 - 232 to rsp 
		mov r10, [r12 - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7060
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump7060:
	; Computing bound for 'Q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp 
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7061
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7061:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'R' to 0
	mov rax, 0
	push rax
	; Initialize 'Q' to 0
	mov rax, 0
	push rax
.jump7062: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'R'
	add qword [rsp + 8], 1
	; Compare R to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7062 ; If R < bound, next iter
	mov qword [rsp + 8], 0 ; R = 0
	add qword [rsp + 0], 1 ; Q++
	; Compare Q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7062 ; If Q < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7063
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7063:
	cmp rax, [rsp + 24]
	jl .jump7064
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7064:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7065
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7065:
	cmp rax, [rsp + 32]
	jl .jump7066
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7066:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump7067
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7067:
	cmp rax, [rsp + 40]
	jl .jump7068
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7068:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump6995:
	sub rsp, 8
	; Moving 8 bytes from r12 - 192 to rsp 
		mov r10, [r12 - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7069
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7069:
	cmp rax, [rsp + 8]
	jl .jump7070
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7070:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 200 to rsp 
		mov r10, [r12 - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7071
	sub rsp, 32
	; Moving 32 bytes from rbp - 48 to rsp 
		mov r10, [rbp - 48 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	jmp .jump7072
.jump7071:
	sub rsp, 32
	lea rdi, [rsp + 0]
	call _I
.jump7072:
	sub rsp, 16
	; Moving 16 bytes from r12 - 40 to rsp 
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'ac'
	sub rsp, 8
	; Moving 8 bytes from r12 - 216 to rsp 
		mov r10, [r12 - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7073
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7073:
	; Computing bound for 'ab'
	sub rsp, 8
	; Moving 8 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7074
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump7074:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump7075
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump7075:
	imul rdi, [rsp + 0 + 8] ; multiply by D 
	jno .jump7076
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump7076:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'ac' to 0
	mov rax, 0
	push rax
	; Initialize 'ab' to 0
	mov rax, 0
	push rax
.jump7077: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from r12 - 144 to rsp 
		mov r10, [r12 - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'ac'
	add qword [rsp + 8], 1
	; Compare ac to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7077 ; If ac < bound, next iter
	mov qword [rsp + 8], 0 ; ac = 0
	add qword [rsp + 0], 1 ; ab++
	; Compare ab to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7077 ; If ab < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 32
	; Moving 32 bytes from r12 - 112 to rsp 
		mov r10, [r12 - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 112 + 0]
		mov [rsp + 0], r10
	add rsp, 160 ; Local variables
	pop rbp
	ret

jpl_main:
_jpl_main:
	push rbp
	mov rbp, rsp
	push r12
	mov r12, rbp ; end of jpl_main prelude
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const0] ; 680
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1:
	; Computing bound for 'c'
	mov rax, [rel const0] ; 680
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2:
	; Computing bound for 'b'
	mov rax, [rel const2] ; 886
	push rax
	mov rax, [rel const3] ; 701
	push rax
	mov rax, [rel const4] ; 641
	push rax
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	mov rax, [rel const5] ; 883
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump3
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3:
	cmp rax, [rsp + 8]
	jl .jump4
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const8] ; 262
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5:
	; Computing bound for 'a'
	mov rax, [rel const9] ; 294
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump6
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump6:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 294 
	jno .jump7
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump7:
	imul rdi, [rsp + 0 + 8] ; multiply by (- (262 - [641, 701, 886][883])) 
	jno .jump8
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump8:
	imul rdi, [rsp + 0 + 16] ; multiply by 680 
	jno .jump9
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump9:
	imul rdi, [rsp + 0 + 24] ; multiply by 680 
	jno .jump10
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump10:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump11: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump12
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump14
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump14:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump15
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump15:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump16
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump16:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump17
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump17:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump18: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const12] ; 11.87
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump18 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump18 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump18 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump18 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	jmp .jump13
.jump12:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump19
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump19:
	; Computing bound for 'f'
	mov rax, [rel const13] ; 183
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump20
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump20:
	; Computing bound for 'e'
	mov rax, [rel const14] ; 573
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump21
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump21:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump22: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const15] ; 97.96
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump22 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump22 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump22 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump13:
	mov rax, [rel const16] ; 21.09
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump11 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump11 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump11 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump11 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const17] ; 591
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump23
	mov rax, [rel const18] ; 160
	push rax
	jmp .jump24
.jump23:
	mov rax, [rel const19] ; 755
	push rax
.jump24:
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump25
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump25:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump26
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump26:
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const21] ; 766
	push rax
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	mov rax, [rel const22] ; 172
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump27
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump27:
	cmp rax, [rsp + 8]
	jl .jump28
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump28:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump29
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump29:
	; Computing bound for 'b'
	mov rax, [rel const23] ; 503
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump30
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump30:
	; Computing bound for 'a'
	mov rax, [rel const24] ; 30
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump31
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump31:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump32: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const25] ; 569
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump32 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump32 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump32 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump33
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump33:
	; Computing bound for 'b'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump34
	mov rax, [rel const27] ; 578
	push rax
	mov rax, [rel const28] ; 346
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump36
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump36:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump35
.jump34:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const29] ; 201
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump37
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump37:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 201 
	jno .jump38
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump38:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump39: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump39 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const30] ; 153
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump40
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump40:
	cmp rax, [rsp + 8]
	jl .jump41
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump41:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump35:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump42
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump42:
	; Computing bound for 'a'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump43
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const31] ; 891
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump45
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump45:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump46: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump46 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump44
.jump43:
	mov rax, [rel const32] ; 438
	push rax
	mov rax, [rel const33] ; 892
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
.jump44:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump47
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump47:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (if true then (sum[a : 891] a) else (892 + 438)) 
	jno .jump48
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump48:
imul rdi, [rsp + 0 + 8] ; multiply by (if false then (- (346 / 578)) else (array[a : 201] a)[(- 153)]) 
	jno .jump49
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump49:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[a : (- 30), b : 503, c : [766][172]] 569) 
	jno .jump50
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump50:
	imul rdi, [rsp + 0 + 24] ; multiply by ((- (if true then 160 else 755)) / (- 591)) 
	jno .jump51
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump51:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump52: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const34] ; 59.27
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump53
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump53:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump54
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump54:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump55
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump55:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump56
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump56:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump57: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const35] ; 69.15
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump57 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump57 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump57 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump57 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump58
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	jmp .jump59
.jump58:
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
.jump59:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump52 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump52 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump52 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump52 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const36] ; 406
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump60
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump60:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump61: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump61 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const37] ; 994
	push rax
	mov rax, [rel const38] ; 726
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump62
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump62:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump63
	mov rax, [rel const26] ; False
	push rax
	jmp .jump64
.jump63:
	mov rax, [rel const26] ; False
	push rax
.jump64:
	pop rax
	cmp rax, 0
	je .jump65
	mov rax, [rel const40] ; 714
	push rax
	jmp .jump66
.jump65:
	mov rax, [rel const41] ; 587
	push rax
.jump66:
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump67
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump67:
	cqo
	idiv r10
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const42] ; 858
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump68
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump68:
	; Computing bound for 'a'
	mov rax, [rel const43] ; 324
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump69
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump69:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 324 
	jno .jump70
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump70:
	imul rdi, [rsp + 0 + 8] ; multiply by 858 
	jno .jump71
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump71:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump72: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump72 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump72 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const44] ; 6
	push rax
	mov rax, [rel const45] ; 453
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump73
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump73:
	cmp rax, [rsp + 16]
	jl .jump74
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump74:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump75
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump75:
	cmp rax, [rsp + 24]
	jl .jump76
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump76:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const46] ; 623
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump77
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump78
	mov rax, [rel const11] ; True
	push rax
	pop rax
.jump78:
	push rax
	pop rax
.jump77:
	push rax
	pop rax
	cmp rax, 0
	je .jump79
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const47] ; 173
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump81
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump81:
	; Computing bound for 'a'
	mov rax, [rel const48] ; 812
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump82
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump82:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump83: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump83 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump83 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	jmp .jump80
.jump79:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump84
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const49] ; 384
	push rax
	mov rax, [rel const50] ; 993
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump86
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump86:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump87
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump87:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump88: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump88 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump85
.jump84:
	mov rax, [rel const51] ; 191
	push rax
.jump85:
.jump80:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const52] ; 804
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump89
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump89:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump90: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump90 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rel const53] ; 144
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump91
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump91:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rel const54] ; 728
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump92
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump92:
	cqo
	idiv r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump93
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump93:
	cmp rax, [rsp + 32]
	jl .jump94
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump94:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump95
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump95:
	cmp rax, [rsp + 40]
	jl .jump96
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump96:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump97
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump97:
	cmp rax, [rsp + 48]
	jl .jump98
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump98:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump99
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump99:
	cmp rax, [rsp + 56]
	jl .jump100
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump100:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const55] ; 622
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const56] ; 408
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const57] ; 925
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump101
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump101:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 925 
	jno .jump102
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump102:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump103: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const58] ; 35
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump103 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const59] ; 305
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump104
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump104:
	cmp rax, [rsp + 8]
	jl .jump105
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump105:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const60] ; 837
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump106
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump106:
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const61] ; 604
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump107
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump107:
	; Computing bound for 'b'
	mov rax, [rel const62] ; 494
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump108
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump108:
	; Computing bound for 'a'
	mov rax, [rel const63] ; 266
	push rax
	mov rax, [rel const64] ; 167
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump109
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump109:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump110: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump110 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump110 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump110 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump111
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump111:
	; Computing bound for 'b'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump112
	mov rax, [rel const65] ; 140
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump113
.jump112:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const66] ; 896
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump114
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump114:
	; Computing bound for 'a'
	mov rax, [rel const67] ; 114
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump115
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump115:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump116: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump116 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump116 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump113:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump117
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump117:
	; Computing bound for 'a'
	mov rax, [rel const68] ; 243
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump118
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump118:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 243) 
	jno .jump119
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump119:
imul rdi, [rsp + 0 + 8] ; multiply by (if false then (- 140) else (sum[a : 114, b : 896] a)) 
	jno .jump120
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump120:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[a : (167 + 266), b : 494, c : (- 604)] c) 
	jno .jump121
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump121:
	imul rdi, [rsp + 0 + 24] ; multiply by 837 
	jno .jump122
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump122:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump123: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump124
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump126
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump126:
	; Computing bound for 'f'
	mov rax, [rel const69] ; 921
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump127
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump127:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump128
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump128:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by d 
	jno .jump129
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump129:
	imul rdi, [rsp + 0 + 8] ; multiply by 921 
	jno .jump130
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump130:
	imul rdi, [rsp + 0 + 16] ; multiply by d 
	jno .jump131
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump131:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump132: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump132 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump132 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump132 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump125
.jump124:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump133
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump133:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump134
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump134:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump135
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump135:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by b 
	jno .jump136
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump136:
	imul rdi, [rsp + 0 + 8] ; multiply by c 
	jno .jump137
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump137:
	imul rdi, [rsp + 0 + 16] ; multiply by a 
	jno .jump138
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump138:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump139: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump139 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump139 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump139 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump125:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump123 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump123 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump123 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump123 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const70] ; 657
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump140
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump140:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 657 
	jno .jump141
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump141:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump142: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const71] ; 696
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump142 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const72] ; 512
	push rax
	mov rax, [rel const73] ; 938
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump143
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump143:
	cqo
	idiv r10
	push rax
	mov rax, [rel const74] ; 68
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump144
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump144:
	cmp rax, [rsp + 8]
	jl .jump145
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump145:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const75] ; 237
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump146
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump146:
	; Computing bound for 'a'
	mov rax, [rel const76] ; 282
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump147
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump147:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump148: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const77] ; 630
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump148 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump148 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rel const78] ; 465
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rel const79] ; 97
	push rax
	mov rax, [rel const80] ; 560
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump149
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump149:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const81] ; 312
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump150
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump150:
	; Computing bound for 'c'
	mov rax, [rel const82] ; 421
	push rax
	mov rax, [rel const83] ; 523
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump151
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump151:
	; Computing bound for 'b'
	mov rax, [rel const84] ; 743
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump152
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump152:
	; Computing bound for 'a'
	mov rax, [rel const41] ; 587
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump153
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump153:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump154: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump154 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump154 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump154 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump154 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump155
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump155:
	cmp rax, [rsp + 32]
	jl .jump156
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump156:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump157
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump157:
	cmp rax, [rsp + 40]
	jl .jump158
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump158:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump159
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump159:
	cmp rax, [rsp + 48]
	jl .jump160
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump160:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump161
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump161:
	cmp rax, [rsp + 56]
	jl .jump162
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump162:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const85] ; 259
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump163
	mov rax, [rel const4] ; 641
	push rax
	mov rax, [rel const86] ; 661
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump165
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump165:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump164
.jump163:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const87] ; 343
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump166
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump166:
	; Computing bound for 'a'
	mov rax, [rel const88] ; 599
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump167
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump167:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump168: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const89] ; 269
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump168 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump168 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const90] ; 320
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
.jump164:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump169
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump169:
	cqo
	idiv r10
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const91] ; 543
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump170
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump170:
	; Computing bound for 'c'
	mov rax, [rel const92] ; 44.69
	push rax
	mov rax, [rel const93] ; 2.76
	push rax
	mov rax, [rel const94] ; 85.18
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump171
	mov rax, [rel const95] ; 136
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump172
.jump171:
	mov rax, [rel const96] ; 56
	push rax
	pop rax
	neg rax
	push rax
.jump172:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump173
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump173:
	; Computing bound for 'b'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump174
	mov rax, [rel const97] ; 885
	push rax
	jmp .jump175
.jump174:
	mov rax, [rel const98] ; 27
	push rax
.jump175:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump176
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump176:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump177: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const99] ; 482
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump177 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump178
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump178:
	; Computing bound for 'a'
	mov rax, [rel const100] ; 765
	push rax
	mov rax, [rel const101] ; 597
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump179
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump179:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump180: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump181
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump183
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump183:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump184
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump184:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump185
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump185:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by a 
	jno .jump186
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump186:
	imul rdi, [rsp + 0 + 8] ; multiply by a 
	jno .jump187
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump187:
	imul rdi, [rsp + 0 + 16] ; multiply by b 
	jno .jump188
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump188:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump189: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const102] ; 276
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump189 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump189 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump189 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump182
.jump181:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump190
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump190:
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump191
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump191:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump192
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump192:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by a 
	jno .jump193
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump193:
	imul rdi, [rsp + 0 + 8] ; multiply by b 
	jno .jump194
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump194:
	imul rdi, [rsp + 0 + 16] ; multiply by d 
	jno .jump195
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump195:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump196: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump196 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump196 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump196 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump182:
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump197
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump197:
	cmp rax, [rsp + 24]
	jl .jump198
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump198:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump199
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump199:
	cmp rax, [rsp + 32]
	jl .jump200
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump200:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump201
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump201:
	cmp rax, [rsp + 40]
	jl .jump202
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump202:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump180 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump180 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump180 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump180 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump203
	mov rax, [rel const26] ; False
	push rax
	pop rax
.jump203:
	push rax
	pop rax
	cmp rax, 0
	je .jump204
	mov rax, [rel const103] ; 740
	push rax
	mov rax, [rel const104] ; 103
	push rax
	mov rax, [rel const85] ; 259
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	jmp .jump205
.jump204:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const105] ; 644
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump206
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump206:
	; Computing bound for 'b'
	mov rax, [rel const106] ; 547
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump207
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump207:
	; Computing bound for 'a'
	mov rax, [rel const107] ; 757
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump208
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump208:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 757 
	jno .jump209
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump209:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 547) 
	jno .jump210
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump210:
	imul rdi, [rsp + 0 + 16] ; multiply by 644 
	jno .jump211
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump211:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump212: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const108] ; 724
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump213
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump213:
	; Computing bound for 'd'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump214
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump214:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
.jump215: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 8], 1
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump215 ; If e < bound, next iter
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump215 ; If d < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump212 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump212 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump212 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const109] ; 238
	push rax
	mov rax, [rel const110] ; 194
	push rax
	mov rax, [rel const111] ; 980
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump216
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump216:
	cmp rax, [rsp + 24]
	jl .jump217
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump217:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump218
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump218:
	cmp rax, [rsp + 32]
	jl .jump219
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump219:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump220
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump220:
	cmp rax, [rsp + 40]
	jl .jump221
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump221:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump205:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump222
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump222:
	cmp rax, [rsp + 24]
	jl .jump223
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump223:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump224
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump224:
	cmp rax, [rsp + 32]
	jl .jump225
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump225:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump226
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump226:
	cmp rax, [rsp + 40]
	jl .jump227
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump227:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const112] ; 510
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump228
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump228:
	; Computing bound for 'b'
	mov rax, [rel const113] ; 426
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump229
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump229:
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const9] ; 294
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump230
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump230:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump231: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump231 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump232
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump232:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump233: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump233 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump233 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump233 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const114] ; 899
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump234
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump234:
	cmp rax, [rsp + 32]
	jl .jump235
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump235:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump236
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump236:
	cmp rax, [rsp + 40]
	jl .jump237
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump237:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump238
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump238:
	cmp rax, [rsp + 48]
	jl .jump239
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump239:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump240
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump240:
	cmp rax, [rsp + 56]
	jl .jump241
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump241:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	mov rax, [rel const26] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump242
	mov rax, [rel const115] ; 719
	push rax
	mov rax, [rel const116] ; 586
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const43] ; 324
	push rax
	mov rax, [rel const57] ; 925
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	jmp .jump243
.jump242:
	mov rax, [rel const117] ; 612
	push rax
	mov rax, [rel const118] ; 382
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
.jump243:
	pop rax
	cmp rax, 0
	je .jump244
	mov rax, [rel const119] ; 8.46
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump246
	mov rax, [rel const120] ; 92.5
	push rax
	jmp .jump247
.jump246:
	mov rax, [rel const121] ; 5.07
	push rax
.jump247:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump245
.jump244:
	mov rax, [rel const122] ; 38.47
	push rax
.jump245:
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const123] ; 17.77
	push rax
	mov rax, [rel const124] ; 65.13
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump248
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const125] ; 811
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump250
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump250:
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const126] ; 22
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump251
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump251:
	; Computing bound for 'b'
	mov rax, [rel const127] ; 682
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump252
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump252:
	; Computing bound for 'a'
	mov rax, [rel const128] ; 862
	push rax
	mov rax, [rel const129] ; 593
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump253
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump253:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump254: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump254 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump254 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump254 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump255
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump255:
	; Computing bound for 'b'
	mov rax, [rel const130] ; 532
	push rax
	mov rax, [rel const131] ; 624
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rel const48] ; 812
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump256
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump256:
	; Computing bound for 'a'
	mov rax, [rel const132] ; 517
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump257
	mov rax, [rel const133] ; 677
	push rax
	jmp .jump258
.jump257:
	mov rax, [rel const134] ; 472
	push rax
.jump258:
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump259
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump259:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by ((if true then 677 else 472) + (- 517)) 
	jno .jump260
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump260:
	imul rdi, [rsp + 0 + 8] ; multiply by ((- 812) + (624 * 532)) 
	jno .jump261
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump261:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[a : (593 + 862), b : 682, c : 22] (b + b)) 
	jno .jump262
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump262:
	imul rdi, [rsp + 0 + 24] ; multiply by 811 
	jno .jump263
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump263:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump264: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const135] ; 7.12
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump264 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump264 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump264 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump264 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'd'
	mov rax, [rel const136] ; 764
	push rax
	mov rax, [rel const137] ; 473
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump265
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump265:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump266
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump266:
	; Computing bound for 'c'
	mov rax, [rel const3] ; 701
	push rax
	mov rax, [rel const138] ; 607
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump267
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump267:
	; Computing bound for 'b'
	mov rax, [rel const139] ; 13
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump268
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump268:
	; Computing bound for 'a'
	mov rax, [rel const140] ; 911
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump269
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump269:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump270: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'd'
	add qword [rsp + 24], 1
	; Compare d to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump270 ; If d < bound, next iter
	mov qword [rsp + 24], 0 ; d = 0
	add qword [rsp + 16], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump270 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump270 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump270 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'a'
	mov rax, [rel const141] ; 589
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump271
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump271:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump272: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const142] ; 402
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump272 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump273
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump273:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump274: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const143] ; 162
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump275
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump275:
	; Computing bound for 'd'
	mov rax, [rel const144] ; 91
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump276
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump276:
	; Computing bound for 'c'
	mov rax, [rel const145] ; 640
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump277
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump277:
	; Computing bound for 'b'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump278
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump278:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
	; Initialize 'd' to 0
	mov rax, 0
	push rax
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump279: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 24], 1
	; Compare e to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump279 ; If e < bound, next iter
	mov qword [rsp + 24], 0 ; e = 0
	add qword [rsp + 16], 1 ; d++
	; Compare d to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump279 ; If d < bound, next iter
	mov qword [rsp + 16], 0 ; d = 0
	add qword [rsp + 8], 1 ; c++
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump279 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump279 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump280
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump280:
	; Computing bound for 'b'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump281
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump281:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
.jump282: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 8], 1
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump282 ; If c < bound, next iter
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump282 ; If b < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'a'
	add qword [rsp + 0], 1
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump274 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'b'
	mov rax, [rel const78] ; 465
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump283
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump283:
	; Computing bound for 'a'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'c'
	mov rax, [rel const146] ; 281
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump284
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump284:
	; Computing bound for 'b'
	mov rax, [rel const147] ; 36
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump285
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump285:
	; Computing bound for 'a'
	mov rax, [rel const148] ; 695
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump286
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump286:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'c' to 0
	mov rax, 0
	push rax
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump287: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const149] ; 581
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'c'
	add qword [rsp + 16], 1
	; Compare c to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump287 ; If c < bound, next iter
	mov qword [rsp + 16], 0 ; c = 0
	add qword [rsp + 8], 1 ; b++
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump287 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump287 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump288
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump288:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'b' to 0
	mov rax, 0
	push rax
	; Initialize 'a' to 0
	mov rax, 0
	push rax
.jump289: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'b'
	add qword [rsp + 8], 1
	; Compare b to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump289 ; If b < bound, next iter
	mov qword [rsp + 8], 0 ; b = 0
	add qword [rsp + 0], 1 ; a++
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump289 ; If a < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const150] ; 333
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump290
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump290:
	cmp rax, [rsp + 32]
	jl .jump291
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump291:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump292
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump292:
	cmp rax, [rsp + 40]
	jl .jump293
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump293:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump294
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump294:
	cmp rax, [rsp + 48]
	jl .jump295
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump295:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump296
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump296:
	cmp rax, [rsp + 56]
	jl .jump297
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump297:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump249
.jump248:
	mov rax, [rel const151] ; 17.46
	push rax
	mov rax, [rel const152] ; 81.1
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const153] ; 21.59
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump249:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	mov rax, [rel const26] ; False
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	mov rax, [rel const215] ; 70.14
	push rax
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1687
	mov rax, [rel const462] ; 325
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump1688
.jump1687:
	mov rax, [rel const463] ; 807
	push rax
.jump1688:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1689
	mov rax, [rel const337] ; 296
	push rax
	mov rax, [rel const289] ; 675
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1691
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump1691:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump1690
.jump1689:
	mov rax, [rel const464] ; 344
	push rax
	mov rax, [rel const465] ; 902
	push rax
	mov rax, [rel const466] ; 219
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1692
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1692:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
.jump1690:
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1693
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const350] ; 750
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1695
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1695:
	; Computing bound for 'g'
	mov rax, [rel const467] ; 149
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1696
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1696:
	; Computing bound for 'f'
	mov rax, [rel const391] ; 534
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1697
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1697:
	; Computing bound for 'e'
	mov rax, [rel const468] ; 326
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1698
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1698:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1699: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const469] ; 42.84
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1700
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump1701
.jump1700:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump1701:
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1699 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1699 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1699 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1699 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const470] ; 60.96
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const471] ; 9.16
	push rax
	mov rax, [rel const472] ; 10.44
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump1694
.jump1693:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump1694:
	lea rdi, [rel const473] ; '(BoolType)'
	lea rsi, [rsp]
	call _show
	add rsp, 8
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const457] ; 633
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1702
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1702:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1703: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1703 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1704
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1704:
	; Computing bound for 'e'
	mov rax, [rel const474] ; 400
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1705
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1705:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1706: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1706 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1706 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const274] ; 600
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump1707
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump1708
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const475] ; 88.19
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
.jump1708:
	push rax
	pop rax
.jump1707:
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1709
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1711
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1713
	mov rax, [rel const11] ; True
	push rax
	pop rax
.jump1713:
	push rax
	jmp .jump1712
.jump1711:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump1712:
	pop rax
	cmp rax, 0
	je .jump1714
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const159] ; 683
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1716
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1716:
	; Computing bound for 'e'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1717
	mov rax, [rel const396] ; 316
	push rax
	jmp .jump1718
.jump1717:
	mov rax, [rel const305] ; 249
	push rax
.jump1718:
	mov rax, [rel const476] ; 198
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1719
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1719:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (198 - (if false then 316 else 249)) 
	jno .jump1720
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1720:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 683) 
	jno .jump1721
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1721:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1722: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1722 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1722 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump1715
.jump1714:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const477] ; 721
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const478] ; 440
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1723
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump1723:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1724
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1724:
	; Computing bound for 'e'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const479] ; 224
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1725
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1725:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1726: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const334] ; 568
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1726 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1727
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1727:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[e : 224] 568) 
	jno .jump1728
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1728:
	imul rdi, [rsp + 0 + 8] ; multiply by (440 / (- 721)) 
	jno .jump1729
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1729:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1730: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1730 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1730 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump1715:
	jmp .jump1710
.jump1709:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const40] ; 714
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1731
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1731:
	; Computing bound for 'f'
	mov rax, [rel const480] ; 208
	push rax
	mov rax, [rel const481] ; 800
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1732
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1732:
	; Computing bound for 'e'
	mov rax, [rel const482] ; 556
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1733
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1733:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1734: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1734 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1734 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1734 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const242] ; 354
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1735
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump1735:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1736
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1736:
	; Computing bound for 'e'
	mov rax, [rel const385] ; 504
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1737
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1737:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (- (- 504)) 
	jno .jump1738
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1738:
imul rdi, [rsp + 0 + 8] ; multiply by (354 / (sum[e : 556, f : (800 + 208), g : 714] (- f))) 
	jno .jump1739
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1739:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1740: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const26] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1740 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1740 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump1710:
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1741
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1743
	mov rax, [rel const483] ; 992
	push rax
	mov rax, [rel const387] ; 731
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1745
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump1745:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	jmp .jump1744
.jump1743:
	mov rax, [rel const321] ; 383
	push rax
.jump1744:
	pop rax
	neg rax
	push rax
	jmp .jump1742
.jump1741:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const484] ; 873
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1746
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1746:
	; Computing bound for 'e'
	mov rax, [rel const66] ; 896
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1747
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1747:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1748: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1748 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1748 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
.jump1742:
	pop rax
	neg rax
	push rax
	mov rax, [rel const77] ; 630
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1749
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1749:
	cmp rax, [rsp + 16]
	jl .jump1750
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1750:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1751
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1751:
	cmp rax, [rsp + 24]
	jl .jump1752
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1752:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1753
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1755
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const160] ; 389
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1757
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1757:
	; Computing bound for 'e'
	mov rax, [rel const485] ; 996
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1758
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1758:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 996) 
	jno .jump1759
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1759:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 389) 
	jno .jump1760
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1760:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1761: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1761 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1761 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump1756
.jump1755:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const486] ; 85
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1762
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1762:
	; Computing bound for 'e'
	mov rax, [rel const487] ; 178
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1763
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1763:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 178 
	jno .jump1764
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1764:
	imul rdi, [rsp + 0 + 8] ; multiply by 85 
	jno .jump1765
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1765:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1766: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1766 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1766 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump1756:
	mov rax, [rel const488] ; 513
	push rax
	mov rax, [rel const4] ; 641
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1767
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1767:
	cmp rax, [rsp + 16]
	jl .jump1768
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1768:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1769
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1769:
	cmp rax, [rsp + 24]
	jl .jump1770
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1770:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1771
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1771:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1772
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const489] ; 329
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1774
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1774:
	; Computing bound for 'e'
	mov rax, [rel const490] ; 583
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1775
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1775:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 583 
	jno .jump1776
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1776:
	imul rdi, [rsp + 0 + 8] ; multiply by 329 
	jno .jump1777
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1777:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1778: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1778 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1778 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump1773
.jump1772:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const491] ; 37
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1779
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1779:
	; Computing bound for 'e'
	mov rax, [rel const492] ; 549
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1780
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1780:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 549 
	jno .jump1781
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1781:
	imul rdi, [rsp + 0 + 8] ; multiply by 37 
	jno .jump1782
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1782:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1783: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1783 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1783 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump1773:
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1784
	mov rax, [rel const255] ; 447
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump1785
.jump1784:
	mov rax, [rel const493] ; 216
	push rax
.jump1785:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1786
	mov rax, [rel const26] ; False
	push rax
	jmp .jump1787
.jump1786:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump1787:
	pop rax
	cmp rax, 0
	je .jump1788
	mov rax, [rel const494] ; 39
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump1789
.jump1788:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const495] ; 48
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1790
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1790:
	; Computing bound for 'f'
	mov rax, [rel const496] ; 645
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1791
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1791:
	; Computing bound for 'e'
	mov rax, [rel const368] ; 10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1792
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1792:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1793: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1793 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1793 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1793 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump1789:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1794
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1794:
	cmp rax, [rsp + 16]
	jl .jump1795
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1795:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1796
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1796:
	cmp rax, [rsp + 24]
	jl .jump1797
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1797:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const60] ; 837
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const486] ; 85
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1798
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1798:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1799
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1799:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1800: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1801
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1801:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1802
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1802:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1803
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1803:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1804
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1804:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1805
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1805:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1806: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1806 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1806 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1806 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1806 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1807
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1807:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump1808: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1808 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1808 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1809
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump1809:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1800 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1800 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
	jmp .jump1754
.jump1753:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1810
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const304] ; 487
	push rax
	mov rax, [rel const43] ; 324
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1812
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1812:
	; Computing bound for 'g'
	mov rax, [rel const247] ; 192
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1813
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1813:
	; Computing bound for 'f'
	mov rax, [rel const426] ; 379
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1814
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1814:
	; Computing bound for 'e'
	mov rax, [rel const96] ; 56
	push rax
	mov rax, [rel const464] ; 344
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1815
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1815:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (344 + 56) 
	jno .jump1816
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1816:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 379) 
	jno .jump1817
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1817:
	imul rdi, [rsp + 0 + 16] ; multiply by (- 192) 
	jno .jump1818
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1818:
	imul rdi, [rsp + 0 + 24] ; multiply by (324 + 487) 
	jno .jump1819
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1819:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1820: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1820 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1820 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1820 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1820 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const291] ; 409
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const263] ; 485
	push rax
	mov rax, [rel const497] ; 431
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1821
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1821:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1822: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1822 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const498] ; 699
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const384] ; 339
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1823
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump1823:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1824
	mov rax, [rel const316] ; 625
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump1825
.jump1824:
	mov rax, [rel const499] ; 710
	push rax
	pop rax
	neg rax
	push rax
.jump1825:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1826
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1826:
	cmp rax, [rsp + 32]
	jl .jump1827
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1827:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1828
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1828:
	cmp rax, [rsp + 40]
	jl .jump1829
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1829:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1830
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1830:
	cmp rax, [rsp + 48]
	jl .jump1831
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1831:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1832
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1832:
	cmp rax, [rsp + 56]
	jl .jump1833
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1833:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1811
.jump1810:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const500] ; 388
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1834
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1834:
	; Computing bound for 'f'
	mov rax, [rel const501] ; 746
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1835
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1835:
	; Computing bound for 'e'
	mov rax, [rel const502] ; 502
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1836
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1836:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 502 
	jno .jump1837
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1837:
	imul rdi, [rsp + 0 + 8] ; multiply by 746 
	jno .jump1838
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1838:
	imul rdi, [rsp + 0 + 16] ; multiply by 388 
	jno .jump1839
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1839:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1840: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1840 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1840 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1840 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const503] ; 805
	push rax
	mov rax, [rel const476] ; 198
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const504] ; 16
	push rax
	mov rax, [rel const216] ; 350
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1841
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1841:
	cmp rax, [rsp + 24]
	jl .jump1842
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1842:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1843
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1843:
	cmp rax, [rsp + 32]
	jl .jump1844
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1844:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1845
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1845:
	cmp rax, [rsp + 40]
	jl .jump1846
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1846:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1847
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1847:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1848: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const218] ; 749
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1848 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump1811:
	mov rax, [rel const505] ; 21
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const66] ; 896
	push rax
	mov rax, [rel const184] ; 975
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1849
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const506] ; 575
	push rax
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1851
	mov rax, [rel const90] ; 320
	push rax
	jmp .jump1852
.jump1851:
	mov rax, [rel const433] ; 359
	push rax
.jump1852:
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1853
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1853:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1854: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1854 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1855
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1855:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const507] ; 841
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1856
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1856:
	; Computing bound for 'g'
	mov rax, [rel const508] ; 507
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1857
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1857:
	; Computing bound for 'f'
	mov rax, [rel const326] ; 997
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1858
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1858:
	; Computing bound for 'e'
	mov rax, [rel const509] ; 478
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1859
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1859:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1860: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1860 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1860 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1860 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1860 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1861
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1861:
	; Computing bound for 'f'
	mov rax, [rel const510] ; 405
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1862
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1862:
	; Computing bound for 'e'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1863
	mov rax, [rel const511] ; 211
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump1864
.jump1863:
	mov rax, [rel const512] ; 674
	push rax
	pop rax
	neg rax
	push rax
.jump1864:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1865
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1865:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1866: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const85] ; 259
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1866 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1866 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1866 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1867
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1867:
	; Computing bound for 'f'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const513] ; 348
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1868
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1868:
	; Computing bound for 'f'
	mov rax, [rel const514] ; 819
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1869
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1869:
	; Computing bound for 'e'
	mov rax, [rel const0] ; 680
	push rax
	mov rax, [rel const304] ; 487
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1870
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1870:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (487 - 680) 
	jno .jump1871
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1871:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 819) 
	jno .jump1872
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1872:
	imul rdi, [rsp + 0 + 16] ; multiply by (- 348) 
	jno .jump1873
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1873:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1874: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1874 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1874 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1874 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const318] ; 585
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const384] ; 339
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1875
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1875:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1876: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1876 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const515] ; 131
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1877
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1877:
	cmp rax, [rsp + 24]
	jl .jump1878
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1878:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1879
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1879:
	cmp rax, [rsp + 32]
	jl .jump1880
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1880:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1881
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1881:
	cmp rax, [rsp + 40]
	jl .jump1882
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1882:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1883
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1883:
	; Computing bound for 'e'
	mov rax, [rel const516] ; 697
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1884
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1884:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 697 
	jno .jump1885
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1885:
imul rdi, [rsp + 0 + 8] ; multiply by (array[e : (487 - 680), f : (- 819), g : (- 348)] f)[(- (- 131)), (sum[e : 339] e), 585] 
	jno .jump1886
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1886:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[e : (if (! a) then (- 211) else (- 674)), f : (- 405), g : (- (sum[e : 478, f : 997, g : 507, h : 841] e))] 259) 
	jno .jump1887
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1887:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[e : ((if false then 320 else 359) * 575)] e) 
	jno .jump1888
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1888:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1889: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const227] ; 378
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1890
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1890:
	; Computing bound for 'j'
	mov rax, [rel const517] ; 255
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1891
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1891:
	; Computing bound for 'i'
	mov rax, [rel const518] ; 856
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1892
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1892:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 856 
	jno .jump1893
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1893:
	imul rdi, [rsp + 0 + 8] ; multiply by 255 
	jno .jump1894
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1894:
	imul rdi, [rsp + 0 + 16] ; multiply by 378 
	jno .jump1895
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1895:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1896: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 16], 1
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1896 ; If k < bound, next iter
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1896 ; If j < bound, next iter
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1896 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1897
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1897:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
.jump1898: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 0], 1
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1898 ; If i < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1899
	mov rax, [rel const74] ; 68
	push rax
	jmp .jump1900
.jump1899:
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
.jump1900:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1901
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1901:
	cmp rax, [rsp + 24]
	jl .jump1902
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1902:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1903
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1903:
	cmp rax, [rsp + 32]
	jl .jump1904
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1904:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1905
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1905:
	cmp rax, [rsp + 40]
	jl .jump1906
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1906:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1889 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1889 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1889 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1889 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const44] ; 6
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const519] ; 984
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1907
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1907:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1908: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const520] ; 164
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1908 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1909
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1909:
	; Computing bound for 'e'
	mov rax, [rel const521] ; 415
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const522] ; 81
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1910
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1910:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 81 
	jno .jump1911
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1911:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1912: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1912 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1913
	mov rax, [rel const523] ; 611
	push rax
	jmp .jump1914
.jump1913:
	mov rax, [rel const524] ; 709
	push rax
.jump1914:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1915
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1915:
	cmp rax, [rsp + 8]
	jl .jump1916
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1916:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1917
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1917:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1918: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1919
	mov rax, [rel const525] ; 991
	push rax
	jmp .jump1920
.jump1919:
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump1920:
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1918 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1918 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const364] ; 744
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const526] ; 233
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1921
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1921:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const436] ; 442
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1922
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1922:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 442 
	jno .jump1923
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1923:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1924: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1924 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const351] ; 474
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1925
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1925:
	cmp rax, [rsp + 8]
	jl .jump1926
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1926:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1927
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1927:
	; Computing bound for 'g'
	mov rax, [rel const527] ; 439
	push rax
	mov rax, [rel const528] ; 175
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1928
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump1928:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1929
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1929:
	; Computing bound for 'f'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'f'
	mov rax, [rel const529] ; 968
	push rax
	mov rax, [rel const46] ; 623
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1930
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump1930:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1931
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1931:
	; Computing bound for 'e'
	mov rax, [rel const530] ; 756
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1932
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1932:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 756 
	jno .jump1933
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1933:
	imul rdi, [rsp + 0 + 8] ; multiply by (623 / 968) 
	jno .jump1934
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1934:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1935: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const531] ; 77
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'f'
	add qword [rsp + 8], 1
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump1935 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump1935 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const41] ; 587
	push rax
	mov rax, [rel const532] ; 671
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1936
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1936:
	cmp rax, [rsp + 16]
	jl .jump1937
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1937:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1938
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1938:
	cmp rax, [rsp + 24]
	jl .jump1939
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1939:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1940
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1940:
	; Computing bound for 'e'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const533] ; 341
	push rax
	mov rax, [rel const85] ; 259
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1941
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1941:
	; Computing bound for 'f'
	mov rax, [rel const534] ; 418
	push rax
	mov rax, [rel const230] ; 817
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1942
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump1942:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1943
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1943:
	; Computing bound for 'e'
	mov rax, [rel const427] ; 741
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1944
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1944:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 741) 
	jno .jump1945
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1945:
	imul rdi, [rsp + 0 + 8] ; multiply by (817 / 418) 
	jno .jump1946
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1946:
	imul rdi, [rsp + 0 + 16] ; multiply by (259 + 341) 
	jno .jump1947
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1947:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1948: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump1948 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump1948 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump1948 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const160] ; 389
	push rax
	mov rax, [rel const330] ; 759
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const535] ; 214
	push rax
	mov rax, [rel const536] ; 651
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const82] ; 421
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1949
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1949:
	cmp rax, [rsp + 24]
	jl .jump1950
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1950:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1951
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1951:
	cmp rax, [rsp + 32]
	jl .jump1952
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1952:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1953
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1953:
	cmp rax, [rsp + 40]
	jl .jump1954
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1954:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1955
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1955:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1956: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const352] ; 60
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1956 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1956 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1956 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1956 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const537] ; 395
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const376] ; 770
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1957
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const538] ; 174
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1959
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1959:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1960: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const476] ; 198
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump1960 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump1958
.jump1957:
	mov rax, [rel const126] ; 22
	push rax
.jump1958:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1961
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1961:
	cmp rax, [rsp + 32]
	jl .jump1962
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1962:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1963
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1963:
	cmp rax, [rsp + 40]
	jl .jump1964
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1964:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1965
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1965:
	cmp rax, [rsp + 48]
	jl .jump1966
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1966:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1967
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1967:
	cmp rax, [rsp + 56]
	jl .jump1968
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1968:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1850
.jump1849:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1969
	mov rax, [rel const26] ; False
	push rax
	pop rax
.jump1969:
	push rax
	pop rax
	cmp rax, 0
	je .jump1970
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	jmp .jump1971
.jump1970:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1972
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump1973
	mov rax, [rel const539] ; 18
	push rax
	mov rax, [rel const540] ; 603
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
.jump1973:
	push rax
	pop rax
.jump1972:
	push rax
.jump1971:
	pop rax
	cmp rax, 0
	je .jump1974
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const541] ; 424
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1976
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1976:
	; Computing bound for 'g'
	mov rax, [rel const466] ; 219
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1977
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1977:
	; Computing bound for 'f'
	mov rax, [rel const542] ; 355
	push rax
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump1978
	mov rax, [rel const213] ; 1000
	push rax
	jmp .jump1979
.jump1978:
	mov rax, [rel const465] ; 902
	push rax
.jump1979:
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1980
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1980:
	; Computing bound for 'e'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump1981
	mov rax, [rel const156] ; 235
	push rax
	jmp .jump1982
.jump1981:
	mov rax, [rel const543] ; 977
	push rax
.jump1982:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1983
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump1983:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (if true then 235 else 977) 
	jno .jump1984
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1984:
	imul rdi, [rsp + 0 + 8] ; multiply by ((if false then 1000 else 902) - 355) 
	jno .jump1985
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1985:
	imul rdi, [rsp + 0 + 16] ; multiply by 219 
	jno .jump1986
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1986:
	imul rdi, [rsp + 0 + 24] ; multiply by 424 
	jno .jump1987
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump1987:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump1988: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 24], 1
	; Compare h to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump1988 ; If h < bound, next iter
	mov qword [rsp + 24], 0 ; h = 0
	add qword [rsp + 16], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump1988 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump1988 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump1988 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const368] ; 10
	push rax
	mov rax, [rel const453] ; 15
	push rax
	mov rax, [rel const544] ; 330
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump1989
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump1989:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const545] ; 561
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump1990
	mov rax, [rel const546] ; 336
	push rax
	jmp .jump1991
.jump1990:
	mov rax, [rel const547] ; 69
	push rax
.jump1991:
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump1992
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1992:
	cmp rax, [rsp + 32]
	jl .jump1993
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1993:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump1994
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1994:
	cmp rax, [rsp + 40]
	jl .jump1995
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1995:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump1996
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1996:
	cmp rax, [rsp + 48]
	jl .jump1997
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1997:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump1998
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump1998:
	cmp rax, [rsp + 56]
	jl .jump1999
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump1999:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump1975
.jump1974:
	mov rax, [rel const82] ; 421
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const367] ; 845
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2000
	mov rax, [rel const548] ; 793
	push rax
	jmp .jump2001
.jump2000:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const63] ; 266
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2002
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2002:
	; Computing bound for 'f'
	mov rax, [rel const393] ; 822
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2003
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2003:
	; Computing bound for 'e'
	mov rax, [rel const549] ; 291
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2004
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2004:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 291 
	jno .jump2005
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2005:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 822) 
	jno .jump2006
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2006:
	imul rdi, [rsp + 0 + 16] ; multiply by 266 
	jno .jump2007
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2007:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2008: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2008 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2008 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2008 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const443] ; 59
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2009
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2009:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2010: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const550] ; 481
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2010 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const522] ; 81
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rel const551] ; 642
	push rax
	mov rax, [rel const489] ; 329
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rel const552] ; 553
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2011
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2011:
	cmp rax, [rsp + 24]
	jl .jump2012
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2012:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2013
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2013:
	cmp rax, [rsp + 32]
	jl .jump2014
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2014:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2015
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2015:
	cmp rax, [rsp + 40]
	jl .jump2016
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2016:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2001:
.jump1975:
.jump1850:
.jump1754:
	mov rax, [rel const28] ; 346
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const99] ; 482
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2017
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2017:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 482 
	jno .jump2018
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2018:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2019: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp 
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2019 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const499] ; 710
	push rax
	mov rax, [rel const553] ; 248
	push rax
	mov rax, [rel const397] ; 261
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2020
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump2020:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2021
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2021:
	cmp rax, [rsp + 8]
	jl .jump2022
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2022:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2023
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2023:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const554] ; 148
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2024
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2024:
	; Computing bound for 'f'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const255] ; 447
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2025
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2025:
	; Computing bound for 'f'
	mov rax, [rel const17] ; 591
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2026
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2026:
	; Computing bound for 'e'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const441] ; 265
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2027
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2027:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2028: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2028 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2029
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2029:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2030: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2030 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2030 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2030 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2031
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2031:
	; Computing bound for 'e'
	mov rax, [rel const482] ; 556
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2032
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2032:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2033: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	mov rax, [rel const487] ; 178
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2034
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2034:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2035
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2035:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2036
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2036:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2037
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2037:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump2038: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2038 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2038 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2038 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2038 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2039
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2039:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2040
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump2040:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2041
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2041:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2042
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2042:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2043
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2043:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump2044: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2044 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2044 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2044 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2044 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2033 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2033 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2033 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2045
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2045:
	; Computing bound for 'e'
	mov rax, [rel const180] ; 594
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2046
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2046:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 594 
	jno .jump2047
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2047:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[e : 556, f : (sum[e : (sum[e : 265] e), f : 591, g : 447] e), g : 148] (sum[h : e, i : g, j : (g / g), k : (sum[h : g, i : g, j : f, k : 178] g)] (- g))) 
	jno .jump2048
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2048:
imul rdi, [rsp + 0 + 16] ; multiply by (array[e : 482] (- e))[((261 * 248) % 710)] 
	jno .jump2049
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2049:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
	; Initialize 'f' to 0
	mov rax, 0
	push rax
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2050: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp 
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 16], 1
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2050 ; If g < bound, next iter
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2050 ; If f < bound, next iter
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2050 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'e'
	mov rax, [rel const555] ; 850
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2051
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2051:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 850 
	jno .jump2052
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2052:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'e' to 0
	mov rax, 0
	push rax
.jump2053: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const447] ; 414
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2054
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	jmp .jump2055
.jump2054:
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
.jump2055:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'e'
	add qword [rsp + 0], 1
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2053 ; If e < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2056
	mov rax, [rel const345] ; 631
	push rax
	jmp .jump2057
.jump2056:
	mov rax, [rel const556] ; 62.86
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2058
	mov rax, [rel const388] ; 121
	push rax
	jmp .jump2059
.jump2058:
	mov rax, [rel const307] ; 308
	push rax
.jump2059:
.jump2057:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2060
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2060:
	cmp rax, [rsp + 8]
	jl .jump2061
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2061:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const349] ; 310
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const515] ; 131
	push rax
	mov rax, [rel const206] ; 966
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2062
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2062:
	cmp rax, [rsp + 24]
	jl .jump2063
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2063:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2064
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2064:
	cmp rax, [rsp + 32]
	jl .jump2065
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2065:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2066
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2066:
	cmp rax, [rsp + 40]
	jl .jump2067
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2067:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const23] ; 503
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2068
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2068:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2069
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump2069:
	cqo
	idiv r10
	push rax
	mov rdi, 16
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 16
	; Moving 16 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const557] ; 469
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2070
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2070:
	; Computing bound for 'h'
	mov rax, [rel const422] ; 187
	push rax
	mov rax, [rel const558] ; 231
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rel const559] ; 309
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2071
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2071:
	; Computing bound for 'g'
	mov rax, [rel const442] ; 809
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2072
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2072:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 809 
	jno .jump2073
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2073:
	imul rdi, [rsp + 0 + 8] ; multiply by ((- 309) + (231 * 187)) 
	jno .jump2074
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2074:
	imul rdi, [rsp + 0 + 16] ; multiply by 469 
	jno .jump2075
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2075:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2076: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const560] ; 931
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2076 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2076 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2076 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const561] ; 736
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2077
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2077:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2078
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2078:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump2079
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2079:
	imul rdi, [rsp + 0 + 8] ; multiply by 736 
	jno .jump2080
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2080:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2081: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const562] ; 717
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2081 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2081 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2082
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const563] ; 369
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2084
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2084:
	; Computing bound for 'g'
	mov rax, [rel const564] ; 304
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2085
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2085:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2086: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2086 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2086 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump2083
.jump2082:
	mov rax, [rel const442] ; 809
	push rax
.jump2083:
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2087
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump2088
.jump2087:
	mov rax, [rel const565] ; 638
	push rax
	pop rax
	neg rax
	push rax
.jump2088:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2089
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2089:
	cmp rax, [rsp + 16]
	jl .jump2090
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2090:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2091
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2091:
	cmp rax, [rsp + 24]
	jl .jump2092
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2092:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2093
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump2093:
	push rax
	pop rax
	cmp rax, 0
	je .jump2094
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump2095
.jump2094:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump2095:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2096
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2096:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2097
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2097:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2098: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2098 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2098 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	sub rax, r10
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2099
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2099:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump2100
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2100:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2101: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const566] ; 704
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2102
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2102:
	cmp rax, [rsp + 8]
	jl .jump2103
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2103:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2101 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2104
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump2105
.jump2104:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump2105:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2106
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2106:
	cmp rax, [rsp + 8]
	jl .jump2107
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2107:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2108
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2108:
	cmp rax, [rsp + 24]
	jl .jump2109
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2109:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2110
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2110:
	cmp rax, [rsp + 32]
	jl .jump2111
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2111:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2112
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2112:
	cmp rax, [rsp + 40]
	jl .jump2113
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2113:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2114
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2114:
	cmp rax, [rsp + 8]
	jl .jump2115
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2115:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2116
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2116:
	; Computing bound for 'i'
	mov rax, [rel const25] ; 569
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2117
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2117:
	; Computing bound for 'h'
	mov rax, [rel const518] ; 856
	push rax
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2118
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2118:
	cmp rax, [rsp + 8]
	jl .jump2119
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2119:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2120
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2122
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2122:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2123: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const489] ; 329
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2123 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2124
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2124:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2125
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2125:
	; Computing bound for 'h'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2126
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump2127
.jump2126:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump2127:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2128
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2128:
	; Computing bound for 'g'
	mov rax, [rel const126] ; 22
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2129
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2129:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2130: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2130 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2130 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2130 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2131
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2131:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2132
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump2133
.jump2132:
	mov rax, [rel const567] ; 713
	push rax
.jump2133:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2134
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2134:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2135: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const508] ; 507
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2135 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2135 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2135 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump2121
.jump2120:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump2121:
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2136
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2136:
	; Computing bound for 'g'
	mov rax, [rel const568] ; 125
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2137
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2137:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 125 
	jno .jump2138
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2138:
imul rdi, [rsp + 0 + 8] ; multiply by ((if false then (sum[g : (if a then f else 713), h : (sum[g : 22, h : (if true then f else f), i : f] f), i : (sum[g : f] (f + 329))] (- 507)) else f) + [856][f]) 
	jno .jump2139
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2139:
	imul rdi, [rsp + 0 + 16] ; multiply by (- 569) 
	jno .jump2140
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2140:
imul rdi, [rsp + 0 + 24] ; multiply by e[(array[g : 809, h : ((- 309) + (231 * 187)), i : 469] (- (931 * f)))[(array[g : f] e[704])[(if false then f else f)], ((sum[g : f, h : f] h) - (if (true && a) then f else f)), (array[g : f, h : 736] (717 + g))[(if false then f else (- 638)), (if a then (sum[g : 304, h : 369] g) else 809)]]] 
	jno .jump2141
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2141:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2142: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2143
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2145
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2145:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
.jump2146: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'k'
	add qword [rsp + 0], 1
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2146 ; If k < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump2144
.jump2143:
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
.jump2144:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2142 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2142 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2142 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2142 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const431] ; 521
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2147
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2147:
	; Computing bound for 'h'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const569] ; 84
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2148
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2148:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 84 
	jno .jump2149
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2149:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2150: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2150 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2151
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2151:
	cmp rax, [rsp + 8]
	jl .jump2152
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2152:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const570] ; 398
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2153
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2153:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2154: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const571] ; 451
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2154 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2155
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2155:
	; Computing bound for 'g'
	mov rax, [rel const379] ; 357
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2156
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2156:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2157: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2157 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2157 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2157 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2158
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2158:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2159: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const572] ; 91.18
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2159 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const573] ; 64.43
	push rax
	mov rax, [rel const574] ; 19.12
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2160
	mov rax, [rel const575] ; 18.16
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump2161
.jump2160:
	mov rax, [rel const576] ; 85.16
	push rax
.jump2161:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2162
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump2163
.jump2162:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump2163:
	mov rax, [rel const577] ; 23.41
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 8 ; Add alignment
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const481] ; 800
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2164
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2164:
	; Computing bound for 'h'
	mov rax, [rel const578] ; 396
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2165
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2165:
	; Computing bound for 'g'
	mov rax, [rel const579] ; 23
	push rax
	mov rax, [rel const61] ; 604
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2166
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2166:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2167: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const580] ; 2.2
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2167 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2167 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2167 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2168
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2170
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2170:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump2171
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump2171:
	push rax
	pop rax
	cmp rax, 0
	je .jump2172
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump2173
.jump2172:
	mov rax, [rel const527] ; 439
	push rax
.jump2173:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2174
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2174:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2175: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const581] ; 239
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2175 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2175 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2176
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2176:
	; Computing bound for 'i'
	sub rsp, 16
	; Moving 16 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2177
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2177:
	cmp rax, [rsp + 8]
	jl .jump2178
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2178:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2179
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2179:
	; Computing bound for 'h'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2180
	mov rax, [rel const26] ; False
	push rax
	jmp .jump2181
.jump2180:
	mov rax, [rel const26] ; False
	push rax
.jump2181:
	pop rax
	cmp rax, 0
	je .jump2182
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump2183
.jump2182:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump2183:
	mov rax, [rel const444] ; 40
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2184
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump2184:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2185
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2185:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2186
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2186:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const84] ; 743
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2187
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2187:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const268] ; 944
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2188
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2188:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2189: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2189 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2190
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2190:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2191
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2191:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2192
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2192:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2193
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2193:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2194: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2194 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2194 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2194 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2194 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2195
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2195:
	; Computing bound for 'g'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2196
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2196:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2197: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const582] ; 449
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2197 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2198
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2198:
	; Computing bound for 'g'
	sub rsp, 16
	; Moving 16 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2199
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2199:
	cmp rax, [rsp + 8]
	jl .jump2200
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2200:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2201
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2201:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2202: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const375] ; 554
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2202 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2202 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2203
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2203:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2204: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const133] ; 677
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2204 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2204 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2204 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2205
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2205:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[g : (sum[g : e[f], h : (sum[g : f] 449)] 554), h : (sum[g : f, h : f, i : f, j : (sum[g : 944] g)] i), i : (- 743)] 677) 
	jno .jump2206
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2206:
	imul rdi, [rsp + 0 + 8] ; multiply by ((- (f / 40)) % (if (if true then false else false) then f else f)) 
	jno .jump2207
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2207:
	imul rdi, [rsp + 0 + 16] ; multiply by (- e[f]) 
	jno .jump2208
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2208:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[g : (if (a || a) then f else 439), h : f] 239) 
	jno .jump2209
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2209:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2210: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const257] ; 855
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2210 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2210 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2210 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2210 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const280] ; 848
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2211
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2211:
	; Computing bound for 'g'
	mov rax, [rel const583] ; 588
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2212
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2212:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 588 
	jno .jump2213
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2213:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump2214
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2214:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2215: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const213] ; 1000
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'h'
	add qword [rsp + 8], 1
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2215 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2215 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rdi, 24
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 1
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump2216
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2218
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump2219
.jump2218:
	mov rax, [rel const584] ; 299
	push rax
.jump2219:
	jmp .jump2217
.jump2216:
	mov rax, [rel const300] ; 703
	push rax
.jump2217:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2220
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2220:
	cmp rax, [rsp + 8]
	jl .jump2221
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2221:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2222
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2224
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2224:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	jmp .jump2223
.jump2222:
	mov rax, [rel const115] ; 719
	push rax
.jump2223:
	mov rax, [rel const459] ; 12
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const585] ; 897
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2225
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2225:
	cmp rax, [rsp + 16]
	jl .jump2226
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2226:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2227
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2227:
	cmp rax, [rsp + 24]
	jl .jump2228
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2228:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const586] ; 166
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2229
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2229:
	; Computing bound for 'i'
	mov rax, [rel const587] ; 558
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2230
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2230:
	; Computing bound for 'h'
	mov rax, [rel const588] ; 401
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2231
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2231:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2232
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2232:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2233: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2233 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2233 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2233 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2233 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	mov rax, [rel const589] ; 700
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2234
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2234:
	; Computing bound for 'i'
	mov rax, [rel const149] ; 581
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2235
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2235:
	; Computing bound for 'h'
	mov rax, [rel const590] ; 768
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2236
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2236:
	; Computing bound for 'g'
	mov rax, [rel const591] ; 859
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2237
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2237:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2238: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'j'
	add qword [rsp + 24], 1
	; Compare j to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2238 ; If j < bound, next iter
	mov qword [rsp + 24], 0 ; j = 0
	add qword [rsp + 16], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2238 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2238 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2238 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2239
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2239:
	cqo
	idiv r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2240
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump2241
.jump2240:
	mov rax, [rel const85] ; 259
	push rax
.jump2241:
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2242
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump2244
	mov rax, [rel const26] ; False
	push rax
	pop rax
.jump2244:
	push rax
	pop rax
	cmp rax, 0
	je .jump2245
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump2246
.jump2245:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump2246:
	jmp .jump2243
.jump2242:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const539] ; 18
	push rax
	mov rax, [rel const592] ; 132
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2247
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump2247:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2248
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2248:
	; Computing bound for 'h'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'g'
	mov rax, [rel const259] ; 267
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2249
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2249:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 267 
	jno .jump2250
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2250:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2251: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const435] ; 907
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2251 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const593] ; 107
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2252
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2252:
	cmp rax, [rsp + 8]
	jl .jump2253
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2253:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2254
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2254:
	; Computing bound for 'g'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2255
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2255:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2256: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 16], 1
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2256 ; If i < bound, next iter
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2256 ; If h < bound, next iter
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2256 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump2243:
	mov rax, [rel const594] ; 385
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2257
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2257:
	cmp rax, [rsp + 32]
	jl .jump2258
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2258:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2259
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2259:
	cmp rax, [rsp + 40]
	jl .jump2260
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2260:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2261
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2261:
	cmp rax, [rsp + 48]
	jl .jump2262
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2262:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2263
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2263:
	cmp rax, [rsp + 56]
	jl .jump2264
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2264:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump2169
.jump2168:
	mov rax, [rel const595] ; 860
	push rax
.jump2169:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2265
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2265:
	cmp rax, [rsp + 32]
	jl .jump2266
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2266:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2267
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2267:
	cmp rax, [rsp + 40]
	jl .jump2268
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2268:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2269
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2269:
	cmp rax, [rsp + 48]
	jl .jump2270
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2270:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2271
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2271:
	cmp rax, [rsp + 56]
	jl .jump2272
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2272:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2273
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2273:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (array[g : 125, h : ((if false then (sum[g : (if a then f else 713), h : (sum[g : 22, h : (if true then f else f), i : f] f), i : (sum[g : f] (f + 329))] (- 507)) else f) + [856][f]), i : (- 569), j : e[(array[g : 809, h : ((- 309) + (231 * 187)), i : 469] (- (931 * f)))[(array[g : f] e[704])[(if false then f else f)], ((sum[g : f, h : f] h) - (if (true && a) then f else f)), (array[g : f, h : 736] (717 + g))[(if false then f else (- 638)), (if a then (sum[g : 304, h : 369] g) else 809)]]]] (if (! a) then (sum[k : f] j) else h))[(if ((c % (sum[g : (604 + 23), h : 396, i : 800] (c + (- 2.2)))) == rgba {((- 23.41) / (if true then c else c)), (if a then (- 18.16) else 85.16), (19.12 - 64.43), (sum[g : f] 91.18)}.g) then (array[g : (sum[g : (sum[g : e[f], h : (sum[g : f] 449)] 554), h : (sum[g : f, h : f, i : f, j : (sum[g : 944] g)] i), i : (- 743)] 677), h : ((- (f / 40)) % (if (if true then false else false) then f else f)), i : (- e[f]), j : (sum[g : (if (a || a) then f else 439), h : f] 239)] 855)[385, (if ((if (c < c) then f else 259) <= ((sum[g : 859, h : 768, i : 581, j : 700] g) / (sum[g : f, h : 401, i : 558, j : 166] h))) then (if (false || false) then f else f) else (sum[g : f, h : (array[g : 267] 907)[107], i : (132 / 18)] i)), [(array[g : 588, h : f] 1000)][(if true then (if a then f else 299) else 703)][897, (12 + (if a then (f % f) else 719))], 848] else 860), f, (sum[g : 357, h : ((sum[g : 398] 451) + (- (array[g : 84] g)[(- f)])), i : 521] (- h)), f] 
	jno .jump2274
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2274:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'g' to 0
	mov rax, 0
	push rax
.jump2275: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2276
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2278
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2278:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2279
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2279:
	; Computing bound for 'h'
	mov rax, [rel const596] ; 51
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2280
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2280:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 51 
	jno .jump2281
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2281:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump2282
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2282:
	imul rdi, [rsp + 0 + 16] ; multiply by g 
	jno .jump2283
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2283:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump2284: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2284 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2284 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2284 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const597] ; 25
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const265] ; 939
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2285
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2285:
	cmp rax, [rsp + 24]
	jl .jump2286
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2286:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2287
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2287:
	cmp rax, [rsp + 32]
	jl .jump2288
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2288:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2289
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2289:
	cmp rax, [rsp + 40]
	jl .jump2290
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2290:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump2277
.jump2276:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump2277:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2291
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2291:
	; Computing bound for 'j'
	mov rax, [rel const11] ; True
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2292
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	jmp .jump2293
.jump2292:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump2293:
	pop rax
	cmp rax, 0
	je .jump2294
	mov rax, [rel const598] ; 605
	push rax
	jmp .jump2295
.jump2294:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2296
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump2297
.jump2296:
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
.jump2297:
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2298
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump2300
	mov rax, [rel const599] ; 445
	push rax
	jmp .jump2301
.jump2300:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump2301:
	jmp .jump2299
.jump2298:
	mov rax, [rel const600] ; 456
	push rax
.jump2299:
	pop rax
	pop r10
	imul rax, r10
	push rax
.jump2295:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2302
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2302:
	; Computing bound for 'i'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2303
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2303:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2304
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2304:
	; Computing bound for 'h'
	mov rax, [rel const467] ; 149
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2305
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2305:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 149 
	jno .jump2306
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2306:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump2307
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2307:
	imul rdi, [rsp + 0 + 16] ; multiply by f 
	jno .jump2308
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2308:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump2309: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2309 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2309 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2309 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const374] ; 376
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'i'
	mov rax, [rel const601] ; 830
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2310
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2310:
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2311
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2311:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump2312: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'i'
	add qword [rsp + 8], 1
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2312 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2312 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2313
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2313:
	cmp rax, [rsp + 24]
	jl .jump2314
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2314:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2315
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2315:
	cmp rax, [rsp + 32]
	jl .jump2316
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2316:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2317
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2317:
	cmp rax, [rsp + 40]
	jl .jump2318
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2318:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2319
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2319:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump2320: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump2321
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump2321:
	cqo
	idiv r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2320 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2322
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2322:
	; Computing bound for 'h'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump2323
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	jmp .jump2324
.jump2323:
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
.jump2324:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2325
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2325:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump2326: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2326 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'k'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2327
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2327:
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2328
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2328:
	; Computing bound for 'i'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2329
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2329:
	; Computing bound for 'h'
	mov rax, [rel const351] ; 474
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2330
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2330:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 474 
	jno .jump2331
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2331:
	imul rdi, [rsp + 0 + 8] ; multiply by g 
	jno .jump2332
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2332:
	imul rdi, [rsp + 0 + 16] ; multiply by (- g) 
	jno .jump2333
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2333:
	imul rdi, [rsp + 0 + 24] ; multiply by f 
	jno .jump2334
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump2334:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump2335: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const341] ; 773
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2335 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2335 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2335 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2335 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'h'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2336
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2336:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump2337: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'h'
	add qword [rsp + 0], 1
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2337 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const201] ; 958
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump2338
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2338:
	cmp rax, [rsp + 32]
	jl .jump2339
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2339:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump2340
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2340:
	cmp rax, [rsp + 40]
	jl .jump2341
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2341:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump2342
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2342:
	cmp rax, [rsp + 48]
	jl .jump2343
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2343:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump2344
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump2344:
	cmp rax, [rsp + 56]
	jl .jump2345
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump2345:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2346
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2346:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'k' to 0
	mov rax, 0
	push rax
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump2347: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const602] ; 955
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2348
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2348:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump2349: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2350
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2350:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2351
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2351:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump2352: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	mov rax, [rel const132] ; 517
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2353
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2353:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2354
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2354:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp 
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2355
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2355:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2356
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2356:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump2357: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const603] ; 8.89
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2357 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2357 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2357 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2357 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump2352 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump2352 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2349 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 64] ; Load sum
	movsd [rsp + 64], xmm0 ; Save sum
	; Increment 'k'
	add qword [rsp + 24], 1
	; Compare k to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump2347 ; If k < bound, next iter
	mov qword [rsp + 24], 0 ; k = 0
	add qword [rsp + 16], 1 ; j++
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump2347 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump2347 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump2347 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const604] ; 31.13
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump2358
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const605] ; 94.56
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'j'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2359
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2359:
	; Computing bound for 'i'
	mov rax, [rel const468] ; 326
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2360
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2360:
	; Computing bound for 'h'
	mov rax, [rel const297] ; 923
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2361
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump2361:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'j' to 0
	mov rax, 0
	push rax
	; Initialize 'i' to 0
	mov rax, 0
	push rax
	; Initialize 'h' to 0
	mov rax, 0
	push rax
.jump2362: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const606] ; 35.65
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'j'
	add qword [rsp + 16], 1
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump2362 ; If j < bound, next iter
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump2362 ; If i < bound, next iter
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump2362 ; If h < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const607] ; 68.99
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const608] ; 6.41
	push rax
	mov rax, [rel const609] ; 3.82
	push rax
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump2363
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump2364
.jump2363:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump2364:
	pop rax
	cmp rax, 0
	je .jump2365
	mov rax, [rel const610] ; 18.3
	push rax
	jmp .jump2366
.jump2365:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const611] ; 20.06
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
.jump2366:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
.jump2358:
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'g'
	add qword [rsp + 0], 1
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump2275 ; If g < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 24
	lea rdi, [rsp]
	lea rsi, [rel const710] ; 'k.png'
	call _read_image
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump4059
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const228] ; 865
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4060
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4060:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 865 
	jno .jump4061
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4061:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4062: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4062 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4063
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4063:
	cmp rax, [rsp + 8]
	jl .jump4064
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4064:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
.jump4059:
	push rax
	pop rax
	cmp rax, 0
	je .jump4065
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4067
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4069
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4069:
	; Computing bound for 'l'
	mov rax, [rel const67] ; 114
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4070
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4070:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 114 
	jno .jump4071
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4071:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump4072
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4072:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4073: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4074
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4074:
	; Computing bound for 'n'
	mov rax, [rel const297] ; 923
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4075
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4075:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
.jump4076: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 8], 1
	; Compare o to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4076 ; If o < bound, next iter
	mov qword [rsp + 8], 0 ; o = 0
	add qword [rsp + 0], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4076 ; If n < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4073 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4073 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump4068
.jump4067:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const467] ; 149
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4077
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4077:
	; Computing bound for 'l'
	mov rax, [rel const396] ; 316
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4078
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4078:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 316 
	jno .jump4079
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4079:
	imul rdi, [rsp + 0 + 8] ; multiply by 149 
	jno .jump4080
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4080:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4081: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4081 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4081 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump4068:
	jmp .jump4066
.jump4065:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const711] ; 864
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4082
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4082:
	; Computing bound for 'l'
	mov rax, [rel const521] ; 415
	push rax
	mov rax, [rel const712] ; 189
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4083
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4083:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (189 - 415) 
	jno .jump4084
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4084:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 864) 
	jno .jump4085
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4085:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4086: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4086 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4086 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump4066:
	mov rax, [rel const62] ; 494
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4087
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4087:
	cmp rax, [rsp + 16]
	jl .jump4088
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4088:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4089
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4089:
	cmp rax, [rsp + 24]
	jl .jump4090
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4090:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4091
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4091:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (if (true || (array[l : 865] a)[(- h)]) then (if (true != a) then (array[l : 114, m : f] (sum[n : 923, o : m] h)) else (array[l : 316, m : 149] f)) else (array[l : (189 - 415), m : (- 864)] f))[(- f), 494] 
	jno .jump4092
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4092:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4093: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const713] ; 306
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4094
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const463] ; 807
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4096
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4096:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4097
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4097:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump4098
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4098:
	imul rdi, [rsp + 0 + 8] ; multiply by 807 
	jno .jump4099
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4099:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump4100: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const26] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4100 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4100 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump4095
.jump4094:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const363] ; 609
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4101
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4101:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4102
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4102:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump4103
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4103:
	imul rdi, [rsp + 0 + 8] ; multiply by 609 
	jno .jump4104
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4104:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump4105: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 8], 1
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4105 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4105 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump4095:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const95] ; 136
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4106
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4106:
	cmp rax, [rsp + 16]
	jl .jump4107
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4107:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4108
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4108:
	cmp rax, [rsp + 24]
	jl .jump4109
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4109:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4110
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4111
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump4111:
	push rax
	pop rax
.jump4110:
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4093 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4112
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4114
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4116
	mov rax, [rel const714] ; 937
	push rax
	jmp .jump4117
.jump4116:
	mov rax, [rel const643] ; 375
	push rax
.jump4117:
	jmp .jump4115
.jump4114:
	mov rax, [rel const462] ; 325
	push rax
.jump4115:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4118
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4118:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const715] ; 90
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4119
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4119:
	; Computing bound for 'l'
	mov rax, [rel const716] ; 536
	push rax
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	mov rax, [rel const717] ; 777
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4120
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4120:
	cmp rax, [rsp + 8]
	jl .jump4121
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4121:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4122
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4122:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof int[,,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by [536][(- 777)] 
	jno .jump4123
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4123:
	imul rdi, [rsp + 0 + 8] ; multiply by (90 * (- f)) 
	jno .jump4124
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4124:
	imul rdi, [rsp + 0 + 16] ; multiply by (if a then (if a then 937 else 375) else 325) 
	jno .jump4125
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4125:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4126: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4127
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4127:
	; Computing bound for 'q'
	mov rax, [rel const148] ; 695
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4128
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4128:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4129
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4129:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4130
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4130:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump4131
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4131:
	imul rdi, [rsp + 0 + 8] ; multiply by l 
	jno .jump4132
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4132:
	imul rdi, [rsp + 0 + 16] ; multiply by 695 
	jno .jump4133
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4133:
	imul rdi, [rsp + 0 + 24] ; multiply by h 
	jno .jump4134
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4134:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4135: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 's'
	mov rax, [rel const396] ; 316
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4136
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4136:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump4137: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 's'
	add qword [rsp + 0], 1
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4137 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4135 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4135 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4135 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4135 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax 
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4126 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4126 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4126 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 16
	; Moving 16 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4138
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4138:
	cmp rax, [rsp + 8]
	jl .jump4139
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4139:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4140
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4140:
	; Computing bound for 'n'
	mov rax, [rel const718] ; 75
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4141
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4141:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4142
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4142:
	; Computing bound for 'l'
	mov rax, [rel const205] ; 959
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4143
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4143:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4144: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4144 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4144 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4144 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4144 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4145
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4145:
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const51] ; 191
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4146
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4146:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4147: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const535] ; 214
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4147 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4148
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4148:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[l : 191] 214) 
	jno .jump4149
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4149:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[l : 959, m : h, n : 75, o : f] l) 
	jno .jump4150
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4150:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4151: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const548] ; 793
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4151 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4151 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 16
	; Moving 16 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4152
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4152:
	cmp rax, [rsp + 8]
	jl .jump4153
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4153:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4154
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4154:
	; Computing bound for 'm'
	mov rax, [rel const719] ; 735
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4155
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4155:
	; Computing bound for 'l'
	mov rax, [rel const58] ; 35
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4156
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4156:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4157: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const720] ; 130
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4157 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4157 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4157 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4158
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4158:
	cmp rax, [rsp + 16]
	jl .jump4159
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4159:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4160
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4160:
	cmp rax, [rsp + 24]
	jl .jump4161
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4161:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4162
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump4163
.jump4162:
	mov rax, [rel const46] ; 623
	push rax
.jump4163:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4164
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4164:
	cmp rax, [rsp + 24]
	jl .jump4165
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4165:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4166
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4166:
	cmp rax, [rsp + 32]
	jl .jump4167
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4167:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4168
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4168:
	cmp rax, [rsp + 40]
	jl .jump4169
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4169:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp 
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4170
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4170:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4171
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4171:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump4172
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4172:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump4173
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4173:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4174: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4174 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4174 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const623] ; 733
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4175
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4175:
	cmp rax, [rsp + 16]
	jl .jump4176
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4176:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4177
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4177:
	cmp rax, [rsp + 24]
	jl .jump4178
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4178:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4179
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const489] ; 329
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4181
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4181:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4182: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4182 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump4180
.jump4179:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump4180:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	mov rax, [rel const521] ; 415
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4183
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4183:
	; Computing bound for 'm'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4184
	mov rax, [rel const721] ; 340
	push rax
	jmp .jump4185
.jump4184:
	mov rax, [rel const722] ; 280
	push rax
.jump4185:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4186
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4186:
	; Computing bound for 'l'
	mov rax, [rel const723] ; 397
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4187
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4187:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4188: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4188 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4188 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4188 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4189
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4189:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4190
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4190:
	; Computing bound for 'l'
	sub rsp, 16
	; Moving 16 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4191
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4191:
	cmp rax, [rsp + 8]
	jl .jump4192
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4192:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4193
	mov rax, [rel const464] ; 344
	push rax
	jmp .jump4194
.jump4193:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const3] ; 701
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4195
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4195:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4196
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4196:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4197
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4197:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4198
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4198:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump4199
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4199:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump4200
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4200:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump4201
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4201:
	imul rdi, [rsp + 0 + 24] ; multiply by 701 
	jno .jump4202
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4202:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4203: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4203 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4203 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4203 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4203 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const724] ; 596
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const86] ; 661
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4204
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4204:
	cmp rax, [rsp + 32]
	jl .jump4205
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4205:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4206
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4206:
	cmp rax, [rsp + 40]
	jl .jump4207
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4207:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4208
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4208:
	cmp rax, [rsp + 48]
	jl .jump4209
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4209:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4210
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4210:
	cmp rax, [rsp + 56]
	jl .jump4211
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4211:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4194:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4212
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4212:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4213: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4213 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4213 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4213 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const676] ; 113
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4214
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4214:
	cqo
	idiv r10
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const289] ; 675
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4215
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4215:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4216
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4216:
	; Computing bound for 'm'
	mov rax, [rel const176] ; 126
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4217
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4217:
	; Computing bound for 'l'
	mov rax, [rel const725] ; 94
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4218
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4218:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4219: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4219 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4219 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4219 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4219 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4220
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump4220:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4221
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4221:
	cmp rax, [rsp + 32]
	jl .jump4222
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4222:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4223
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4223:
	cmp rax, [rsp + 40]
	jl .jump4224
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4224:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4225
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4225:
	cmp rax, [rsp + 48]
	jl .jump4226
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4226:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4227
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4227:
	cmp rax, [rsp + 56]
	jl .jump4228
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4228:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4113
.jump4112:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4229
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4229:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4230
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4230:
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4231
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump4232
.jump4231:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump4232:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4233
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4233:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4234
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4234:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4235
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4235:
	; Computing bound for 'l'
	mov rax, [rel const726] ; 210
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4236
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4236:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4237: ; Begin body of loop
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4238
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4238:
	cmp rax, [rsp + 8]
	jl .jump4239
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4239:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4237 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4237 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4237 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4237 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4240
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4240:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4241: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4241 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4241 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4241 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4242
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump4242:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
.jump4113:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4243
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4243:
	cmp rax, [rsp + 8]
	jl .jump4244
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4244:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4245
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4247
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4247:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4248
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4248:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump4249
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4249:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump4250
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4250:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4251: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4252
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump4253
.jump4252:
	mov rax, [rel const368] ; 10
	push rax
.jump4253:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4254
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump4254:
	cqo
	idiv r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4251 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4251 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4255
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4255:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4256: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4256 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4257
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4257:
	cmp rax, [rsp + 16]
	jl .jump4258
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4258:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4259
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4259:
	cmp rax, [rsp + 24]
	jl .jump4260
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4260:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4261
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4261:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4262
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4262:
	; Computing bound for 'l'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4263
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const354] ; 150
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4265
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4265:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4266
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4266:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump4267
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4267:
	imul rdi, [rsp + 0 + 8] ; multiply by 150 
	jno .jump4268
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4268:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4269: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4269 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4269 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump4264
.jump4263:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4270
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4270:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4271
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4271:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump4272
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4272:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump4273
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4273:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4274: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4274 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4274 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump4264:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4275
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4277
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump4278
.jump4277:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump4278:
	jmp .jump4276
.jump4275:
	mov rax, [rel const36] ; 406
	push rax
.jump4276:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4279
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4279:
	cmp rax, [rsp + 16]
	jl .jump4280
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4280:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4281
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4281:
	cmp rax, [rsp + 24]
	jl .jump4282
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4282:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4283
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4283:
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4284
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4284:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4285: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4285 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4286
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4286:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4287: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4287 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4288
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4288:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump4289
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4289:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4290: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4290 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const727] ; 706
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4291
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4291:
	cmp rax, [rsp + 8]
	jl .jump4292
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4292:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4293
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4293:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4294
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4294:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4295
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4295:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump4296
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4296:
imul rdi, [rsp + 0 + 8] ; multiply by ((array[l : f] f)[(- 706)] / (sum[l : (sum[l : f] f)] f)) 
	jno .jump4297
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4297:
imul rdi, [rsp + 0 + 16] ; multiply by (if (! a) then (array[l : h, m : 150] h) else (array[l : h, m : f] f))[(if a then (if a then f else h) else 406), h] 
	jno .jump4298
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4298:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4299: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4300
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4302
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump4303
.jump4302:
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
.jump4303:
	jmp .jump4301
.jump4300:
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
.jump4301:
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4299 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4299 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4299 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const234] ; 720
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4304
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4304:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4305
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4305:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4306: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4306 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4306 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const347] ; 89
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4307
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4307:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4308
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4308:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4309: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 32] ; Load sum
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4309 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4309 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4310
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4312
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4312:
	; Computing bound for 'm'
	mov rax, [rel const728] ; 365
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4313
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4313:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4314
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4314:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- f) 
	jno .jump4315
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4315:
	imul rdi, [rsp + 0 + 8] ; multiply by 365 
	jno .jump4316
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4316:
	imul rdi, [rsp + 0 + 16] ; multiply by (- h) 
	jno .jump4317
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4317:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4318: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4318 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4318 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4318 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4311
.jump4310:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4319
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4321
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4321:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4322
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4322:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4323
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4323:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump4324
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4324:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump4325
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4325:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump4326
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4326:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4327: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp 
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4327 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4327 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4327 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4320
.jump4319:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4328
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4328:
	; Computing bound for 'm'
	mov rax, [rel const595] ; 860
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4329
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4329:
	; Computing bound for 'l'
	mov rax, [rel const729] ; 524
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4330
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4330:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by 524 
	jno .jump4331
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4331:
	imul rdi, [rsp + 0 + 8] ; multiply by 860 
	jno .jump4332
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4332:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump4333
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4333:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4334: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4334 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4334 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4334 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4320:
.jump4311:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4335
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4335:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4336
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4336:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump4337
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4337:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump4338
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4338:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4339: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const26] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4339 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4339 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4340
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4340:
	cmp rax, [rsp + 16]
	jl .jump4341
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4341:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4342
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4342:
	cmp rax, [rsp + 24]
	jl .jump4343
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4343:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4344
	mov rax, [rel const220] ; 947
	push rax
	jmp .jump4345
.jump4344:
	mov rax, [rel const27] ; 578
	push rax
.jump4345:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4346
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4346:
	cmp rax, [rsp + 24]
	jl .jump4347
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4347:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4348
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4348:
	cmp rax, [rsp + 32]
	jl .jump4349
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4349:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4350
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4350:
	cmp rax, [rsp + 40]
	jl .jump4351
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4351:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4352
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4352:
	cmp rax, [rsp + 24]
	jl .jump4353
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4353:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4354
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4354:
	cmp rax, [rsp + 32]
	jl .jump4355
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4355:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4356
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4356:
	cmp rax, [rsp + 40]
	jl .jump4357
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4357:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4358
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4358:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
imul rdi, [rsp + 0 + 0] ; multiply by (h * (array[l : f, m : ((array[l : f] f)[(- 706)] / (sum[l : (sum[l : f] f)] f)), n : (if (! a) then (array[l : h, m : 150] h) else (array[l : h, m : f] f))[(if a then (if a then f else h) else 406), h]] (- (if a then (if false then f else l) else m)))[(if ((c - c) < (sum[l : h, m : 89] c)) then (array[l : (- f), m : 365, n : (- h)] f) else (if a then (array[l : f, m : f, n : h] l) else (array[l : 524, m : 860, n : h] h)))[(- h), (if (array[l : h, m : f] false)[f, h] then 947 else 578), f], (sum[l : h, m : f] f), 720]) 
	jno .jump4359
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4359:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump4360
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4360:
imul rdi, [rsp + 0 + 16] ; multiply by (array[l : f, m : f] ((l * (- h)) / (if true then h else 10)))[f, (sum[l : h] h)] 
	jno .jump4361
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4361:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4362: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const730] ; 4.68
	push rax
	mov rax, [rel const731] ; 64.27
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const732] ; 29.74
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4363
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4365
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4365:
	; Computing bound for 'p'
	mov rax, [rel const504] ; 16
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4366
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4366:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4367
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4367:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump4368
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4368:
	imul rdi, [rsp + 0 + 8] ; multiply by 16 
	jno .jump4369
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4369:
	imul rdi, [rsp + 0 + 16] ; multiply by (- f) 
	jno .jump4370
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4370:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4371: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const733] ; 45.34
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4371 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4371 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4371 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4364
.jump4363:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4372
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4372:
	; Computing bound for 'q'
	mov rax, [rel const734] ; 459
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4373
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4373:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4374
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4374:
	; Computing bound for 'o'
	mov rax, [rel const735] ; 349
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4375
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4375:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4376: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const736] ; 158
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'r'
	add qword [rsp + 24], 1
	; Compare r to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4376 ; If r < bound, next iter
	mov qword [rsp + 24], 0 ; r = 0
	add qword [rsp + 16], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4376 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4376 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4376 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4377
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4377:
	; Computing bound for 'p'
	mov rax, [rel const438] ; 119
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4378
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4378:
	; Computing bound for 'o'
	mov rax, [rel const737] ; 656
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4379
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4379:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by 656 
	jno .jump4380
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4380:
	imul rdi, [rsp + 0 + 8] ; multiply by 119 
	jno .jump4381
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4381:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[o : 349, p : h, q : 459, r : m] 158) 
	jno .jump4382
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4382:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4383: ; Begin body of loop
	; Compute loop body
	sub rsp, 24
	; Moving 24 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 80 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4384
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4384:
	cmp rax, [rsp + 16]
	jl .jump4385
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4385:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4386
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4386:
	cmp rax, [rsp + 24]
	jl .jump4387
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4387:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4383 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4383 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4383 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4364:
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const40] ; 714
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4388
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4388:
	cmp rax, [rsp + 24]
	jl .jump4389
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4389:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4390
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4390:
	cmp rax, [rsp + 32]
	jl .jump4391
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4391:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4392
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4392:
	cmp rax, [rsp + 40]
	jl .jump4393
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4393:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24 
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 8 ; Add alignment
	sub rsp, 32
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4394
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4394:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump4395
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4395:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4396: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4397
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4397:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump4398
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4398:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump4399: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const738] ; 28.02
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 0], 1
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4399 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 32]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4396 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4400
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4400:
	cmp rax, [rsp + 8]
	jl .jump4401
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4401:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp 
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rsi
	lea rdi, [rsp + 16]
	call _b
	add rsp, 16
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4402
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4402:
	; Computing bound for 'p'
	mov rax, [rel const500] ; 388
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4403
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4403:
	; Computing bound for 'o'
	mov rax, [rel const739] ; 435
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4404
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4404:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (- 435) 
	jno .jump4405
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4405:
	imul rdi, [rsp + 0 + 8] ; multiply by 388 
	jno .jump4406
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4406:
	imul rdi, [rsp + 0 + 16] ; multiply by (- l) 
	jno .jump4407
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4407:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4408: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4408 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4408 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4408 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4409
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4409:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4410
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4410:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4411
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4411:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump4412
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4412:
	imul rdi, [rsp + 0 + 8] ; multiply by n 
	jno .jump4413
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4413:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump4414
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4414:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4415: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4415 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4415 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4415 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4416
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4416:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4417
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4417:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4418
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4418:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by l 
	jno .jump4419
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4419:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump4420
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4420:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump4421
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4421:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4422: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'q'
	add qword [rsp + 16], 1
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4422 ; If q < bound, next iter
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4422 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4422 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rdi, 64
	call _jpl_alloc
	; Moving 64 bytes from rsp to rax 
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 64
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4423
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4423:
	cmp rax, [rsp + 8]
	jl .jump4424
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4424:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	mov rax, [rel const304] ; 487
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4425
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4425:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4426
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4426:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4427: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 296 to rsp 
		mov r10, [rbp - 296 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4427 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4427 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4428
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4428:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[o : m, p : 487] p) 
	jno .jump4429
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4429:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4430: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4431
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4431:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4432
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4432:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4433
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4433:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump4434
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4434:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump4435
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4435:
	imul rdi, [rsp + 0 + 16] ; multiply by m 
	jno .jump4436
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4436:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump4437: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4437 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4437 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4437 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4430 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4438
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4438:
	cmp rax, [rsp + 8]
	jl .jump4439
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4439:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rdi, 96
	call _jpl_alloc
	; Moving 96 bytes from rsp to rax 
		mov r10, [rsp + 88]
		mov [rax + 88], r10
		mov r10, [rsp + 80]
		mov [rax + 80], r10
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 96
	push rax
	mov rax, 3
	push rax
	call _i
	add rsp, 16
	add rsp, 32
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4362 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4362 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4362 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4246
.jump4245:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4440
	mov rax, [rel const401] ; 535
	push rax
	jmp .jump4441
.jump4440:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump4441:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4442
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4442:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4443
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4443:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4444: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp 
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4444 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4444 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4445
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4445:
	; Computing bound for 'n'
	mov rax, [rel const289] ; 675
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4446
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4446:
	; Computing bound for 'm'
	mov rax, [rel const740] ; 679
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4447
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4447:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4448
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4448:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4449: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4449 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4449 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4449 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4449 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4450
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const74] ; 68
	push rax
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4452
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4452:
	cmp rax, [rsp + 8]
	jl .jump4453
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4453:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4454
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4454:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4455
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4455:
	; Computing bound for 'l'
	mov rax, [rel const526] ; 233
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4456
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4456:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4457: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4457 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4457 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4457 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4458
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4460
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const741] ; 109
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4462
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4462:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4463
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4463:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump4464
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4464:
	imul rdi, [rsp + 0 + 8] ; multiply by 109 
	jno .jump4465
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4465:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4466: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4466 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4466 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump4461
.jump4460:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4467
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4467:
	; Computing bound for 'l'
	mov rax, [rel const590] ; 768
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4468
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4468:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by 768 
	jno .jump4469
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4469:
	imul rdi, [rsp + 0 + 8] ; multiply by (- h) 
	jno .jump4470
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4470:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4471: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4471 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4471 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump4461:
	jmp .jump4459
.jump4458:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const742] ; 46
	push rax
	mov rax, [rel const380] ; 745
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4472
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4472:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4473
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4473:
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4474
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4474:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4475
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4475:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4476
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4476:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4477: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4477 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4477 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4477 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4478
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4478:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[l : h, m : f, n : (f - h)] l) 
	jno .jump4479
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4479:
	imul rdi, [rsp + 0 + 8] ; multiply by (745 % 46) 
	jno .jump4480
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4480:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4481: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const26] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4481 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4481 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump4459:
	mov rax, [rel const283] ; 135
	push rax
	mov rax, [rel const743] ; 91.69
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4482
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump4483
.jump4482:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump4483:
	mov rax, [rel const681] ; 70
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4484
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump4484:
	cqo
	idiv r10
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const744] ; 43
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4485
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4485:
	; Computing bound for 'l'
	sub rsp, 16
	; Moving 16 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4486
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4486:
	cmp rax, [rsp + 8]
	jl .jump4487
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4487:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4488
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4488:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by e[h] 
	jno .jump4489
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4489:
	imul rdi, [rsp + 0 + 8] ; multiply by (43 + f) 
	jno .jump4490
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4490:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4491: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const745] ; 659
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4491 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4491 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4492
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const96] ; 56
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4494
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4494:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	jmp .jump4493
.jump4492:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump4493:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4495
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4495:
	cmp rax, [rsp + 16]
	jl .jump4496
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4496:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4497
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4497:
	cmp rax, [rsp + 24]
	jl .jump4498
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4498:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4499
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4499:
	cmp rax, [rsp + 16]
	jl .jump4500
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4500:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4501
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4501:
	cmp rax, [rsp + 24]
	jl .jump4502
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4502:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4451
.jump4450:
	mov rax, [rel const746] ; 31.79
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const747] ; 53.55
	push rax
	mov rax, [rel const748] ; 10.13
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	divsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
.jump4451:
	pop rax
	cmp rax, 0
	je .jump4503
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4505
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4505:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4506
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4506:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (f / (f * h)) 
	jno .jump4507
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4507:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4508: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 16
	; Moving 16 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4509
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4509:
	cmp rax, [rsp + 8]
	jl .jump4510
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4510:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4511
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4511:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4512
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4512:
	; Computing bound for 'm'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4513
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	jmp .jump4514
.jump4513:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump4514:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4515
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4515:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
	imul rdi, [rsp + 0 + 0] ; multiply by (if false then l else h) 
	jno .jump4516
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4516:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump4517
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4517:
	imul rdi, [rsp + 0 + 16] ; multiply by e[f] 
	jno .jump4518
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4518:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
.jump4519: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4520
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4520:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump4521
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4521:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump4522: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const749] ; 62.44
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'p'
	add qword [rsp + 0], 1
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4522 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'o'
	add qword [rsp + 16], 1
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4519 ; If o < bound, next iter
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4519 ; If n < bound, next iter
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4519 ; If m < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4508 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const750] ; 967
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4523
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4523:
	cmp rax, [rsp + 8]
	jl .jump4524
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4524:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4525
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4525:
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4526
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4526:
	; Computing bound for 'n'
	mov rax, [rel const751] ; 608
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4527
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4527:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4528
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4528:
	; Computing bound for 'l'
	mov rax, [rel const752] ; 363
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4529
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4529:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4530: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const753] ; 960
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4530 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4530 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4530 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4530 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4531
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4531:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4532: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4532 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4532 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4533
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4533:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4534
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4534:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4535
	mov rax, [rel const357] ; 570
	push rax
	jmp .jump4536
.jump4535:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump4536:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4537
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4537:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4538
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump4539
.jump4538:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump4539:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4540
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4540:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4541
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4541:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4542: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4543
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	jmp .jump4544
.jump4543:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump4544:
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4542 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4542 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4542 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4542 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4545
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4545:
	; Computing bound for 'l'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const268] ; 944
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4546
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4546:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4547
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4547:
	; Computing bound for 'm'
	mov rax, [rel const236] ; 889
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4548
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4548:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4549
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4549:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by (- h) 
	jno .jump4550
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4550:
	imul rdi, [rsp + 0 + 8] ; multiply by 889 
	jno .jump4551
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4551:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump4552
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4552:
	imul rdi, [rsp + 0 + 24] ; multiply by (- 944) 
	jno .jump4553
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4553:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4554: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4554 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4554 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4554 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4554 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4555
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4555:
	; Computing bound for 'n'
	mov rax, [rel const368] ; 10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4556
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4556:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4557
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4557:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4558
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4558:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump4559
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4559:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump4560
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4560:
	imul rdi, [rsp + 0 + 16] ; multiply by 10 
	jno .jump4561
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4561:
	imul rdi, [rsp + 0 + 24] ; multiply by h 
	jno .jump4562
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4562:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4563: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4563 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4563 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4563 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4563 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const754] ; 840
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4564
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4564:
	cmp rax, [rsp + 32]
	jl .jump4565
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4565:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4566
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4566:
	cmp rax, [rsp + 40]
	jl .jump4567
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4567:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4568
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4568:
	cmp rax, [rsp + 48]
	jl .jump4569
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4569:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4570
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4570:
	cmp rax, [rsp + 56]
	jl .jump4571
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4571:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4572
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4572:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4573
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4573:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4574
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump4574:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4575
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4575:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4576
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4576:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4577
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4577:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4578: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4578 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4578 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4578 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4578 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rel const755] ; 332
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4579
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4579:
	cmp rax, [rsp + 32]
	jl .jump4580
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4580:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4581
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4581:
	cmp rax, [rsp + 40]
	jl .jump4582
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4582:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4583
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4583:
	cmp rax, [rsp + 48]
	jl .jump4584
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4584:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4585
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4585:
	cmp rax, [rsp + 56]
	jl .jump4586
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4586:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4587
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4587:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
imul rdi, [rsp + 0 + 0] ; multiply by (array[l : (- h), m : 889, n : h, o : (- 944)] o)[332, (sum[l : (- f), m : h, n : (h / f), o : (f % f)] (- f)), h, (array[l : f, m : h, n : 10, o : h] l)[h, h, 840, f]] 
	jno .jump4588
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4588:
imul rdi, [rsp + 0 + 8] ; multiply by ((sum[l : (- h), m : (if a then f else f), n : (if a then 570 else f), o : (- h)] (if a then o else h)) * f) 
	jno .jump4589
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4589:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[l : (sum[l : 363, m : f, n : 608, o : f] 960), m : f] l) 
	jno .jump4590
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4590:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4591: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 16
	; Moving 16 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4592
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4592:
	cmp rax, [rsp + 8]
	jl .jump4593
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4593:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4594
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4594:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by (- e[n]) 
	jno .jump4595
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4595:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4596: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4596 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4591 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4591 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4591 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4597
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4597:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4598
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4598:
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4599
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4599:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4600
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4600:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4601
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4601:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4602
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4602:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4603: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4603 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4603 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4603 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4603 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4604
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4604:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4605
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4605:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4606
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4606:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4607: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	mov rax, [rel const61] ; 604
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4608
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4608:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4609
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4609:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4610: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4610 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4610 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4607 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4607 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4607 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4611
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4611:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4612
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4612:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump4613
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4613:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[l : f, m : h, n : (sum[l : f, m : f, n : h, o : f] n)] (sum[o : m, p : 604] m)) 
	jno .jump4614
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4614:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump4615
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4615:
	imul rdi, [rsp + 0 + 24] ; multiply by f 
	jno .jump4616
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4616:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4617: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	mov rax, [rel const50] ; 993
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4618
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4618:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4619
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4619:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4620
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4620:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump4621
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4621:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump4622
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4622:
	imul rdi, [rsp + 0 + 16] ; multiply by 993 
	jno .jump4623
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4623:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump4624: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const756] ; 78.97
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4624 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4624 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4624 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4617 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4617 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4617 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4617 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4625
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4625:
	; Computing bound for 'n'
	mov rax, [rel const427] ; 741
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4626
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4626:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4627
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4627:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4628
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4628:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump4629
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4629:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump4630
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4630:
	imul rdi, [rsp + 0 + 16] ; multiply by (- 741) 
	jno .jump4631
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4631:
	imul rdi, [rsp + 0 + 24] ; multiply by h 
	jno .jump4632
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4632:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4633: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4633 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4633 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4633 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4633 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const268] ; 944
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4634
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4634:
	cmp rax, [rsp + 32]
	jl .jump4635
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4635:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4636
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4636:
	cmp rax, [rsp + 40]
	jl .jump4637
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4637:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4638
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4638:
	cmp rax, [rsp + 48]
	jl .jump4639
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4639:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4640
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4640:
	cmp rax, [rsp + 56]
	jl .jump4641
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4641:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const675] ; 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4642
	mov rax, [rel const404] ; 493
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump4643
.jump4642:
	mov rax, [rel const734] ; 459
	push rax
.jump4643:
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4644
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4644:
	cmp rax, [rsp + 32]
	jl .jump4645
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4645:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4646
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4646:
	cmp rax, [rsp + 40]
	jl .jump4647
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4647:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4648
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4648:
	cmp rax, [rsp + 48]
	jl .jump4649
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4649:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4650
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4650:
	cmp rax, [rsp + 56]
	jl .jump4651
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4651:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4652
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4654
	mov rax, [rel const26] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump4655
.jump4654:
	mov rax, [rel const26] ; False
	push rax
.jump4655:
	pop rax
	cmp rax, 0
	je .jump4656
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4658
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4658:
	; Computing bound for 'm'
	mov rax, [rel const757] ; 650
	push rax
	mov rax, [rel const70] ; 657
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4659
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4659:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4660
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4660:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
	imul rdi, [rsp + 0 + 0] ; multiply by (- f) 
	jno .jump4661
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4661:
	imul rdi, [rsp + 0 + 8] ; multiply by (657 * 650) 
	jno .jump4662
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4662:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump4663
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4663:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4664: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4665
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4665:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump4666
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4666:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4667: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4667 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4664 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4664 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4664 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4657
.jump4656:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4668
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4668:
	; Computing bound for 'm'
	mov rax, [rel const758] ; 961
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4669
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4669:
	; Computing bound for 'l'
	mov rax, [rel const414] ; 801
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4670
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4670:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
	imul rdi, [rsp + 0 + 0] ; multiply by 801 
	jno .jump4671
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4671:
	imul rdi, [rsp + 0 + 8] ; multiply by 961 
	jno .jump4672
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4672:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump4673
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4673:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4674: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4675
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4675:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump4676
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4676:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4677: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const759] ; 31.89
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4677 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4674 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4674 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4674 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4657:
	jmp .jump4653
.jump4652:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4678
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4678:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4679
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4679:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4680
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4680:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump4681
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4681:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump4682
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4682:
	imul rdi, [rsp + 0 + 16] ; multiply by f 
	jno .jump4683
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4683:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4684: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4685
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
.jump4685:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4686
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4686:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by (n / n) 
	jno .jump4687
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4687:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4688: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const760] ; 22.1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4688 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4684 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4684 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4684 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4653:
	mov rdi, 128
	call _jpl_alloc
	; Moving 128 bytes from rsp to rax 
		mov r10, [rsp + 120]
		mov [rax + 120], r10
		mov r10, [rsp + 112]
		mov [rax + 112], r10
		mov r10, [rsp + 104]
		mov [rax + 104], r10
		mov r10, [rsp + 96]
		mov [rax + 96], r10
		mov r10, [rsp + 88]
		mov [rax + 88], r10
		mov r10, [rsp + 80]
		mov [rax + 80], r10
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 128
	push rax
	mov rax, 4
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4689
	sub rsp, 16
	; Moving 16 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4691
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4691:
	cmp rax, [rsp + 8]
	jl .jump4692
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4692:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4693
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump4694
.jump4693:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4695
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4695:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4696: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4696 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4697
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4697:
	; Computing bound for 'm'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4698
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4698:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4699: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4699 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4700
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4700:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4701
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4701:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4702: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const252] ; 729
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4702 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4702 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4702 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump4694:
	jmp .jump4690
.jump4689:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump4690:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4703
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4703:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4704: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const267] ; 555
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4704 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4705
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4705:
	cmp rax, [rsp + 8]
	jl .jump4706
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4706:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump4504
.jump4503:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4707
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4709
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4710
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump4710:
	push rax
	pop rax
	cmp rax, 0
	jne .jump4711
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump4711:
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
.jump4709:
	push rax
	pop rax
	cmp rax, 0
	je .jump4712
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4714
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4714:
	; Computing bound for 'm'
	mov rax, [rel const423] ; 117
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4715
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4715:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const450] ; 989
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4716
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4716:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4717
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4717:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
	imul rdi, [rsp + 0 + 0] ; multiply by (989 % h) 
	jno .jump4718
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4718:
	imul rdi, [rsp + 0 + 8] ; multiply by 117 
	jno .jump4719
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4719:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump4720
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4720:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4721: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const46] ; 623
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4722
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4722:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by 623 
	jno .jump4723
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4723:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4724: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4724 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4721 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4721 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4721 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4713
.jump4712:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4725
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4727
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4727:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4728
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4728:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4729: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4729 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4729 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4730
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4730:
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4731
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4731:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4732
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4732:
	; Computing bound for 'l'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4733
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4733:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4734: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment 'l'
	add qword [rsp + 0], 1
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4734 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4735
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4735:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4736: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp 
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4736 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4736 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4736 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4736 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4737
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4737:
	; Computing bound for 'm'
	mov rax, [rel const761] ; 50.47
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4738
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump4739
.jump4738:
	mov rax, [rel const481] ; 800
	push rax
.jump4739:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4740
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4740:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4741
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4741:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump4742
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4742:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (c > 50.47) then (- h) else 800) 
	jno .jump4743
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4743:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[l : (sum[l : f] h), m : h, n : h, o : (sum[l : h, m : h] m)] l) 
	jno .jump4744
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4744:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4745: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4746
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4746:
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4747
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4747:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'p' to 0
	mov rax, 0
	push rax
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4748: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'p'
	add qword [rsp + 8], 1
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4748 ; If p < bound, next iter
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4748 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4749
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4749:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[o : m, p : h] f) 
	jno .jump4750
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4750:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4751: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const762] ; 74.58
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4751 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4745 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4745 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4745 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4726
.jump4725:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'n'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4752
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4752:
	; Computing bound for 'm'
	mov rax, [rel const763] ; 425
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4753
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4753:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4754
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4754:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump4755
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4755:
	imul rdi, [rsp + 0 + 8] ; multiply by 425 
	jno .jump4756
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4756:
	imul rdi, [rsp + 0 + 16] ; multiply by (- h) 
	jno .jump4757
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4757:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4758: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4759
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4759:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump4760
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4760:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
.jump4761: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const764] ; 85.99
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'o'
	add qword [rsp + 0], 1
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4761 ; If o < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'n'
	add qword [rsp + 16], 1
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4758 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4758 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4758 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4726:
.jump4713:
	jmp .jump4708
.jump4707:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'o'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'o'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4762
	mov rax, [rel const377] ; 753
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump4763
.jump4762:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump4763:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4764
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4764:
	; Computing bound for 'n'
	mov rax, [rel const765] ; 776
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4765
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4765:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4766
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4766:
	; Computing bound for 'l'
	mov rax, [rel const766] ; 180
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4767
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4767:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4768: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4768 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4768 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4768 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4768 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4769
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4769:
	; Computing bound for 'n'
	mov rax, [rel const767] ; 30.36
	push rax
	mov rax, [rel const768] ; 9.7
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4770
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	mov rax, [rel const769] ; 205
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4772
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4772:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4773
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4773:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by h 
	jno .jump4774
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4774:
	imul rdi, [rsp + 0 + 8] ; multiply by 205 
	jno .jump4775
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4775:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4776: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4776 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4776 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump4771
.jump4770:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4777
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4777:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4778
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4778:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump4779
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4779:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump4780
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4780:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4781: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4781 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4781 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump4771:
	mov rax, [rel const11] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4782
	mov rax, [rel const770] ; 790
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump4783
.jump4782:
	sub rsp, 16
	; Moving 16 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const771] ; 171
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4784
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4784:
	cmp rax, [rsp + 8]
	jl .jump4785
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4785:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4783:
	mov rax, [rel const667] ; 92
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4786
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4786:
	cmp rax, [rsp + 16]
	jl .jump4787
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4787:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4788
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4788:
	cmp rax, [rsp + 24]
	jl .jump4789
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4789:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4790
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4790:
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const772] ; 54.69
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4791
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump4792
.jump4791:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4793
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump4794
.jump4793:
	mov rax, [rel const773] ; 99
	push rax
.jump4794:
.jump4792:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4795
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4795:
	; Computing bound for 'l'
	mov rax, [rel const26] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump4796
	mov rax, [rel const774] ; 287
	push rax
	mov rax, [rel const634] ; 63
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	jmp .jump4797
.jump4796:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'm'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4798
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4798:
	; Computing bound for 'l'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4799
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4799:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4800: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'm'
	add qword [rsp + 8], 1
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4800 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4800 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
.jump4797:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4801
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4801:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[][,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (h - (if false then (63 * 287) else (sum[l : f, m : h] f))) 
	jno .jump4802
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4802:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (54.69 < (- c)) then h else (if a then h else 99)) 
	jno .jump4803
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4803:
imul rdi, [rsp + 0 + 16] ; multiply by (if (9.7 >= 30.36) then (array[l : h, m : 205] h) else (array[l : f, m : f] f))[92, (if (! true) then (- 790) else e[171])] 
	jno .jump4804
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4804:
imul rdi, [rsp + 0 + 24] ; multiply by (sum[l : 180, m : f, n : (f + (- 776)), o : (if false then (- 753) else (- h))] n) 
	jno .jump4805
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4805:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'o' to 0
	mov rax, 0
	push rax
	; Initialize 'n' to 0
	mov rax, 0
	push rax
	; Initialize 'm' to 0
	mov rax, 0
	push rax
	; Initialize 'l' to 0
	mov rax, 0
	push rax
.jump4806: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4807
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
.jump4807:
	push rax
	pop rax
	cmp rax, 0
	je .jump4808
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	mov rax, [rel const322] ; 818
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4810
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4810:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4811
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4811:
	; Computing bound for 'p'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4812
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4812:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump4813
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4813:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump4814
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4814:
	imul rdi, [rsp + 0 + 16] ; multiply by (f - 818) 
	jno .jump4815
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4815:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump4816: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	mov rax, [rel const775] ; 337
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4817
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4817:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by 337 
	jno .jump4818
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4818:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump4819: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const776] ; 92.51
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 's'
	add qword [rsp + 0], 1
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4819 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4816 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4816 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4816 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4809
.jump4808:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'r'
	mov rax, [rel const777] ; 795
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4820
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4820:
	; Computing bound for 'q'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4821
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4821:
	; Computing bound for 'p'
	mov rax, [rel const778] ; 626
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4822
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4822:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
	imul rdi, [rsp + 0 + 0] ; multiply by 626 
	jno .jump4823
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4823:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump4824
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4824:
	imul rdi, [rsp + 0 + 16] ; multiply by 795 
	jno .jump4825
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4825:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'r' to 0
	mov rax, 0
	push rax
	; Initialize 'q' to 0
	mov rax, 0
	push rax
	; Initialize 'p' to 0
	mov rax, 0
	push rax
.jump4826: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 's'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4827
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4827:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump4828
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4828:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 's' to 0
	mov rax, 0
	push rax
.jump4829: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 's'
	add qword [rsp + 0], 1
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4829 ; If s < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'r'
	add qword [rsp + 16], 1
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4826 ; If r < bound, next iter
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4826 ; If q < bound, next iter
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4826 ; If p < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4809:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 88] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 32
	add rax, [rsp + 96]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'o'
	add qword [rsp + 24], 1
	; Compare o to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4806 ; If o < bound, next iter
	mov qword [rsp + 24], 0 ; o = 0
	add qword [rsp + 16], 1 ; n++
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4806 ; If n < bound, next iter
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4806 ; If m < bound, next iter
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4806 ; If l < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	mov rax, [rel const73] ; 938
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4830
	mov rax, [rel const101] ; 597
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump4831
.jump4830:
	mov rax, [rel const579] ; 23
	push rax
.jump4831:
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump4832
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4834
	mov rax, [rel const26] ; False
	push rax
	jmp .jump4835
.jump4834:
	mov rax, [rel const11] ; True
	push rax
.jump4835:
	jmp .jump4833
.jump4832:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump4833:
	pop rax
	cmp rax, 0
	je .jump4836
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4838
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump4838:
	push rax
	pop rax
	cmp rax, 0
	je .jump4839
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	jmp .jump4840
.jump4839:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump4840:
	jmp .jump4837
.jump4836:
	mov rax, [rel const26] ; False
	push rax
.jump4837:
	pop rax
	cmp rax, 0
	je .jump4841
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump4842
.jump4841:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump4842:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4843
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4843:
	cmp rax, [rsp + 32]
	jl .jump4844
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4844:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4845
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4845:
	cmp rax, [rsp + 40]
	jl .jump4846
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4846:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4847
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4847:
	cmp rax, [rsp + 48]
	jl .jump4848
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4848:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump4849
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4849:
	cmp rax, [rsp + 56]
	jl .jump4850
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4850:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 32
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4708:
.jump4504:
.jump4246:
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump4851
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4852
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4852:
	; Computing bound for 't'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'w'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4853
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4853:
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4854
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4854:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4855
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4855:
	; Computing bound for 't'
	mov rax, [rel const779] ; 927
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4856
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4856:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'w' to 0
	mov rax, 0
	push rax
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump4857: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'w'
	add qword [rsp + 24], 1
	; Compare w to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump4857 ; If w < bound, next iter
	mov qword [rsp + 24], 0 ; w = 0
	add qword [rsp + 16], 1 ; v++
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump4857 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump4857 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump4857 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4858
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump4859
.jump4858:
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
.jump4859:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4860
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4860:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (if ((- f) <= (sum[t : 927, u : o, v : h, w : n] v)) then h else o) 
	jno .jump4861
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4861:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump4862
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4862:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump4863: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const403] ; 297
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 8], 1
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4863 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4863 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const780] ; 42
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4864
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump4864:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4865
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4865:
	cmp rax, [rsp + 16]
	jl .jump4866
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4866:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4867
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4867:
	cmp rax, [rsp + 24]
	jl .jump4868
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4868:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; True
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4869
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump4869:
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4870
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4870:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4871
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4871:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump4872
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4872:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump4873
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4873:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump4874: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'u'
	add qword [rsp + 8], 1
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4874 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4874 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4875
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4875:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4876
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4876:
	; Computing bound for 't'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4877
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4877:
	; Computing bound for 't'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4878
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4878:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump4879: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment 'u'
	add qword [rsp + 8], 1
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4879 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4879 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4880
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4880:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
	; Initialize 't' to 0
	mov rax, 0
	push rax
.jump4881: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const523] ; 611
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4882
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	jmp .jump4883
.jump4882:
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
.jump4883:
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment 'v'
	add qword [rsp + 16], 1
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4881 ; If v < bound, next iter
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4881 ; If u < bound, next iter
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4881 ; If t < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4884
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4884:
	cmp rax, [rsp + 16]
	jl .jump4885
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4885:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4886
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4886:
	cmp rax, [rsp + 24]
	jl .jump4887
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4887:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
.jump4851:
	push rax
	pop rax
	xor rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4888
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump4889
.jump4888:
	mov rax, [rel const11] ; True
	push rax
.jump4889:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4890
	sub rsp, 24
	; Moving 24 bytes from rbp - 80 to rsp 
		mov r10, [rbp - 80 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 80 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	jmp .jump4891
.jump4890:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'v'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4892
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4892:
	; Computing bound for 'u'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4893
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const20] ; 'divide by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4893:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4894
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4894:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof rgba 
	imul rdi, [rsp + 0 + 0] ; multiply by ((- (- r)) / m) 
	jno .jump4895
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4895:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump4896
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4896:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'v' to 0
	mov rax, 0
	push rax
	; Initialize 'u' to 0
	mov rax, 0
	push rax
.jump4897: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4898
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump4899
.jump4898:
	mov rax, [rel const781] ; 10.54
	push rax
.jump4899:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rsi
	lea rdi, [rsp + 16]
	call _b
	add rsp, 16
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'v'
	add qword [rsp + 8], 1
	; Compare v to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump4897 ; If v < bound, next iter
	mov qword [rsp + 8], 0 ; v = 0
	add qword [rsp + 0], 1 ; u++
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump4897 ; If u < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump4891:
	lea rdi, [rel const782] ; 'x'
	call _print
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const783] ; 5.22
	push rax
	mov rax, [rel const784] ; 56.32
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4900
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump4901
.jump4900:
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
.jump4901:
	pop rax
	cmp rax, 0
	je .jump4902
	mov rax, [rel const785] ; 82.56
	push rax
	mov rdi, 8
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4904
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4904:
	cmp rax, [rsp + 8]
	jl .jump4905
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4905:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4906
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4908
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump4909
.jump4908:
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
.jump4909:
	pop rax
	cmp rax, 0
	je .jump4910
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4912
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4912:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4913
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4913:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4914
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4914:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump4915
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4915:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump4916
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4916:
	imul rdi, [rsp + 0 + 16] ; multiply by s 
	jno .jump4917
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4917:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump4918: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4918 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4918 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4918 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4911
.jump4910:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4919
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4919:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4920
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4920:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4921
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4921:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by o 
	jno .jump4922
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4922:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump4923
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4923:
	imul rdi, [rsp + 0 + 16] ; multiply by o 
	jno .jump4924
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4924:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump4925: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const26] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4925 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4925 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4925 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4911:
	jmp .jump4907
.jump4906:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump4926
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4926:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4927
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4927:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4928
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4928:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4929
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4929:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (- o) 
	jno .jump4930
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4930:
	imul rdi, [rsp + 0 + 8] ; multiply by w 
	jno .jump4931
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4931:
	imul rdi, [rsp + 0 + 16] ; multiply by (o % o) 
	jno .jump4932
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4932:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump4933: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4933 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4933 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4933 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4907:
	jmp .jump4903
.jump4902:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4934
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4934:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4935
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4935:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4936
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4936:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump4937
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4937:
	imul rdi, [rsp + 0 + 8] ; multiply by q 
	jno .jump4938
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4938:
	imul rdi, [rsp + 0 + 16] ; multiply by w 
	jno .jump4939
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4939:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump4940: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4940 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4940 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4940 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4941
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4941:
	cmp rax, [rsp + 24]
	jl .jump4942
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4942:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4943
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4943:
	cmp rax, [rsp + 32]
	jl .jump4944
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4944:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4945
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4945:
	cmp rax, [rsp + 40]
	jl .jump4946
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4946:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4947
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4947:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4948
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4948:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump4949
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4951
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4951:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4952
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4952:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4953
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4953:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump4954
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4954:
	imul rdi, [rsp + 0 + 8] ; multiply by v 
	jno .jump4955
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4955:
	imul rdi, [rsp + 0 + 16] ; multiply by y 
	jno .jump4956
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4956:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump4957: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 264 to rsp 
		mov r10, [rbp - 264 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4957 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4957 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4957 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump4950
.jump4949:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4958
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4958:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4959
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4959:
	; Computing bound for 'z'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4960
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4960:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump4961
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4961:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump4962
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4962:
	imul rdi, [rsp + 0 + 16] ; multiply by n 
	jno .jump4963
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4963:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump4964: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4964 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4964 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4964 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4950:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const325] ; 274
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4965
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4965:
	cmp rax, [rsp + 24]
	jl .jump4966
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4966:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4967
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4967:
	cmp rax, [rsp + 32]
	jl .jump4968
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4968:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4969
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4969:
	cmp rax, [rsp + 40]
	jl .jump4970
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4970:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4971
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4971:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
imul rdi, [rsp + 0 + 0] ; multiply by (if (v <= h) then (array[z : w, A : v, B : y] A) else (array[z : q, A : f, B : n] v))[274, f, f] 
	jno .jump4972
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4972:
	imul rdi, [rsp + 0 + 8] ; multiply by x 
	jno .jump4973
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4973:
imul rdi, [rsp + 0 + 16] ; multiply by (array[z : x, A : q, B : w] A)[y, (q + v), x] 
	jno .jump4974
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump4974:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
	; Initialize 'z' to 0
	mov rax, 0
	push rax
.jump4975: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const11] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'B'
	add qword [rsp + 16], 1
	; Compare B to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4975 ; If B < bound, next iter
	mov qword [rsp + 16], 0 ; B = 0
	add qword [rsp + 8], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4975 ; If A < bound, next iter
	mov qword [rsp + 8], 0 ; A = 0
	add qword [rsp + 0], 1 ; z++
	; Compare z to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4975 ; If z < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump4903:
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4976
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4976:
	cmp rax, [rsp + 24]
	jl .jump4977
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4977:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump4978
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4978:
	cmp rax, [rsp + 32]
	jl .jump4979
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4979:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump4980
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4980:
	cmp rax, [rsp + 40]
	jl .jump4981
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4981:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump4982
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump4982:
	push rax
	pop rax
	xor rax, 1
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4983
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	jmp .jump4984
.jump4983:
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
.jump4984:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4985
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4985:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by (if z then y else x) 
	jno .jump4986
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4986:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump4987: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4988
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	jmp .jump4989
.jump4988:
	mov rax, [rel const26] ; False
	push rax
.jump4989:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'A'
	add qword [rsp + 0], 1
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump4987 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4990
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4990:
	cmp rax, [rsp + 8]
	jl .jump4991
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4991:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump4992
	mov rax, [rel const768] ; 9.7
	push rax
	jmp .jump4993
.jump4992:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4994
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4994:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4995
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump4995:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4996
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4996:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump4997: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const786] ; 18.5
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 48] ; Load sum
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump4997 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump4997 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump4997 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump4998
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump4998:
	cmp rax, [rsp + 8]
	jl .jump4999
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump4999:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump4993:
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5000
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump5001
.jump5000:
	sub rsp, 32
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5002
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5002:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump5003
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5003:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5004: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'A'
	add qword [rsp + 0], 1
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5004 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rsi
	lea rdi, [rsp + 16]
	call _b
	add rsp, 16
	; Moving 8 bytes from rsp + 24 to rsp + 24 
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
.jump5001:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5005
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
.jump5005:
	push rax
	pop rax
	cmp rax, 0
	je .jump5006
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'A'
	mov rax, [rel const561] ; 736
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5008
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5008:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5009: ; Begin body of loop
	; Compute loop body
	mov rax, [rel const787] ; 18.15
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	addsd xmm0, [rsp + 16] ; Load sum
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment 'A'
	add qword [rsp + 0], 1
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5009 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5010
	sub rsp, 8
	; Moving 8 bytes from rbp - 200 to rsp 
		mov r10, [rbp - 200 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5012
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5014
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5014:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[][,,][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump5015
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5015:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5016: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5017
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5019
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5019:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5020
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5020:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5021
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5021:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump5022
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5022:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump5023
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5023:
	imul rdi, [rsp + 0 + 16] ; multiply by h 
	jno .jump5024
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5024:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump5025: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'D'
	add qword [rsp + 16], 1
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5025 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5025 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5025 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump5018
.jump5017:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5026
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5026:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5027
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5027:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5028
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5028:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump5029
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5029:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump5030
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5030:
	imul rdi, [rsp + 0 + 16] ; multiply by w 
	jno .jump5031
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5031:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump5032: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'D'
	add qword [rsp + 16], 1
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5032 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5032 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5032 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump5018:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'A'
	add qword [rsp + 0], 1
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5016 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump5013
.jump5012:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5033
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5033:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5034
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5034:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5035
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5035:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump5036
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5036:
	imul rdi, [rsp + 0 + 8] ; multiply by y 
	jno .jump5037
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5037:
	imul rdi, [rsp + 0 + 16] ; multiply by o 
	jno .jump5038
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5038:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5039: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp 
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5040
	sub rsp, 32
	; Moving 32 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	jmp .jump5041
.jump5040:
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
.jump5041:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5039 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5039 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5039 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5042
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5042:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5043
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5043:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5044
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5044:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump5045
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5045:
	imul rdi, [rsp + 0 + 8] ; multiply by h 
	jno .jump5046
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5046:
	imul rdi, [rsp + 0 + 16] ; multiply by f 
	jno .jump5047
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5047:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5048: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5048 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5048 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5048 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5049
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5049:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5050
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5050:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5051
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5051:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by s 
	jno .jump5052
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5052:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump5053
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5053:
	imul rdi, [rsp + 0 + 16] ; multiply by w 
	jno .jump5054
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5054:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5055: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5055 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5055 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5055 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rdi, 96
	sub rsp, 8 ; Add alignment
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 96 bytes from rsp to rax 
		mov r10, [rsp + 88]
		mov [rax + 88], r10
		mov r10, [rsp + 80]
		mov [rax + 80], r10
		mov r10, [rsp + 72]
		mov [rax + 72], r10
		mov r10, [rsp + 64]
		mov [rax + 64], r10
		mov r10, [rsp + 56]
		mov [rax + 56], r10
		mov r10, [rsp + 48]
		mov [rax + 48], r10
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 96
	push rax
	mov rax, 3
	push rax
.jump5013:
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5056
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5056:
	cmp rax, [rsp + 8]
	jl .jump5057
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5057:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5011
.jump5010:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	mov rax, [rel const384] ; 339
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5058
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5058:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5059
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5059:
	; Computing bound for 'A'
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5060
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5060:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5061
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5061:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5062
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5062:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5063
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5063:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5064: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5064 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5064 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5064 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5064 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5065
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5065:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[][,,] 
imul rdi, [rsp + 0 + 0] ; multiply by (sum[A : s, B : o, C : s, D : y] y) 
	jno .jump5066
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5066:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump5067
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5067:
	imul rdi, [rsp + 0 + 16] ; multiply by 339 
	jno .jump5068
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5068:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5069: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5070
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5072
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	jmp .jump5073
.jump5072:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump5073:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5074
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5074:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 240 to rsp 
		mov r10, [rbp - 240 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5075
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5075:
	; Computing bound for 'D'
	mov rax, [rel const145] ; 640
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5076
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5076:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 640 
	jno .jump5077
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5077:
	imul rdi, [rsp + 0 + 8] ; multiply by C 
	jno .jump5078
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5078:
	imul rdi, [rsp + 0 + 16] ; multiply by (if true then y else h) 
	jno .jump5079
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5079:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump5080: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'F'
	add qword [rsp + 16], 1
	; Compare F to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5080 ; If F < bound, next iter
	mov qword [rsp + 16], 0 ; F = 0
	add qword [rsp + 8], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5080 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5080 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5081
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5081:
	cmp rax, [rsp + 24]
	jl .jump5082
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5082:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5083
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5083:
	cmp rax, [rsp + 32]
	jl .jump5084
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5084:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5085
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5085:
	cmp rax, [rsp + 40]
	jl .jump5086
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5086:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5071
.jump5070:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5087
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5087:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5088
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5088:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5089
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5089:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump5090
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5090:
	imul rdi, [rsp + 0 + 8] ; multiply by A 
	jno .jump5091
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5091:
	imul rdi, [rsp + 0 + 16] ; multiply by o 
	jno .jump5092
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5092:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump5093: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'F'
	add qword [rsp + 16], 1
	; Compare F to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5093 ; If F < bound, next iter
	mov qword [rsp + 16], 0 ; F = 0
	add qword [rsp + 8], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5093 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5093 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const26] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump5094
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for 'G'
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5096
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5096:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5097
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5097:
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5098
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5098:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5099
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5099:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
.jump5100: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 64], rax ; Add loop body to sum
	; Increment 'G'
	add qword [rsp + 24], 1
	; Compare G to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5100 ; If G < bound, next iter
	mov qword [rsp + 24], 0 ; G = 0
	add qword [rsp + 16], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5100 ; If F < bound, next iter
	mov qword [rsp + 16], 0 ; F = 0
	add qword [rsp + 8], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5100 ; If E < bound, next iter
	mov qword [rsp + 8], 0 ; E = 0
	add qword [rsp + 0], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5100 ; If D < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; Free all loop bounds
	add rsp, 32
	; sum left on stack
	jmp .jump5095
.jump5094:
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
.jump5095:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5101
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5101:
	cmp rax, [rsp + 24]
	jl .jump5102
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5102:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5103
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5103:
	cmp rax, [rsp + 32]
	jl .jump5104
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5104:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5105
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5105:
	cmp rax, [rsp + 40]
	jl .jump5106
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5106:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5071:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5069 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5069 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5069 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump5011:
	jmp .jump5007
.jump5006:
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5107
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	jmp .jump5108
.jump5107:
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
.jump5108:
	pop rax
	cmp rax, 0
	je .jump5109
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5111
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5111:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5112
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5112:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5113
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5113:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump5114
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5114:
	imul rdi, [rsp + 0 + 8] ; multiply by m 
	jno .jump5115
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5115:
	imul rdi, [rsp + 0 + 16] ; multiply by o 
	jno .jump5116
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5116:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5117: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5117 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5117 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5117 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5118
	sub rsp, 16
	; Moving 16 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump5119
.jump5118:
	sub rsp, 16
	; Moving 16 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump5119:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5120
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5120:
	cmp rax, [rsp + 8]
	jl .jump5121
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5121:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5122
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5122:
	cmp rax, [rsp + 24]
	jl .jump5123
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5123:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5124
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5124:
	cmp rax, [rsp + 32]
	jl .jump5125
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5125:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5126
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5126:
	cmp rax, [rsp + 40]
	jl .jump5127
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5127:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump5128
	mov rax, [rel const11] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump5130
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5132
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5132:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5133
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5133:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[][,,][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by x 
	jno .jump5134
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5134:
	imul rdi, [rsp + 0 + 8] ; multiply by (q * s) 
	jno .jump5135
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5135:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5136: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5137
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5137:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5138
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5138:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5139
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5139:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by y 
	jno .jump5140
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5140:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump5141
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5141:
	imul rdi, [rsp + 0 + 16] ; multiply by w 
	jno .jump5142
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5142:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump5143: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 112 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 112 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'E'
	add qword [rsp + 16], 1
	; Compare E to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5143 ; If E < bound, next iter
	mov qword [rsp + 16], 0 ; E = 0
	add qword [rsp + 8], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5143 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5143 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5136 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5136 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump5131
.jump5130:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5144
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5144:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5145
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5145:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[][,,][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by q 
	jno .jump5146
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5146:
	imul rdi, [rsp + 0 + 8] ; multiply by x 
	jno .jump5147
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5147:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5148: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5149
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5149:
	; Computing bound for 'D'
	mov rax, [rel const405] ; 44
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5150
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5150:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5151
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5151:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump5152
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5152:
	imul rdi, [rsp + 0 + 8] ; multiply by 44 
	jno .jump5153
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5153:
	imul rdi, [rsp + 0 + 16] ; multiply by o 
	jno .jump5154
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5154:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump5155: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'E'
	add qword [rsp + 16], 1
	; Compare E to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5155 ; If E < bound, next iter
	mov qword [rsp + 16], 0 ; E = 0
	add qword [rsp + 8], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5155 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5155 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5148 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5148 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump5131:
	jmp .jump5129
.jump5128:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5156
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5156:
	; Computing bound for 'A'
	mov rax, [rel const774] ; 287
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5157
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5157:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[][,,][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by 287 
	jno .jump5158
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5158:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump5159
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5159:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5160: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'E'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5161
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5161:
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5162
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5162:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5163
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5163:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by n 
	jno .jump5164
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5164:
	imul rdi, [rsp + 0 + 8] ; multiply by y 
	jno .jump5165
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5165:
	imul rdi, [rsp + 0 + 16] ; multiply by x 
	jno .jump5166
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5166:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'E' to 0
	mov rax, 0
	push rax
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
.jump5167: ; Begin body of loop
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 144 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 144 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'E'
	add qword [rsp + 16], 1
	; Compare E to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5167 ; If E < bound, next iter
	mov qword [rsp + 16], 0 ; E = 0
	add qword [rsp + 8], 1 ; D++
	; Compare D to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5167 ; If D < bound, next iter
	mov qword [rsp + 8], 0 ; D = 0
	add qword [rsp + 0], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5167 ; If C < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'B'
	add qword [rsp + 8], 1
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump5160 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump5160 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump5129:
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5168
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5168:
	; Computing bound for 'B'
	mov rax, [rel const711] ; 864
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5169
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5169:
	; Computing bound for 'A'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5170
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5170:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by f 
	jno .jump5171
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5171:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5172: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'A'
	add qword [rsp + 0], 1
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5172 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5173
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5173:
	cmp rax, [rsp + 8]
	jl .jump5174
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5174:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5175
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5175:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
imul rdi, [rsp + 0 + 0] ; multiply by (array[A : f] s)[q] 
	jno .jump5176
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5176:
	imul rdi, [rsp + 0 + 8] ; multiply by 864 
	jno .jump5177
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5177:
	imul rdi, [rsp + 0 + 16] ; multiply by r 
	jno .jump5178
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5178:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5179: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'C'
	add qword [rsp + 16], 1
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5179 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5179 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5179 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5180
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5180:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5181
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5181:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5182
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5182:
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5183
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5183:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by v 
	jno .jump5184
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5184:
	imul rdi, [rsp + 0 + 8] ; multiply by x 
	jno .jump5185
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5185:
	imul rdi, [rsp + 0 + 16] ; multiply by y 
	jno .jump5186
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5186:
	imul rdi, [rsp + 0 + 24] ; multiply by m 
	jno .jump5187
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5187:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 32], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5188: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 328 to rsp 
		mov r10, [rbp - 328 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 8
	add rax, [rsp + 72]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'D'
	add qword [rsp + 24], 1
	; Compare D to its bound
	mov rax, [rsp + 24]
	cmp rax, [rsp + 56]
	jl .jump5188 ; If D < bound, next iter
	mov qword [rsp + 24], 0 ; D = 0
	add qword [rsp + 16], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 48]
	jl .jump5188 ; If C < bound, next iter
	mov qword [rsp + 16], 0 ; C = 0
	add qword [rsp + 8], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 40]
	jl .jump5188 ; If B < bound, next iter
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 32]
	jl .jump5188 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 32
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5189
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5189:
	cmp rax, [rsp + 32]
	jl .jump5190
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5190:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5191
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5191:
	cmp rax, [rsp + 40]
	jl .jump5192
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5192:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5193
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5193:
	cmp rax, [rsp + 48]
	jl .jump5194
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5194:
	mov rax, [rsp + 24]
	cmp rax, 0
	jge .jump5195
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5195:
	cmp rax, [rsp + 56]
	jl .jump5196
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5196:
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 64]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 40
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5197
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5197:
	cmp rax, [rsp + 24]
	jl .jump5198
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5198:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5199
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5199:
	cmp rax, [rsp + 32]
	jl .jump5200
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5200:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5201
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5201:
	cmp rax, [rsp + 40]
	jl .jump5202
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5202:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5203
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5203:
	cmp rax, [rsp + 16]
	jl .jump5204
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5204:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5205
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5205:
	cmp rax, [rsp + 24]
	jl .jump5206
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5206:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump5110
.jump5109:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'A'
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump5207
	lea rdi, [rel const39] ; 'mod by zero'
	call _fail_assertion
.jump5207:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5208
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5208:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[][,,][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (v - (w % q)) 
	jno .jump5209
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5209:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'A' to 0
	mov rax, 0
	push rax
.jump5210: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'D'
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5211
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5211:
	; Computing bound for 'C'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5212
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5212:
	; Computing bound for 'B'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5213
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5213:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[][,,] 
	imul rdi, [rsp + 0 + 0] ; multiply by (m + y) 
	jno .jump5214
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5214:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump5215
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5215:
	imul rdi, [rsp + 0 + 16] ; multiply by A 
	jno .jump5216
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5216:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'D' to 0
	mov rax, 0
	push rax
	; Initialize 'C' to 0
	mov rax, 0
	push rax
	; Initialize 'B' to 0
	mov rax, 0
	push rax
.jump5217: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'G'
	mov rax, [rel const788] ; 941
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5218
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5218:
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5219
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5219:
	; Computing bound for 'E'
	sub rsp, 16
	; Moving 16 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5220
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5220:
	cmp rax, [rsp + 8]
	jl .jump5221
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5221:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5222
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5222:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[] 
	imul rdi, [rsp + 0 + 0] ; multiply by e[v] 
	jno .jump5223
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5223:
	imul rdi, [rsp + 0 + 8] ; multiply by s 
	jno .jump5224
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5224:
	imul rdi, [rsp + 0 + 16] ; multiply by (- 941) 
	jno .jump5225
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5225:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'G' to 0
	mov rax, 0
	push rax
	; Initialize 'F' to 0
	mov rax, 0
	push rax
	; Initialize 'E' to 0
	mov rax, 0
	push rax
.jump5226: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'H'
	sub rsp, 8
	; Moving 8 bytes from rbp - 320 to rsp 
		mov r10, [rbp - 320 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5227
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump5227:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float 
	imul rdi, [rsp + 0 + 0] ; multiply by G 
	jno .jump5228
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump5228:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'H' to 0
	mov rax, 0
	push rax
.jump5229: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp 
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'H'
	add qword [rsp + 0], 1
	; Compare H to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5229 ; If H < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax 
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment 'G'
	add qword [rsp + 16], 1
	; Compare G to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5226 ; If G < bound, next iter
	mov qword [rsp + 16], 0 ; G = 0
	add qword [rsp + 8], 1 ; F++
	; Compare F to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5226 ; If F < bound, next iter
	mov qword [rsp + 8], 0 ; F = 0
	add qword [rsp + 0], 1 ; E++
	; Compare E to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5226 ; If E < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'D'
	add qword [rsp + 16], 1
	; Compare D to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump5217 ; If D < bound, next iter
	mov qword [rsp + 16], 0 ; D = 0
	add qword [rsp + 8], 1 ; C++
	; Compare C to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump5217 ; If C < bound, next iter
	mov qword [rsp + 8], 0 ; C = 0
	add qword [rsp + 0], 1 ; B++
	; Compare B to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump5217 ; If B < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment 'A'
	add qword [rsp + 0], 1
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5210 ; If A < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5230
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5230:
	cmp rax, [rsp + 8]
	jl .jump5231
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5231:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump5110:
.jump5007:
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp 
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump5232
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5232:
	cmp rax, [rsp + 24]
	jl .jump5233
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5233:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump5234
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5234:
	cmp rax, [rsp + 32]
	jl .jump5235
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5235:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump5236
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump5236:
	cmp rax, [rsp + 40]
	jl .jump5237
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump5237:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp 
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 176 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	lea rdi, [rel const789] ; 'E.png'
	call _write_image
	add rsp, 24
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'F'
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp 
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump5481
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5481:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by r 
	jno .jump5482
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump5482:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize 'F' to 0
	mov rax, 0
	push rax
.jump5483: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'F'
	add qword [rsp + 0], 1
	; Compare F to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jl .jump5483 ; If F < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - 176 to rsp 
		mov r10, [rbp - 176 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 176 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'S'
	sub rsp, 8
	; Moving 8 bytes from rbp - 256 to rsp 
		mov r10, [rbp - 256 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7078
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7078:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7079
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump7079:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int 
	imul rdi, [rsp + 0 + 0] ; multiply by B 
	jno .jump7080
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump7080:
	imul rdi, [rsp + 0 + 8] ; multiply by K 
	jno .jump7081
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
.jump7081:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump7082: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 128 to rsp 
		mov r10, [rbp - 128 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'S'
	add qword [rsp + 8], 1
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7082 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7082 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 288 to rsp 
		mov r10, [rbp - 288 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7083
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump7083:
	cmp rax, [rsp + 16]
	jl .jump7084
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump7084:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7085
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump7085:
	cmp rax, [rsp + 24]
	jl .jump7086
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump7086:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp 
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7087
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump7087:
	; Computing bound for 'R'
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp 
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7088
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7088:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by w 
	jno .jump7089
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7089:
imul rdi, [rsp + 0 + 8] ; multiply by (- (array[R : B, S : K] s)[P, G]) 
	jno .jump7090
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7090:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'S' to 0
	mov rax, 0
	push rax
	; Initialize 'R' to 0
	mov rax, 0
	push rax
.jump7091: ; Begin body of loop
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp 
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump7092
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7094
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7094:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7095
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump7095:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 344 to rsp 
		mov r10, [rbp - 344 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7096
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7096:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by R 
	jno .jump7097
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7097:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump7098
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7098:
	imul rdi, [rsp + 0 + 16] ; multiply by Q 
	jno .jump7099
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7099:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump7100: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp 
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7101
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump7101:
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from rbp - 216 to rsp 
		mov r10, [rbp - 216 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7102
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7102:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by D 
	jno .jump7103
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7103:
	imul rdi, [rsp + 0 + 8] ; multiply by f 
	jno .jump7104
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7104:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'X' to 0
	mov rax, 0
	push rax
	; Initialize 'W' to 0
	mov rax, 0
	push rax
.jump7105: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _J
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'X'
	add qword [rsp + 8], 1
	; Compare X to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7105 ; If X < bound, next iter
	mov qword [rsp + 8], 0 ; X = 0
	add qword [rsp + 0], 1 ; W++
	; Compare W to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7105 ; If W < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'V'
	add qword [rsp + 16], 1
	; Compare V to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7100 ; If V < bound, next iter
	mov qword [rsp + 16], 0 ; V = 0
	add qword [rsp + 8], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7100 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7100 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump7093
.jump7092:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'V'
	sub rsp, 8
	; Moving 8 bytes from rbp - 280 to rsp 
		mov r10, [rbp - 280 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7106
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7106:
	; Computing bound for 'U'
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp 
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7107
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump7107:
	; Computing bound for 'T'
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7108
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7108:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof void[,] 
	imul rdi, [rsp + 0 + 0] ; multiply by m 
	jno .jump7109
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7109:
	imul rdi, [rsp + 0 + 8] ; multiply by o 
	jno .jump7110
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7110:
	imul rdi, [rsp + 0 + 16] ; multiply by Q 
	jno .jump7111
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7111:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize 'V' to 0
	mov rax, 0
	push rax
	; Initialize 'U' to 0
	mov rax, 0
	push rax
	; Initialize 'T' to 0
	mov rax, 0
	push rax
.jump7112: ; Begin body of loop
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for 'X'
	sub rsp, 8
	; Moving 8 bytes from rbp - 184 to rsp 
		mov r10, [rbp - 184 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7113
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
.jump7113:
	; Computing bound for 'W'
	sub rsp, 8
	; Moving 8 bytes from rbp - 192 to rsp 
		mov r10, [rbp - 192 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump7114
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const1] ; 'non-positive loop bound'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7114:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof void 
	imul rdi, [rsp + 0 + 0] ; multiply by y 
	jno .jump7115
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7115:
	imul rdi, [rsp + 0 + 8] ; multiply by x 
	jno .jump7116
	sub rsp, 8 ; Add alignment
	lea rdi, [rel const10] ; 'overflow computing array size'
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump7116:
	sub rsp, 8 ; Add alignment
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize 'X' to 0
	mov rax, 0
	push rax
	; Initialize 'W' to 0
	mov rax, 0
	push rax
.jump7117: ; Begin body of loop
	; Compute loop body
	sub rsp, 8 ; Add alignment
	call _J
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax 
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment 'X'
	add qword [rsp + 8], 1
	; Compare X to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7117 ; If X < bound, next iter
	mov qword [rsp + 8], 0 ; X = 0
	add qword [rsp + 0], 1 ; W++
	; Compare W to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7117 ; If W < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'V'
	add qword [rsp + 16], 1
	; Compare V to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump7112 ; If V < bound, next iter
	mov qword [rsp + 16], 0 ; V = 0
	add qword [rsp + 8], 1 ; U++
	; Compare U to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump7112 ; If U < bound, next iter
	mov qword [rsp + 8], 0 ; U = 0
	add qword [rsp + 0], 1 ; T++
	; Compare T to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jl .jump7112 ; If T < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump7093:
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp 
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp 
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump7118
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump7118:
	cmp rax, [rsp + 24]
	jl .jump7119
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump7119:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump7120
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump7120:
	cmp rax, [rsp + 32]
	jl .jump7121
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump7121:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump7122
	lea rdi, [rel const6] ; 'negative array index'
	call _fail_assertion
.jump7122:
	cmp rax, [rsp + 40]
	jl .jump7123
	lea rdi, [rel const7] ; 'index too large'
	call _fail_assertion
.jump7123:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp 
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 24
	add rax, [rsp + 56]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax 
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment 'S'
	add qword [rsp + 8], 1
	; Compare S to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7091 ; If S < bound, next iter
	mov qword [rsp + 8], 0 ; S = 0
	add qword [rsp + 0], 1 ; R++
	; Compare R to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jl .jump7091 ; If R < bound, next iter
	; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8 ; Add alignment
	call _J
	add rsp, 8 ; Remove alignment
	push rax
	call _d
	add rsp, 8
	add rsp, 24
	push rax
	pop rax
	cmp rax, 0
	je .jump7124
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp 
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	jmp .jump7125
.jump7124:
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp 
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 248 to rsp 
		mov r10, [rbp - 248 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
.jump7125:
	sub rsp, 8
	; Moving 8 bytes from rbp - 224 to rsp 
		mov r10, [rbp - 224 + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax 
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 4
	push rax
	sub rsp, 24
	lea rdi, [rsp]
	sub rsp, 8 ; Add alignment
	lea rsi, [rel const837] ; 'S.png'
	call _read_image
	add rsp, 8 ; Remove alignment
	add rsp, 320 ; Local variables
	pop r12 ; begin jpl_main postlude
	pop rbp
	ret

